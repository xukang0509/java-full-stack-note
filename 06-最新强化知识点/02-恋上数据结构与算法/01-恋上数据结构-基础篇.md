# 恋上数据结构-基础篇

+++

## 零、复杂度知识以及LeetCode刷题指南

### 1 什么是算法？

算法是用于解决特定问题的一系列的执行步骤。

以下算法是为了解决**两数相加**的问题：

```java
// 计算a和b的和
public static int plue(int a, int b){
	return a + b;
}
```

以下算法是为了解决**n个数字的和**的问题：

```java
// 1+2+3+...+n
public static int sum(int n){
	int result = 0;
	for(int i = 1; i <= n; i++){
		result += i;
	}
	return result;
}
```

使用不同算法，解决同一个问题，效率可能相差非常大。比如：

**求第 n 个斐波那契数（fibonacci number）**



### 2 如何评判一个算法的好坏？

如果单从执行效率上进行评估，可能会想到这么一种方案：

- 比较不同算法对同一组输入的执行处理时间
- 这种方案也叫做：事后统计法

上述方案有比较明显的缺点：

- 执行时间严重依赖硬件以及运行时各种不确定的环境因素
- 必须编写相应的测算代码
- 测试数据的选择比较难保证公正性

一般从以下维度来评估算法的优劣：

- 正确性、可读性、健壮性（对不合理输入的反应能力和处理能力）
- **时间复杂度（time complexity）**：估算程序指令的执行次数（执行时间）
- **空间复杂度（space complexity）**：估算所需占用的存储空间

由于现在硬件发展的较好，一般情况下我们更侧重于**时间复杂度**。

> 附：
>
> 下面代码是一个测试时间效率的小工具：
>
> ```java
> package com.mj;
> 
> import java.text.SimpleDateFormat;
> import java.util.Date;
> 
> /**
>  * 测试时间效率的小工具
>  */
> public class Times {
> 	private static final SimpleDateFormat fmt = new SimpleDateFormat("HH:mm:ss.SSS");
> 	
> 	public interface Task {
> 		void execute();
> 	}
> 	
> 	public static void test(String title, Task task) {
> 		if (task == null) return;
> 		title = (title == null) ? "" : ("【" + title + "】");
> 		System.out.println(title);
> 		System.out.println("开始：" + fmt.format(new Date()));
> 		long begin = System.currentTimeMillis(); // 开始时间
> 		task.execute(); // 执行代码
> 		long end = System.currentTimeMillis(); // 结束时间
> 		System.out.println("结束：" + fmt.format(new Date()));
> 		double delta = (end - begin) / 1000.0; // 毫秒转换为秒
> 		System.out.println("耗时：" + delta + "秒");
> 		System.out.println("-------------------------------------");
> 	}
> }
> ```



### 3 大O表示法（Big O）

一般用大O表示法来描述复杂度，它表示的是数据规模 n 对应的复杂度。

忽略常数、系数、低阶：

- 9 >> O(1)
- 2n + 3 >> O(n)
- n<sup>2</sup> + 2n + 6 >> O(n^2)
- 4n<sup>3</sup> + 3n<sup>2</sup> + 22n + 100 >> O(n<sup>3</sup>)
- 写法上，n<sup>3</sup> 等价于 n^3

注意：大O表示法仅仅是一种粗略的**分析模型**，是一种**估算**，能帮助我们短时间内了解一个算法的执行效率。



#### 3.1 对数阶的细节

对数阶一般省略底数：

- 由于 log<sub>2</sub>9 ∗ log<sub>9</sub>n >> log<sub>2</sub>n，即每个对数基本都可以常数乘另一个对数
- 所以 O(log<sub>2</sub>n) 、O(log<sub>9</sub>n) 统称为 **O(logn)**



#### 3.2 常见的复杂度

![img](01-恋上数据结构-基础篇.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzczNDA5NQ==,size_1,color_FFFFFF,t_70.png)

![img](01-恋上数据结构-基础篇.assets/20200326125254163.png)

> 可以借助函数生成工具对比复杂度的大小：https://zh.numberempire.com/graphingcalculator.php

![img](01-恋上数据结构-基础篇.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzczNDA5NQ==,size_16,color_FFFFFF,t_70.png)

![在这里插入图片描述](01-恋上数据结构-基础篇.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzczNDA5NQ==,size_16,color_FFFFFF,t_70-1663236889763-7.png)



#### 3.3 多个数据规模的情况

时间复杂度：O(n + k)

```java 
public static void test(int n, int k){
	for(int i = 0; i < n; i++){
		System.out.println("test");
	}
	for (int i = 0; i < k; i++){
		System.out.println("test");
	}
}
```



### 4 LeetCode刷题指南

首先去 https://leetcode-cn.com/ 注册一个力扣账号。

我们以力扣上一道斐波那契的题目为例，顺便分析算法的时间复杂度。

题目网址：[LeetCode: 509.斐波那契数](https://leetcode-cn.com/problems/fibonacci-number/)

![img](01-恋上数据结构-基础篇.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzczNDA5NQ==,size_16,color_FFFFFF,t_70-1663237071334-10.png)

以执行**斐波那契数列(递归)**为例，必须写成这样：

![image-20220915183747221](01-恋上数据结构-基础篇.assets/image-20220915183747221.png)



### 5 斐波那契数列复杂度分析

#### 5.1 斐波那契数列 - 递归

很简单的代码，相信来学数据结构的同学都能看懂。

```java
// O(2^n)
public static int fib1(int n) {
	if (n <= 1) return n;
	return fib1(n - 1) + fib1(n - 2);
}
```

复杂度分析：

![img](01-恋上数据结构-基础篇.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzczNDA5NQ==,size_16,color_FFFFFF,t_70-1663238329353-13.png)

我们放到力扣上去执行一下：效率奇差无比！

![在这里插入图片描述](01-恋上数据结构-基础篇.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzczNDA5NQ==,size_16,color_FFFFFF,t_70-1663238343913-16.png)



#### 5.2 斐波那契数列 - 循环

不开辟任何空间，只使用循环完成。

```java
// O(n)
public static int fib2(int n) {
	if (n <= 1) return n;
	
	int first = 0;
	int second = 1;
	for (int i = 0; i < n - 1; i++) {
		int sum = first + second;
		first = second;
		second = sum;
	}
	/*
	// 也可以使用while循环
	while (n-- > 1) {
		second += first;
		first = second - first;
	}
	*/
	return second;
}
```

力扣上执行：速度变快了，内存消耗还是很多…

![img](01-恋上数据结构-基础篇.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzczNDA5NQ==,size_16,color_FFFFFF,t_70-1663238439183-19.png)

开辟新的数组空间，用空间换时间。

```java
public static int fib3(int n){
	if(n <= 1) return n;
	
	int[] fib = new int[n+1];
	fib[0] = 0;
	fib[1] = 1;
	for(int i = 2; i < fib.length; i++){
		fib[i] = fib[i-1] + fib[i-2];
	}
	return fib[n];
}
```

力扣上执行：呃，和上面好像没啥区别。。

![在这里插入图片描述](01-恋上数据结构-基础篇.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzczNDA5NQ==,size_16,color_FFFFFF,t_70-1663238486681-22.png)



#### 5.3 fib函数的时间复杂度分析

上面两种 fib 函数的差别有多大？

- 如果有一台 1GHz 的普通计算机，运算速度 10<sup>9</sup> 次每秒，n 为 64
- O(n) 大约耗时 6.4 * 10<sup>-8</sup> 秒
- O(2<sup>n</sup>) 大约耗时 584.94 年
- 有时候算法之间的差距，往往比硬件方面的差距还要大



#### 5.4 斐波那契的线性代数解法-特征方程

![img](01-恋上数据结构-基础篇.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzczNDA5NQ==,size_16,color_FFFFFF,t_70-1663238671885-25.png)



### 6 算法的优化方向

- 用尽量少的存储空间
- 用尽量少的执行步骤（执行时间）
- 根据情况：**空间换时间**、**时间换空间**

+++

## 一、动态扩容数组原理及实现

### 1 什么是数据结构？

数据结构是计算机存储、组织数据的方式；

![img](01-恋上数据结构-基础篇.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzczNDA5NQ==,size_16,color_FFFFFF,t_70-1663239186234-28.png)

在实际应用中，根据使用场景来选择最合适的数据结构



### 2 线性表

**线性表**是具有 n 个**相同类型元素**的有限**序列**（ n ≥ 0 ）

![在这里插入图片描述](01-恋上数据结构-基础篇.assets/20200501000311746.png)

- a<sub>1</sub>是首节点（首元素），a<sub>n</sub>是尾结点（尾元素）
- a<sub>1 </sub>是 a<sub>2</sub> 的**前驱**，a<sub>2</sub> 是 a<sub>1</sub> 的**后继**

常见的线性表有：

- 数组
- 链表
- 栈
- 队列
- 哈希表（散列表）



### 3 数组（Array）

数组是一种顺序存储的线性表，所有元素的**内存地址是连续**的

![img](01-恋上数据结构-基础篇.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzczNDA5NQ==,size_16,color_FFFFFF,t_70-1663239361997-33.png)

在很多编程语言中，数组都有个致命的缺点：**无法动态修改容量**

实际开发中，我们更希望数组的容量是可以动态改变的



### 4 动态数组（Dynamic Array）

#### 4.1 动态数组接口设计

![img](01-恋上数据结构-基础篇.assets/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA6JCM5a6F6bm_,size_20,color_FFFFFF,t_70,g_se,x_16.png)

动态数组的结构：

- size
- elements

![在这里插入图片描述](01-恋上数据结构-基础篇.assets/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA6JCM5a6F6bm_,size_20,color_FFFFFF,t_70,g_se,x_16-1663239450356-38.png)

> Java 中，成员变量会自动初始化，比如：
>
> - int 类型自动初始化为 0
> - 对象类型自动初始化为 null



#### 4.2 清除所有元素--clear()

核心代码是 size = 0，实际上不需要执行 `elements = null`，size = 0 的操作已经对用户来说保证了无法访问动态数组中的元素了。

代码实现：

```java
public void clear() {
    size = 0;
}
```



#### 4.3 添加元素--add(E element)、add(int index, E element)

`add(E element)`：默认往数组最后添加元素；

![img](01-恋上数据结构-基础篇.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzczNDA5NQ==,size_16,color_FFFFFF,t_70-1663239556722-41.png)

`add(int index, E element)`：在 `index` 位置插入一个元素；

比如要往 `index = 2` 的地方添加元素：

- 正确的顺序应当是：**从后往前**开始将 `index = 2` 以后的元素依次后移，然后赋值：

![在这里插入图片描述](01-恋上数据结构-基础篇.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzczNDA5NQ==,size_16,color_FFFFFF,t_70-1663239577862-44.png)

- 如果**从前往后**开始移动元素，会造成如下**错误的**后果：

![在这里插入图片描述](01-恋上数据结构-基础篇.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzczNDA5NQ==,size_16,color_FFFFFF,t_70-1663239630099-47.png)

代码实现：

```java
/**
 * 在index位置插入一个元素
 * @param index
 * @param element
 */
public void add(int index, E element){ 
	rangeCheckForAdd(index); // 检查下标越界
	ensureCapacity(size + 1); // 确保容量够大
	// 0 1 2 3 4 5 6 7 8 9	(index)
	// 1 2 3 4 5 6 x x x x	(原数组)
	// 在index=2处，插入9，元素全部后移
	// 1 2 9 3 4 5 6 x x x	(add后数组)
	// 先从后往前开始, 将每个元素往后移一位, 然后再赋值
	for (int i = size; i > index; i--) {
        elements[i] = elements[i-1];
    }
	elements[index] = element; // 复制
	size++;
}

/**
 * 添加元素到数组最后
 */
public void add(E element){
	add(size, element);
}
```



#### 4.4 删除元素--remove(int index)、清空数组--clear()

例如，删除 `index = 3` 的数组元素，应当**从前往后**开始移动，用后面的元素覆盖前面的元素。

![在这里插入图片描述](01-恋上数据结构-基础篇.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzczNDA5NQ==,size_16,color_FFFFFF,t_70-1663240091206-50.png)

**思考**：**最后一个元素如何处理**？

- 如果存放 `int` 类型，`size--` 后，最后一个元素已经无法访问了。

- 如果使用**泛型**，数组要注意内存管理（将元素置 `null`）。

  使用泛型技术可以让动态数组更加通用，可以存放任何数据类型：

  ![在这里插入图片描述](01-恋上数据结构-基础篇.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzczNDA5NQ==,size_16,color_FFFFFF,t_70-1663240134229-53.png)

代码实现：

```java
/**
 * 删除index位置的元素
 * @param index
 * @return
 */
public E remove(int index){
	rangeCheck(index); // 检查下标越界
	// 0 1 2 3 4 5 	(index)
	// 1 2 3 4 5 6 	(原数组)
	// 删除index为2的元素，元素前移
	// 1 2 4 5 6	(remove后的数组)
	// 从前往后开始移, 用后面的元素覆盖前面的元素
	E old = elements[index];
	for (int i = index + 1; i < size; i++) {
        elements[i-1] = elements[i];
    }
	// 下面是使用泛型后需要写的(如果存储的是int型数据, 则不需要)
	elements[--size] = null; // 删除元素后, 将最后一位设置为null
	return old;
}

/**
 * 清除所有元素
 */
public void clear(){
	// 使用泛型数组后要注意内存管理(将元素置null)
	for (int i = 0; i < size; i++) {
		elements[i] = null;
	}
	size = 0;
}
```



#### 4.5 是否包含某个元素--contains(E element)

关于 null 的处理主要看你的业务需求：是否可以存储 null 数据？

```java
private static final int ELEMENT_NOT_FOUND = -1;

/**
 * 是否包含某个元素
 * @param element
 * @return
 */
public boolean contains(E element){
	return indexOf(element) != ELEMENT_NOT_FOUND; // 找的到该元素则返回True
}

/**
* 查看元素的索引
 * @param element
 * @return
 */
public int indexOf(E element){
	/*
	// 不对 null 进行处理也可以，但是健壮性不够
	for (int i = 0; i < size; i++) {
		if(elements[i].equals(element)) return i;
	}
	 */
	if(element == null){ // 对 null 进行处理
		for (int i = 0; i < size; i++) {
			if(elements[i] == null) return i;
		}
	}else{
		for (int i = 0; i < size; i++) {
			if(element.equals(elements[i])) return i;
		}
	}
	return ELEMENT_NOT_FOUND;
}
```



#### 4.6 扩容--ensureCapacity(int capacity)

相信看过视频的小伙伴一看这图就懂了。

![在这里插入图片描述](01-恋上数据结构-基础篇.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzczNDA5NQ==,size_16,color_FFFFFF,t_70-1663240435676-56.png)

```java
/**
 * 扩容操作
 */
private void ensureCapacity(int capacity) {
	int oldCapacity = elements.length; // 旧的容量大小
	if (oldCapacity >= capacity) return; // 如果容量大小管够，则返回
	// 新容量为旧容量的1.5倍
	int newCapacity = oldCapacity + (oldCapacity >> 1);
	E[] newElements = (E[]) new Object[newCapacity];
	for (int i = 0; i < size; i++) {
		newElements[i] = elements[i]; // 拷贝原数组元素到新数组
	}
	elements = newElements;
}
```



#### 4.7 打印数组--toString()

- 重写 `toString` 方法
- 在 `toString` 方法中将元素拼接成字符串
- 字符串拼接建议使用 `StringBuilder`

```java
	@Override
    public String toString() {
        StringBuilder string = new StringBuilder();
        string.append("size=").append(size).append(", [");
        for (int i = 0; i < size; i++) {
            if (i != 0){
                string.append(", ");
            }
            string.append(elements[i]);
        }
        string.append("]");
        return string.toString();
    }
	// size=6, [1, 2, 3, 4, 5, 6]
```



### 5 泛型

使用泛型技术可以让动态数组更加通用，可以存放任何数据类型

```java
public class ArrayList<E> {
	private int size;
	private E[] elements;
}
```

```java
private static final int DEFAULT_CAPACITY = 10;

public ArrayList(int capacity){
    capacity = Math.max(capacity, DEFAULT_CAPACITY);
    elements = (E[]) new Object[capacity];
}
public ArrayList(){
    this(DEFAULT_CAPACITY);
}
```

```java
ArrayList<Integer> list = new ArrayList<>();
```



#### 5.1 对象数组 - Object[]

```java
Object[] objects = new Object[7];
```

- 由于 Object 可以存放任何类型，因此无法固定 Object 占多少内存空间（根据传入不同的自定义对象，占用的空间都不同），因此实际上 Object 数组中存放的是**对象的地址**。
- 想要销毁对象，只需要将指向该对象的地址赋值为`null`，没有地址引用该对象，则会自动被垃圾回收

![在这里插入图片描述](01-恋上数据结构-基础篇.assets/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA6JCM5a6F6bm_,size_20,color_FFFFFF,t_70,g_se,x_16-1663240840385-59.png)

内存管理细节：

```java
public void clear() {
    for (int i = 0; i < size; i++) {
        elements[i] = null; // 管理内存
    }
    size = 0;
}
```

```java
public E remove(int index) {
    rangeCheck(index);
    E old = elements[index];
    for (int i = index + 1; i < size; i++) {
        elements[i-1] = elements[i];
    }
    elements[--size] = null; // 管理内存
    return old;
}
```



### 6 int型动态数组源码（Java）

```java
public class ArrayList {
	private int size;		// 元素数量	
	private int[] elements; // 所有的元素

	private static final int DEFAULT_CAPACITY = 10; // 初始容量
	private static final int ELEMENT_NOT_FOUND = -1;
	
	public ArrayList(int capacity) { // 容量小于10一律扩充为10
		capacity = (capacity < DEFAULT_CAPACITY) ? DEFAULT_CAPACITY : capacity;
		elements = new int[capacity];
	}
	public ArrayList(){
		this(DEFAULT_CAPACITY);
	}
	/**
	 * 元素的数量
	 * @return
	 */
	public int size(){
		return size;
	}
	/**
	 * 是否为空
	 * @return
	 */
	public boolean isEmpty(){
		return size == 0;
	}
	/**
	 * 是否包含某个元素
	 * @param element
	 * @return
	 */
	public boolean contains(int element){
		return indexOf(element) != ELEMENT_NOT_FOUND; //找的到该元素则返回True
	}
	/**
	 * 在index位置插入一个元素
	 * @param index
	 * @param element
	 */
	public void add(int index, int element){
		rangeCheckForAdd(index); // 检查下标越界
		ensureCapacity(size + 1); // 确保容量够大
		
		// 0 1 2 3 4 5 6 7 8 9	(index)
		// 1 2 3 4 5 6 x x x x	(原数组)
		// 在index=2处，插入9，元素全部后移
		// 1 2 9 3 4 5 6 x x x	(add后数组)
		// 先从后往前开始, 将每个元素往后移一位, 然后再赋值
		for (int i = size - 1; i >= index; i--) {
			elements[i + 1] = elements[i];
		}
		elements[index] = element; // 赋值
		size++;
	}
	/**
	 * 添加元素到最后面
	 */
	public void add(int element){
		add(size, element);
	}
	/**
	 * 设置index位置的元素
	 * @param index
	 * @param element
	 * @return 原来的元素ֵ
	 */
	public int get(int index){
		rangeCheck(index);
		return elements[index];
	}
	/**
	 * 设置index位置的元素
	 * @param index
	 * @param element
	 * @return 原来的元素ֵ
	 */
	public int set(int index, int element){
		rangeCheck(index);
		int old = elements[index];
		elements[index] = element;
		return old;
	}
	/**
	 * 删除index位置的元素
	 * @param index
	 * @return
	 */
	public int remove(int index){
		rangeCheck(index);
		
		// 0 1 2 3 4 5 	(index)
		// 1 2 3 4 5 6 	(原数组)
		// 删除index为2的元素，元素前移
		// 1 2 4 5 6	(remove后的数组)
		int old = elements[index];
		// 从前往后开始移, 用后面的元素覆盖前面的元素
		for (int i = index; i < size-1; i++) {
			elements[i] = elements[i + 1];
		}
		size--;
		return old;
	}
	/**
	 * 查看元素的索引
	 * @param element
	 * @return
	 */
	public int indexOf(int element){
		for (int i = 0; i < size; i++) {
			if(elements[i] == element) return i;
		}
		return ELEMENT_NOT_FOUND;
	}
	/**
	 * 清除所有元素
	 */
	public void clear(){
		size = 0;
	}
	/*
	 * 扩容操作
	 */
	private void ensureCapacity(int capacity){
		int oldCapacity = elements.length;
		if(oldCapacity >= capacity) return;
		// 新容量为旧容量的1.5倍
		int newCapacity = oldCapacity + (oldCapacity >> 1); // 1.5
		int[] newElements = new int[newCapacity];
		for (int i = 0; i < size; i++) {
			newElements[i] = elements[i];
		}
		elements = newElements;
		System.out.println("size="+oldCapacity+", 扩容到了"+newCapacity);
	}
	/****************封装好的功能函数*******************************/
	// 下标越界抛出的异常
	private void outOfBounds(int index) {
		throw new IndexOutOfBoundsException("Index:" + index + ", Size:" + size);
	}
	// 检查下标越界(不可访问或删除size位置)
	private void rangeCheck(int index){
		if(index < 0 || index >= size){
			outOfBounds(index);
		}
	}
	// 检查add()的下标越界(可以在size位置添加)
	private void rangeCheckForAdd(int index) {
		if (index < 0 || index > size) {
			outOfBounds(index);
		}
	}
	/****************封装好的功能函数*******************************/
	@Override
	public String toString() {
		// 打印形式为: size=5, [99, 88, 77, 66, 55]
		StringBuilder string = new StringBuilder();
		string.append("size=").append(size).append(", [");
		for (int i = 0; i < size; i++) {
			if(0 != i) string.append(", ");
			string.append(elements[i]);
		}
		string.append("]");
		return string.toString();
	}
}
```



### 7 泛型动态数组源码（Java）

```java
@SuppressWarnings("unchecked")
public class ArrayList<E> {
    /**
     * 元素的容量
     */
    private int size;
    /**
     * 所有的元素
     */
    private E[] elements;

    private static final int DEFAULT_CAPACITY = 10; //初始容量
    private static final int ELEMENT_NOT_FOUND = -1;

    public ArrayList(int capacity){ // 容量小于10一律扩充为10
        capacity = Math.max(capacity, DEFAULT_CAPACITY);
        elements = (E[]) new Object[capacity];
    }

    public ArrayList(){
        this(DEFAULT_CAPACITY);
    }

    /**
     * 清除所有元素
     */
    public void clear() {
        for (int i = 0; i < size; i++) {
            elements[i] = null;
        }
        size = 0;
    }

    /**
     * 元素的数量
     * @return
     */
    public int size() {
        return size;
    }

    /**
     * 是否为空
     * @return
     */
    public boolean isEmpty() {
        return size == 0;
    }
    /**
     * 是否包含某个元素
     * @param element
     * @return
     */
    public boolean contains(E element) {
        return indexOf(element) != ELEMENT_NOT_FOUND;
    }

    /**
     * 获取index位置的元素
     * @param index
     * @return
     */
    public E get(int index) {
        rangeCheck(index);
        return elements[index];
    }

    /**
     * 设置index位置的元素
     * @param index
     * @param element
     * @return 原来的元素ֵ
     */
    public E set(int index, E element) {
        rangeCheck(index);
        E old = elements[index];
        elements[index] = element;
        return old;
    }

    /**
     * 添加元素到尾部
     * @param element
     */
    public void add(E element) {
        add(size, element);
    }

    /**
     * 在index位置插入一个元素
     * @param index
     * @param element
     */
    public void add(int index, E element) {
        rangeCheckForAdd(index);
        ensureCapacity(size + 1);

        for (int i = size; i > index; i--) {
            elements[i] = elements[i-1];
        } 
        elements[index] = element;
        size++;
    }

    /**
     * 删除index位置的元素
     * @param index
     * @return
     */
    public E remove(int index) {
        rangeCheck(index);
        E old = elements[index];
        for (int i = index + 1; i < size; i++) {
            elements[i-1] = elements[i];
        }
        elements[--size] = null;
        return old;
    }

    /**
     * 查看元素的索引
     * @param element
     * @return
     */
    public int indexOf(E element) {
        if (element == null){
            for (int i = 0; i < size; i++) {
                if (elements[i] == null){
                    return i;
                }
            }
        } else {
            for (int i = 0; i < size; i++) {
                if (element.equals(elements[i])){
                    return i;
                }
            }
        }
        return ELEMENT_NOT_FOUND;
    }

    /**
     * 保证要有capacity的容量
     * @param capacity
     */
    private void ensureCapacity(int capacity) {
        int oldCapacity = elements.length;
        if (oldCapacity >= capacity) return;
        //新容量为旧容量的1.5倍
        int newCapacity = oldCapacity + (oldCapacity >> 1);
        E[] newElements = (E[]) new Object[newCapacity];
        for (int i = 0; i < size; i++) {
            newElements[i] = elements[i];
        }
        elements = newElements;
    }

    /****************封装好的功能函数**************************/
	// 下标越界抛出的异常
    private void outOfBounds(int index) {
        throw new IndexOutOfBoundsException("Index: " + index + ", Size: " + size);
    }
	// 检查下标越界(不可访问或删除size位置)
    private void rangeCheck(int index) {
        if (index < 0 || index >= size){
            outOfBounds(index);
        }
    }
	// 检查add()的下标越界(可以在size位置添加元素)
    private void rangeCheckForAdd(int index) {
        if (index < 0 || index > size){
            outOfBounds(index);
        }
    }

    @Override
    public String toString() {
        StringBuilder string = new StringBuilder();
        string.append("size=").append(size).append(", [");
        for (int i = 0; i < size; i++) {
            if (i != 0){
                string.append(", ");
            }
            string.append(elements[i]);
        }
        string.append("]");
        return string.toString();
    }
}
```

+++

## 二、



















































































































































































