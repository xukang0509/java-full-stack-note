# æ‹ä¸Šæ•°æ®ç»“æ„-ç®—æ³•ç¯‡

![ç¬¬2å­£](02-æ‹ä¸Šæ•°æ®ç»“æ„-ç®—æ³•ç¯‡.assets/ç¬¬2å­£.png)

+++

## ä¸€ã€æ’åºSort

### 1 å‰ç½®çŸ¥è¯†

#### 1.1 æ’åºç®—æ³•å¤§å…¨

![image-20221003163705650](02-æ‹ä¸Šæ•°æ®ç»“æ„-ç®—æ³•ç¯‡.assets/image-20221003163705650.png)



#### 1.2 æ’åºåŸºæœ¬çŸ¥è¯†

1. ä½•ä¸ºæ’åºï¼Ÿ
   - æ’åºå‰ï¼š3ï¼Œ1ï¼Œ6ï¼Œ9ï¼Œ2ï¼Œ5ï¼Œ8ï¼Œ47
   - å‡åºæ’åºï¼š1ï¼Œ2ï¼Œ3ï¼Œ4ï¼Œ5ï¼Œ6ï¼Œ7ï¼Œ8ï¼Œ9
   - é™åºæ’åºï¼š9ï¼Œ8ï¼Œ7ï¼Œ6ï¼Œ5ï¼Œ4ï¼Œ3ï¼Œ2ï¼Œ1

2. ä½•ä¸ºç¨³å®šæ€§ï¼Ÿ

   - é™åºå‰ï¼š5ï¼Œ1ï¼Œ3<sub>a</sub>ï¼Œ7ï¼Œ3<sub>b</sub>
   - ç¨³å®šçš„æ’åºï¼š1ï¼Œ3<sub>a</sub>ï¼Œ3<sub>b</sub>ï¼Œ5ï¼Œ7
   - ä¸ç¨³å®šçš„æ’åºï¼š1ï¼Œ3<sub>b</sub>ï¼Œ3<sub>a</sub>ï¼Œ5ï¼Œ7

   å¯¹**è‡ªå®šä¹‰å¯¹è±¡**è¿›è¡Œæ’åºæ—¶ï¼Œç¨³å®šæ€§ä¼šå½±å“æœ€ç»ˆçš„æ’åºæ•ˆæœã€‚

3. ä½•ä¸ºåŸåœ°ç®—æ³•ï¼Ÿ
   - ä¸ä¾èµ–é¢å¤–çš„èµ„æºæˆ–è€…ä¾èµ–å°‘æ•°çš„é¢å¤–èµ„æºï¼Œä»…ä¾é *è¾“å‡º*æ¥è¦†ç›–*è¾“å…¥*ï¼›
   - ç©ºé—´å¤æ‚åº¦ä¸º`O(1)`çš„éƒ½å¯ä»¥è®¤ä¸ºæ˜¯åŸåœ°ç®—æ³•ï¼›
   - éåŸåœ°ç®—æ³•ï¼Œç§°ä¸º Not-in-place æˆ–è€… Out-of-placeã€‚



#### 1.3 å†™æ’åºç®—æ³•å‰çš„å‡†å¤‡

##### 1.3.1 é¡¹ç›®ç»“æ„

åˆ›å»ºä¸€ä¸ªé¡¹ç›®ï¼Œå¤§ä½“ç»“æ„æ˜¯è¿™æ ·çš„ï¼š

![image-20221004124012854](02-æ‹ä¸Šæ•°æ®ç»“æ„-ç®—æ³•ç¯‡.assets/image-20221004124012854.png)

- sortï¼šå„ç§æ’åºç±»
  - cmpï¼šæ¯”è¾ƒç±»æ’åº
  - sort.javaï¼šæ’åºæŠ½è±¡ç±»
- toolsï¼šæ’åºä¸­ç”¨åˆ°çš„å·¥å…·
  - Asserts.javaï¼šå•å…ƒæµ‹è¯•
  - Inegers.javaï¼šç”Ÿæˆæµ‹è¯•æ•°æ®
  - Times.javaï¼šè®¡ç®—æ—¶é—´
- Mainï¼šä¸»å‡½æ•°ï¼Œå†™æ’åºæµ‹è¯•
- Student.javaï¼šåˆ©ç”¨è‡ªå®šä¹‰ç±»æµ‹è¯•ç¨³å®šæ€§(sort.javaä¸­ä½¿ç”¨)



##### 1.3.2 Sort.java

å†™ä¸€ä¸ªæŠ½è±¡ç±» Sort.java

- å®ç°è‡ªå®šä¹‰å¯¹è±¡çš„æ¯”è¾ƒ(cmp)ï¼Œäº¤æ¢(swap)æ–¹æ³•
- åŒæ—¶å¯ä»¥ç”¨æ¥è®¡ç®—æ¯”è¾ƒæ¬¡æ•°(cmpCount)ï¼Œäº¤æ¢æ¬¡æ•°(swapCount)ï¼ŒèŠ±è´¹æ—¶é—´(time)
- æ’åºæ˜¯å¦ç¨³å®š()

```java
package com.xk._02Algorithmic._01sort.sort;

import com.xk._02Algorithmic._01sort.Student;
import java.text.DecimalFormat;

public abstract class Sort<E extends Comparable<E>> implements Comparable<Sort<E>> {
    protected E[] array;
    private int cmpCount;
    private int swapCount;
    private long time;
    private DecimalFormat fmt = new DecimalFormat("#.00");

    public void sort(E[] array) {
        if (array == null || array.length < 2) return;
        this.array = array;
        this.cmpCount = 0;
        this.swapCount = 0;
        long begin = System.currentTimeMillis();
        sort();
        time = System.currentTimeMillis() - begin;
    }

    protected abstract void sort();

    /**
     * æ¯”è¾ƒå¯¹åº”ä¸¤ä¸ªç´¢å¼•å¯¹åº”æ•°æ®çš„å¤§å°
     * @return
     *      è¿”å›å€¼è¿”å›0ï¼Œ array[i1] == array[i2]
     *      è¿”å›å€¼å¤§äº0ï¼Œ array[i1] > array[i2]
     *      è¿”å›å€¼å°äº0ï¼Œ array[i1] < array[i2]
     */
    protected int cmp(int i1, int i2){
        cmpCount++;
        return array[i1].compareTo(array[i2]);
    }
    protected int cmp(E v1, E v2){
        cmpCount++;
        return v1.compareTo(v2);
    }

    protected void swap(int i1, int i2) {
        swapCount++;
        E tmp = array[i1];
        array[i1] = array[i2];
        array[i2] = tmp;
    }

    @Override
    public int compareTo(Sort<E> o) {
        int result = (int) (this.time - o.time);
        if (result == 0) result = this.swapCount - o.swapCount;
        if (result == 0) result = this.cmpCount - o.cmpCount;
        return result;
    }

    @Override
    public String toString() {
        String timeStr = "è€—æ—¶ï¼š" + (time / 1000.0) + "s(" + time + "ms)";
        String compareCountStr = "æ¯”è¾ƒï¼š" + numberString(cmpCount);
        String swapCountStr = "äº¤æ¢ï¼š" + numberString(swapCount);
        String stableStr = "ç¨³å®šæ€§ï¼š" + isStable();
        return "ã€" + getClass().getSimpleName() + "ã€‘\n"
                + stableStr + "\t "
                + timeStr + " \t"
                + compareCountStr + "\t "
                + swapCountStr + "\n"
                + "------------------------------------------------------------------";
    }

    private String numberString(int number) {
        if (number < 10000) return "" + number;
        if (number < 100000000) return fmt.format(number / 10000.0) + "ä¸‡";
        return fmt.format(number / 100000000.0) + "äº¿";
    }

    private boolean isStable(){
        if (this instanceof ShellSort1 || this instanceof ShellSort2) return false;
        Student[] students = new Student[20];
        for (int i = 0; i < students.length; i++) {
            students[i] = new Student(i * 10, 10);
        }

        sort((E[]) students);

        for (int i = 1; i < students.length; i++) {
            if (students[i].score - students[i-1].score != 10) return false;
        }
        return true;
    }
}
```



##### 1.3.3 Asserts.java

```java
public class Asserts {
   public static void test(boolean value) {
      try {
         if (!value) throw new Exception("æµ‹è¯•æœªé€šè¿‡");
      } catch (Exception e) {
         e.printStackTrace();
      }
   }
}
```



##### 1.3.4 Integers.java

```java
package com.xk._02Algorithmic._01sort.tools;

import java.util.Arrays;

public class Integers {
   public static Integer[] random(int count, int min, int max) {
      if (count <= 0 || min > max) return null;
      Integer[] array = new Integer[count];
      int delta = max - min + 1;
      for (int i = 0; i < count; i++) {
         array[i] = min + (int)(Math.random() * delta);
      }
      return array;
   }
   
   public static Integer[] combine(Integer[] array1, Integer[] array2) {
      if (array1 == null || array2 == null) return null;
      Integer[] array = new Integer[array1.length + array2.length];
      for (int i = 0; i < array1.length; i++) {
         array[i] = array1[i];
      }
      for (int i = 0; i < array2.length; i++) {
         array[i + array1.length] = array2[i];
      }
      return array;
      
   }
   
   public static Integer[] same(int count, int unsameCount) {
      if (count <= 0 || unsameCount > count) return null;
      Integer[] array = new Integer[count];
      for (int i = 0; i < unsameCount; i++) {
         array[i] = unsameCount - i;
      }
      for (int i = unsameCount; i < count; i++) {
         array[i] = unsameCount + 1;
      }
      return array;
   }
   
   public static Integer[] headTailAscOrder(int min, int max, int disorderCount) {
      Integer[] array = ascOrder(min, max);
      if (disorderCount > array.length) return array;
      
      int begin = (array.length - disorderCount) >> 1;
      reverse(array, begin, begin + disorderCount);
      return array;
   }
   
   public static Integer[] centerAscOrder(int min, int max, int disorderCount) {
      Integer[] array = ascOrder(min, max);
      if (disorderCount > array.length) return array;
      int left = disorderCount >> 1;
      reverse(array, 0, left);
      
      int right = disorderCount - left;
      reverse(array, array.length - right, array.length);
      return array;
   }
   
   public static Integer[] headAscOrder(int min, int max, int disorderCount) {
      Integer[] array = ascOrder(min, max);
      if (disorderCount > array.length) return array;
      reverse(array, array.length - disorderCount, array.length);
      return array;
   }
   
   public static Integer[] tailAscOrder(int min, int max, int disorderCount) {
      Integer[] array = ascOrder(min, max);
      if (disorderCount > array.length) return array;
      reverse(array, 0, disorderCount);
      return array;
   }
   
   public static Integer[] ascOrder(int min, int max) {
      if (min > max) return null;
      Integer[] array = new Integer[max - min + 1];
      for (int i = 0; i < array.length; i++) {
         array[i] = min++;
      }
      return array;
   }
   
   public static Integer[] descOrder(int min, int max) {
      if (min > max) return null;
      Integer[] array = new Integer[max - min + 1];
      for (int i = 0; i < array.length; i++) {
         array[i] = max--;
      }
      return array;
   }
   
   /**
    * åè½¬ä¸€ä¸ªæ•°ç»„ï¼Œç´¢å¼•èŒƒå›´æ˜¯[begin, end)
    */
   private static void reverse(Integer[] array, int begin, int end) {
      int count = (end - begin) >> 1;
      int sum = begin + end - 1;
      for (int i = begin; i < begin + count; i++) {
         int j = sum - i;
         int tmp = array[i];
         array[i] = array[j];
         array[j] = tmp;
      }
   }
   
   public static Integer[] copy(Integer[] array) {
      return Arrays.copyOf(array, array.length);
   }
   
   public static boolean isAscOrder(Integer[] array) {
      if (array == null || array.length == 0) return false;
      for (int i = 1; i < array.length; i++) {
         if (array[i - 1] > array[i]) return false;
      }
      return true;
   }
   
   public static void println(Integer[] array) {
      if (array == null) return;
      StringBuilder string = new StringBuilder();
      for (int i = 0; i < array.length; i++) {
         if (i != 0) string.append("_");
         string.append(array[i]);
      }
      System.out.println(string);
   }
}
```



##### 1.3.5 Times.java

```java
package com.xk._02Algorithmic._01sort.tools;

import java.text.SimpleDateFormat;
import java.util.Date;

public class Times {
   private static final SimpleDateFormat fmt = new SimpleDateFormat("HH:mm:ss.SSS");
   
   public interface Task {
      void execute();
   }
   
   public static void test(String title, Task task) {
      if (task == null) return;
      title = (title == null) ? "" : ("ã€" + title + "ã€‘");
      System.out.println(title);
      System.out.println("å¼€å§‹ï¼š" + fmt.format(new Date()));
      long begin = System.currentTimeMillis();
      task.execute();
      long end = System.currentTimeMillis();
      System.out.println("ç»“æŸï¼š" + fmt.format(new Date()));
      double delta = (end - begin) / 1000.0;
      System.out.println("è€—æ—¶ï¼š" + delta + "ç§’");
      System.out.print("-------------------------------------");
      System.out.println("-------------------------------------");
   }
}
```



##### 1.3.6 Student.java

```java
package com.xk._02Algorithmic._01sort;

public class Student implements Comparable<Student> {
   public int score;
   public int age;
   
   public Student(int score, int age) {
      this.score = score;
      this.age = age;
   }
   
   @Override
   public int compareTo(Student o) {
      return age - o.age;
   }
}
```



### 2 åå¤§æ’åºç®—æ³•

#### 2.1 å†’æ³¡æ’åº

**å†’æ³¡æ’åº**ä¹Ÿå«åš**èµ·æ³¡æ’åº**ã€‚

**æ‰§è¡Œæµç¨‹**ï¼š

1. ä»å¤´å¼€å§‹æ¯”è¾ƒæ¯ä¸€å¯¹ç›¸é‚»å…ƒç´ ï¼Œå¦‚æœç¬¬1ä¸ªæ¯”ç¬¬2ä¸ªå¤§ï¼Œå°±äº¤æ¢å®ƒä»¬çš„ä½ç½®ï¼›

   æ‰§è¡Œå®Œä¸€è½®åï¼Œæœ€æœªå°¾é‚£ä¸ªå…ƒç´ å°±æ˜¯æœ€å¤§çš„å…ƒç´ ã€‚

2. å¿½ç•¥**1**ä¸­æ›¾ç»æ‰¾åˆ°çš„æœ€å¤§å…ƒç´ ï¼Œé‡å¤æ‰§è¡Œæ­¥éª¤**1**ï¼Œç›´åˆ°å…¨éƒ¨å…ƒç´ æœ‰åºã€‚

è¿™æ˜¯ä¸€ä¸ªæ ‡å‡†çš„å†’æ³¡æ’åºã€‚

```java
package com.xk._02Algorithmic._01sort.sort;

/**
 * @description: å†’æ³¡æ’åº
 * @author: xu
 * @date: 2022/10/1 2:14
 */
public class BubbleSort1<E extends Comparable<E>> extends Sort<E> {
    /**
     * å†’æ³¡æ’åº
     */
    private void bubbleSort1(){
        for (int end = array.length - 1; end > 0; end--) {
            for (int begin = 1; begin <= end; begin++) {
                if (cmp(begin-1, begin) > 0){
                    swap(begin, begin-1);
                }
            }
        }
    }

    @Override
    protected void sort() {
        bubbleSort1();
    }
}
```



##### 2.1.1 å†’æ³¡æ’åº--ä¼˜åŒ–1

è¿™ä¸ªä¼˜åŒ–å¹¶ä¸ä¼šæé«˜å†’æ³¡æ’åºçš„å¹³å‡æ€§èƒ½ï¼Œåªæ˜¯**é’ˆå¯¹æç«¯æ¡ä»¶è¿›è¡Œå¤„ç†**ã€‚

å¦‚æœ**åºåˆ—å·²ç»å®Œå…¨æœ‰åº**ï¼Œå¯ä»¥æå‰ç»ˆæ­¢å†’æ³¡æ’åºã€‚

```java
package com.xk._02Algorithmic._01sort.sort;

/**
 * @description: å†’æ³¡æ’åº ä¼˜åŒ–1 -- å¦‚æœåºåˆ—å·²ç»å®Œå…¨æœ‰åºï¼Œå¯ä»¥æå‰ç»ˆæ­¢å†’æ³¡æ’åº
 * @author: xu
 * @date: 2022/10/1 2:14
 */
public class BubbleSort2<E extends Comparable<E>> extends Sort<E> {
    /**
     * å†’æ³¡æ’åº ä¼˜åŒ–1 -- å¦‚æœåºåˆ—å·²ç»å®Œå…¨æœ‰åºï¼Œå¯ä»¥æå‰ç»ˆæ­¢å†’æ³¡æ’åº
     */
    private void bubbleSort2(){
        for (int end = array.length - 1; end > 0; end--) {
            boolean swap = true;
            for (int begin = 1; begin <= end; begin++) {
                if (cmp(begin, begin-1) < 0){
                    swap(begin, begin-1);
                    swap = false;
                }
            }
            if (swap) break;
        }
    }

    @Override
    protected void sort() {
        bubbleSort2();
    }
}
```



##### 2.1.2 å†’æ³¡æ’åº--ä¼˜åŒ–2

è¿™ä¸ªä¼˜åŒ–æ˜¯åœ¨ä¼˜åŒ–1çš„åŸºç¡€ä¸Šï¼Œå¢å¤§æç«¯æ¡ä»¶çš„èŒƒå›´ï¼Œä»**å®Œå…¨æœ‰åº**å˜ä¸º**å°¾éƒ¨å±€éƒ¨æœ‰åº**ã€‚

å¦‚æœ**åºåˆ—å°¾éƒ¨å·²ç»å±€éƒ¨æœ‰åº**ï¼Œå¯ä»¥**è®°å½•æœ€å1æ¬¡äº¤æ¢çš„ä½ç½®**ï¼Œå‡å°‘æ¯”è¾ƒæ¬¡æ•°ã€‚

```java
package com.xk._02Algorithmic._01sort.sort;

/**
 * @description: å†’æ³¡æ’åº ä¼˜åŒ–2 -- å¦‚æœåºåˆ—å°¾éƒ¨å·²ç»å±€éƒ¨æœ‰åºï¼Œå¯ä»¥è®°å½•æœ€å1æ¬¡äº¤æ¢çš„ä½ç½®ï¼Œå‡å°‘æ¯”è¾ƒæ¬¡æ•°
 * @author: xu
 * @date: 2022/10/1 2:14
 */
public class BubbleSort3<E extends Comparable<E>> extends Sort<E> {
    /**
     * å†’æ³¡æ’åº ä¼˜åŒ–2 -- å¦‚æœåºåˆ—å°¾éƒ¨å·²ç»å±€éƒ¨æœ‰åºï¼Œå¯ä»¥è®°å½•æœ€å1æ¬¡äº¤æ¢çš„ä½ç½®ï¼Œå‡å°‘æ¯”è¾ƒæ¬¡æ•°
     */
    private void bubbleSort3(){
        for (int end = array.length - 1; end > 0; end--) {
            // sortedIndex çš„åˆå§‹å€¼åœ¨æ•°ç»„å®Œå…¨æœ‰åºçš„æ—¶å€™æœ‰ç”¨
            int sortedIndex = 1;
            for (int begin = 1; begin <= end; begin++) {
                if (cmp(begin, begin-1) < 0){
                    swap(begin, begin-1);
                    sortedIndex = begin;
                }
            }
            end = sortedIndex;
        }
    }

    @Override
    protected void sort() {
        bubbleSort3();
    }
}
```



##### 2.1.3 å¤æ‚åº¦ä¸ç¨³å®šæ€§

æœ€åã€å¹³å‡æ—¶é—´å¤æ‚åº¦ï¼šO(n<sup>2</sup>)

æœ€å¥½æ—¶é—´å¤æ‚åº¦ï¼šO(n)

ç©ºé—´å¤æ‚åº¦ï¼šO(1)

**å†’æ³¡æ’åºå±äº In-place**ï¼›

å†’æ³¡æ’åºå±äº**ç¨³å®šçš„æ’åºç®—æ³•**ã€‚

ç¨æœ‰ä¸æ…ï¼Œç¨³å®šçš„æ’åºç®—æ³•ä¹Ÿèƒ½è¢«å†™æˆä¸ç¨³å®šçš„æ’åºç®—æ³•ï¼Œæ¯”å¦‚ä¸‹é¢çš„å†’æ³¡æ’åºä»£ç æ˜¯ä¸ç¨³å®šçš„ã€‚

![image-20221003171905603](02-æ‹ä¸Šæ•°æ®ç»“æ„-ç®—æ³•ç¯‡.assets/image-20221003171905603.png)



#### 2.2 é€‰æ‹©æ’åº

##### 2.2.1 ä»£ç å®ç°

æ‰§è¡Œæµç¨‹ï¼š

1. ä»åºåˆ—ä¸­æ‰¾å‡ºæœ€å¤§çš„é‚£ä¸ªå…ƒç´ ï¼Œç„¶åä¸æœ€æœ«å°¾çš„å…ƒç´ äº¤æ¢ä½ç½®

   æ‰§è¡Œå®Œä¸€è½®åï¼Œæœ€æœ«å°¾çš„é‚£ä¸ªå…ƒç´ å°±æ˜¯æœ€å¤§çš„å…ƒç´ 

2. å¿½ç•¥**1**ä¸­æ›¾ç»æ‰¾åˆ°çš„æœ€å¤§å…ƒç´ ï¼Œé‡å¤æ‰§è¡Œæ­¥éª¤**1**ã€‚

```java
package com.xk._02Algorithmic._01sort.sort;

/**
 * @description: é€‰æ‹©æ’åºï¼šæœ€å¤§çš„å…ƒç´ æ”¾åœ¨æœ€å³è¾¹
 * @author: xu
 * @date: 2022/10/1 4:34
 */
public class SelectionSort1<E extends Comparable<E>> extends Sort<E> {
    /**
     * é€‰æ‹©æ’åºï¼šæœ€å¤§çš„å…ƒç´ æ”¾åœ¨æœ€å³è¾¹
     */
    private void selectionSort1() {
        for (int end = array.length - 1; end > 0; end--) {
            int maxIndex = 0;
            for (int begin = 1; begin <= end; begin++) {
                if (cmp(maxIndex, begin) <= 0) {
                    // <= : ä¸ºäº†ç®—æ³•çš„ç¨³å®šæ€§
                    // ä»å‰å¾€åéå†ï¼Œå°†ç›¸ç­‰æ•°å€¼çš„æœ€åä¸€ä¸ªæ”¾åˆ°æ•°ç»„çš„æœ€åé¢å»
                    maxIndex = begin;
                }
            }
            swap(maxIndex, end);
        }
    }

    @Override
    protected void sort() {
        selectionSort1();
    }
}
```

é€‰æ‹©æ’åºçš„äº¤æ¢æ¬¡æ•°è¦è¿œè¿œå°‘äºå†’æ³¡æ’åºï¼Œå¹³å‡æ€§èƒ½ä¼˜äºå†’æ³¡æ’åº



##### 2.2.2 å¤æ‚åº¦ä¸ç¨³å®šæ€§

- æœ€å¥½ã€æœ€åã€å¹³å‡æ—¶é—´å¤æ‚åº¦ï¼šO(n<sup>2</sup>)
- ç©ºé—´å¤æ‚åº¦ï¼šO(1)
- é€‰æ‹©æ’åºå±äº**ä¸ç¨³å®šæ’åº**

é€‰æ‹©æ’åºæ˜¯å¦è¿˜æœ‰ä¼˜åŒ–çš„ç©ºé—´ï¼Ÿ

- **ä½¿ç”¨å †æ¥é€‰æ‹©æœ€å¤§å€¼ï¼Œå¯ä»¥å¤§å¤§æé«˜é€‰æ‹©é€Ÿåº¦**ã€‚



#### 2.3 å †æ’åº

##### 2.3.1 ä»£ç å®ç°

æ‰§è¡Œæµç¨‹ï¼š

1. å¯¹åºåˆ—è¿›è¡ŒåŸåœ°å»ºå †ï¼ˆheapifyï¼‰
2. é‡å¤æ‰§è¡Œä»¥ä¸‹æ“ä½œï¼Œç›´åˆ°å †çš„å…ƒç´ æ•°é‡ä¸º1
   - äº¤æ¢å †é¡¶å…ƒç´ ä¸å°¾å…ƒç´ 
   - å †çš„å…ƒç´ æ•°é‡å‡ 1
   - å¯¹ 0 ä½ç½®è¿›è¡Œ 1 æ¬¡ siftDown æ“ä½œ

![image-20221003173557802](02-æ‹ä¸Šæ•°æ®ç»“æ„-ç®—æ³•ç¯‡.assets/image-20221003173557802.png)



```java
package com.xk._02Algorithmic._01sort.sort;

/**
 * @description: å †æ’åº
 * @author: xu
 * @date: 2022/10/1 4:57
 */
public class HeapSort<E extends Comparable<E>> extends Sort<E> {
    /**
     * å †æ’åºï¼šåŸåœ°å»ºå †
     */
    private void heapSort() {
        int heapSize = array.length;
        // åŸåœ°å»ºå † è‡ªä¸‹è€Œä¸Šçš„ä¸‹æ»¤
        for (int i = (heapSize >> 1) - 1; i >= 0; i--) {
            siftDown(i, heapSize);
        }
        while (heapSize > 1) {
            // äº¤æ¢å †é¡¶å…ƒç´ å’Œå°¾éƒ¨å…ƒç´ 
            swap(0, --heapSize);
            // å¯¹0ä½ç½®è¿›è¡Œsiftdownï¼ˆæ¢å¤å †çš„æ€§è´¨ï¼‰
            siftDown(0, heapSize);
        }
    }

    /**
     * ä¸‹æ»¤
     * @param index
     */
    private void siftDown(int index, int heapSize) {
        E element = array[index];
        // å¿…é¡»ä¿è¯indexä½ç½®æ˜¯éå¶å­èŠ‚ç‚¹
        int half = heapSize >> 1;
        while (index < half) {
            // é»˜è®¤ä¸ºå·¦å­èŠ‚ç‚¹è·Ÿå®ƒè¿›è¡Œæ¯”è¾ƒ
            int childIndex = (index << 1) + 1;
            E child = array[childIndex];

            // å³å­èŠ‚ç‚¹
            int rightIndex = childIndex + 1;
            // é€‰å‡ºå·¦å³å­èŠ‚ç‚¹æœ€å¤§çš„é‚£ä¸ª
            if (rightIndex < heapSize && cmp(child, array[rightIndex]) < 0){
                child = array[childIndex = rightIndex];
            }
            if (cmp(element, child) >= 0) break;

            // å°†å­èŠ‚ç‚¹å­˜æ”¾åˆ°indexä½ç½®
            array[index] = child;
            // é‡æ–°è®¾ç½® index
            index = childIndex;
        }
        array[index] = element;
    }

    @Override
    protected void sort() {
        heapSort();
    }
}
```



##### 2.3.2 å¤æ‚åº¦ä¸ç¨³å®šæ€§

- æœ€å¥½ã€æœ€åã€å¹³å‡æ—¶é—´å¤æ‚åº¦ï¼šO(nlogn)
- ç©ºé—´å¤æ‚åº¦ï¼šO(1)
- å †æ’åºå±äº**ä¸ç¨³å®šæ’åº**



#### 2.4 æ’å…¥æ’åº

##### 2.4.1 ä»£ç å®ç°

æ’å…¥æ’åºéå¸¸ç±»ä¼¼äºæ‰‘å…‹ç‰Œçš„æ’åºï¼Œå°†åé¢çš„ç‰Œä¸€å¼ å¼ æ’å…¥åˆ°å‰é¢ï¼Œä½¿å¾—å‰é¢æœ‰åºçš„ç‰Œé€æ¸å˜å¤šï¼Œç›´åˆ°å®Œå…¨æœ‰åºã€‚

![image-20221003174609730](02-æ‹ä¸Šæ•°æ®ç»“æ„-ç®—æ³•ç¯‡.assets/image-20221003174609730.png)

![image-20221003174613119](02-æ‹ä¸Šæ•°æ®ç»“æ„-ç®—æ³•ç¯‡.assets/image-20221003174613119.png)

æ‰§è¡Œæµç¨‹ï¼š

1. åœ¨æ‰§è¡Œè¿‡ç¨‹ä¸­ï¼Œæ’å…¥æ’åºä¼šå°†åºåˆ—åˆ†ä¸º2éƒ¨åˆ†ï¼šå¤´éƒ¨æ˜¯å·²ç»æ’å¥½åºçš„ï¼Œå°¾éƒ¨æ˜¯å¾…æ’åºçš„
2. ä»å¤´å¼€å§‹æ‰«ææ¯ä¸€ä¸ªå…ƒç´ ï¼šæ¯å½“æ‰«æåˆ°ä¸€ä¸ªå…ƒç´ ï¼Œå°±å°†å®ƒæ’å…¥åˆ°å¤´éƒ¨åˆé€‚çš„ä½ç½®ï¼Œä½¿å¾—å¤´éƒ¨æ•°æ®ä¾ç„¶ä¿æŒæœ‰åº

```java
package com.xk._02Algorithmic._01sort.sort;

/**
 * @description: æ’å…¥æ’åº
 * @author: xu
 * @date: 2022/10/1 23:08
 */
public class InsertionSort1<E extends Comparable<E>> extends Sort<E> {
    /**
     * æ’å…¥æ’åº
     */
    private void insertionSort1(){
        for (int begin = 1; begin < array.length; begin++) {
            int curIndex = begin;
            while (curIndex > 0 && cmp(curIndex-1, curIndex) > 0) {
                swap(curIndex, curIndex-1);
                curIndex--;
            }
        }
    }

    @Override
    protected void sort() {
        insertionSort1();
    }
}
```



##### 2.4.2 æ’å…¥æ’åº--é€†åºå¯¹

ä»€ä¹ˆæ˜¯é€†åºå¯¹ï¼Ÿ

- æ•°ç»„ <2, 3, 8, 6, 1> çš„é€†åºå¯¹ä¸ºï¼š

  <2, 1> <3, 1> <8, 1> <8, 6> <6, 1>ï¼Œå…±5ä¸ªé€†åºå¯¹

æ’å…¥æ’åºçš„æ—¶é—´å¤æ‚åº¦ä¸é€†åºå¯¹çš„æ•°é‡æˆæ­£æ¯”å…³ç³»

- é€†åºå¯¹çš„æ•°é‡è¶Šå¤šï¼Œæ’å…¥æ’åºçš„æ—¶é—´å¤æ‚åº¦è¶Šé«˜



å¾ˆæ˜æ˜¾ï¼Œä¸‹å›¾ä»ä¸Šè‡³ä¸‹ï¼Œ**æ’å…¥æ’åºçš„æ•ˆç‡æ˜¯é€æ¸æé«˜çš„**ã€‚

![image-20221003175325855](02-æ‹ä¸Šæ•°æ®ç»“æ„-ç®—æ³•ç¯‡.assets/image-20221003175325855.png)



##### 2.4.3 æ’å…¥æ’åº--ä¼˜åŒ–1

æ€è·¯æ˜¯å°†ã€äº¤æ¢ã€‘è½¬ä¸ºã€æŒªåŠ¨ã€‘

æ‰§è¡Œæµç¨‹ï¼š

1. å…ˆå°†å¾…æ’å…¥çš„å…ƒç´ å¤‡ä»½
2. å¤´éƒ¨æœ‰åºæ•°æ®ä¸­æ¯”å¾…æ’å…¥å…ƒç´ å¤§çš„ï¼Œéƒ½æœå°¾éƒ¨æ–¹å‘æŒªåŠ¨1ä¸ªä½ç½®
3. å°†å¾…æ’å…¥å…ƒç´ æ”¾åˆ°æœ€ç»ˆçš„åˆé€‚ä½ç½®

![image-20221003180016132](02-æ‹ä¸Šæ•°æ®ç»“æ„-ç®—æ³•ç¯‡.assets/image-20221003180016132.png)

```java
package com.xk._02Algorithmic._01sort.sort;

/**
 * @description: æ’å…¥æ’åºä¼˜åŒ– æ€è·¯ï¼šå°†ã€äº¤æ¢ã€‘è½¬ä¸ºã€æŒªåŠ¨ã€‘
 * @author: xu
 * @date: 2022/10/1 23:08
 */
public class InsertionSort2<E extends Comparable<E>> extends Sort<E> {
    /**
     * æ’å…¥æ’åºä¼˜åŒ– æ€è·¯ï¼šå°†ã€äº¤æ¢ã€‘è½¬ä¸ºã€æŒªåŠ¨ã€‘
     */
    private void insertionSort2(){
        for (int begin = 1; begin < array.length; begin++) {
            int curIndex = begin;
            E cur = array[curIndex];
            while (curIndex > 0 && cmp(array[curIndex - 1], cur) > 0) {
                array[curIndex] = array[curIndex - 1];
                curIndex--;
            }
            array[curIndex] = cur;
        }
    }

    @Override
    protected void sort() {
        insertionSort2();
    }
}
```



##### 2.4.4 å¤æ‚åº¦ä¸ç¨³å®šæ€§

- æœ€åã€å¹³å‡æ—¶é—´å¤æ‚åº¦ï¼šO(n<sup>2</sup>)

- æœ€å¥½æ—¶é—´å¤æ‚åº¦ï¼šO(n)

- ç©ºé—´å¤æ‚åº¦ï¼šO(1)

- å±äºç¨³å®šæ’åº

- å½“é€†åºå¯¹çš„æ•°é‡æå°‘æ—¶ï¼Œæ’å…¥æ’åºçš„æ•ˆç‡ç‰¹åˆ«é«˜

  ç”šè‡³é€Ÿåº¦æ¯” O(nlogn) çº§åˆ«çš„å¿«é€Ÿæ’åºè¿˜è¦å¿«

æ•°æ®é‡ä¸æ˜¯ç‰¹åˆ«å¤§çš„æ—¶å€™ï¼Œæ’å…¥æ’åºçš„æ•ˆç‡ä¹Ÿæ˜¯éå¸¸å¥½çš„ã€‚



##### 2.4.5 äºŒåˆ†æœç´¢ç®—æ³•

å¦‚ä½•ç¡®å®šä¸€ä¸ªå…ƒç´ åœ¨æ•°ç»„ä¸­çš„ä½ç½®ï¼Ÿï¼ˆå‡è®¾æ•°ç»„é‡Œé¢å…¨éƒ½æ˜¯æ•´æ•°ï¼‰

- å¦‚æœæ˜¯æ— åºæ•°ç»„ï¼Œä»ç¬¬ 0 ä¸ªä½ç½®å¼€å§‹éå†æœç´¢ï¼Œå¹³å‡æ—¶é—´å¤æ‚åº¦ï¼šO(n)

  ![image-20221003180309795](02-æ‹ä¸Šæ•°æ®ç»“æ„-ç®—æ³•ç¯‡.assets/image-20221003180309795.png)

-  å¦‚æœæ˜¯æœ‰åºæ•°ç»„ï¼Œå¯ä»¥ä½¿ç”¨äºŒåˆ†æœç´¢ï¼Œæœ€åæ—¶é—´å¤æ‚åº¦ï¼šO(logn)

  ![image-20221003180318001](02-æ‹ä¸Šæ•°æ®ç»“æ„-ç®—æ³•ç¯‡.assets/image-20221003180318001.png)

æ€è·¯ï¼š

- å‡è®¾åœ¨*[begin, end)*èŒƒå›´å†…æœç´¢æŸä¸ªå…ƒç´ *v*ï¼Œ*mid == (begin + end) / 2*ï¼›
- å¦‚æœ*v < m*ï¼Œå»*[begin, mid)*èŒƒå›´å†…äºŒåˆ†æœç´¢ï¼›
- å¦‚æœ*v > m*ï¼Œå»*[mid + 1, end)*èŒƒå›´å†…äºŒåˆ†æœç´¢ï¼›
- å¦‚æœ*v == m*ï¼Œç›´æ¥è¿”å›*mid*ã€‚

![image-20221003180635573](02-æ‹ä¸Šæ•°æ®ç»“æ„-ç®—æ³•ç¯‡.assets/image-20221003180635573.png)

![image-20221003180638089](02-æ‹ä¸Šæ•°æ®ç»“æ„-ç®—æ³•ç¯‡.assets/image-20221003180638089.png)

å®ç°ï¼š

```java
package com.xk._02Algorithmic._01sort;

import com.xk._02Algorithmic._01sort.tools.Asserts;

/**
 * @description:
 * @author: xu
 * @date: 2022/10/2 0:09
 */
public class BinarySearch {
    public static int indexOf(Integer[] array, int v) {
        if (array == null || array.length == 0) return -1;
        int begin = 0;
        int end = array.length;
        while (begin < end) {
            int mid = (begin + end) >> 1;
            if (v > array[mid]) {
                begin = mid + 1;
            } else if (v < array[mid]) {
                end = mid;
            } else {
                return mid;
            }
        }
        return -1;
    }

    public static void main(String[] args) {
        Integer[] array = { 2, 4, 6, 7, 11, 15, 22, 26 };
        Asserts.test(search(array, 5) == 2);
        Asserts.test(search(array, 1) == 0);
        Asserts.test(search(array, 15) == 6);
        Asserts.test(search(array, 33) == 8);
    }
}
```



##### 2.4.6 æ’å…¥æ’åº--äºŒåˆ†æœç´¢ä¼˜åŒ–

åœ¨å…ƒç´  v çš„æ’å…¥è¿‡ç¨‹ä¸­ï¼Œå¯ä»¥å…ˆ**äºŒåˆ†æœç´¢å‡ºåˆé€‚çš„æ’å…¥ä½ç½®**ï¼Œ**å†å°†å…ƒç´  v æ’å…¥**ã€‚

å‡è®¾æœ‰å¦‚ä¸‹åºåˆ—ï¼š

![image-20221003181121063](02-æ‹ä¸Šæ•°æ®ç»“æ„-ç®—æ³•ç¯‡.assets/image-20221003181121063.png)

è¦æ±‚äºŒåˆ†æœç´¢è¿”å›çš„æ’å…¥ä½ç½®ï¼š**ç¬¬1ä¸ªå¤§äº v çš„å…ƒç´ ä½ç½®**ï¼›

- å¦‚æœ v æ˜¯ 5ï¼Œè¿”å› 2
- å¦‚æœ v æ˜¯ 1ï¼Œè¿”å› 0
- å¦‚æœ v æ˜¯ 15ï¼Œè¿”å› 7
- å¦‚æœ v æ˜¯ 8ï¼Œè¿”å› 5



æ€è·¯ï¼š

- å‡è®¾åœ¨*[begin, end)*èŒƒå›´å†…æœç´¢æŸä¸ªå…ƒç´ *v*ï¼Œ*mid == (begin + end) / 2*ï¼›
- å¦‚æœ*v < m*ï¼Œå»*[begin, mid)*èŒƒå›´å†…äºŒåˆ†æœç´¢
- å¦‚æœ*v â‰¥ m*ï¼Œå»*[mid + 1, end)*èŒƒå›´å†…äºŒåˆ†æœç´¢

![image-20221003181545673](02-æ‹ä¸Šæ•°æ®ç»“æ„-ç®—æ³•ç¯‡.assets/image-20221003181545673.png)



å®ä¾‹ï¼š

![image-20221003181548828](02-æ‹ä¸Šæ•°æ®ç»“æ„-ç®—æ³•ç¯‡.assets/image-20221003181548828.png)

![image-20221003181552202](02-æ‹ä¸Šæ•°æ®ç»“æ„-ç®—æ³•ç¯‡.assets/image-20221003181552202.png)

![image-20221003181554918](02-æ‹ä¸Šæ•°æ®ç»“æ„-ç®—æ³•ç¯‡.assets/image-20221003181554918.png)



ä»£ç å®ç°ï¼š

```java
package com.xk._02Algorithmic._01sort.sort;

import com.xk._02Algorithmic._01sort.tools.Integers;

/**
 * @description: æ’å…¥æ’åºä¼˜åŒ– æ€è·¯ï¼šäºŒåˆ†æœç´¢æ³•
 * @author: xu
 * @date: 2022/10/1 23:08
 */
public class InsertionSort3<E extends Comparable<E>> extends Sort<E> {
    /**
     * æ’å…¥æ’åºä¼˜åŒ– æ€è·¯ï¼šäºŒåˆ†æœç´¢æ³•
     */
    private void insertionSort3(){
        for (int begin = 1; begin < array.length; begin++) {
            insert(begin, search(begin));
        }
    }

    /**
     * å°†sourceä½ç½®çš„å…ƒç´ æ’å…¥åˆ°destä½ç½®
     * @param source
     * @param dest
     */
    private void insert(int source, int dest){
        E v = array[source];
        for (int i = source; i > dest; i--){
            array[i] = array[i-1];
        }
        array[dest] = v;
    }

    /**
     * åˆ©ç”¨äºŒåˆ†æœç´¢æ³•æ‰¾åˆ° index ä½ç½®å…ƒç´ çš„å¾…æ’å…¥ä½ç½®
     * å·²ç»æ’å¥½åºçš„åŒºé—´èŒƒå›´[0, index)
     * @param index
     * @return
     */
    private int search(int index) {
        int begin = 0;
        int end = index;
        while (begin < end) {
            int mid = (begin + end) >> 1;
            if (cmp(index, mid) >= 0) {
                begin = mid + 1;
            } else {
                end = mid;
            }
        }
        return begin;
    }

    @Override
    protected void sort() {
        insertionSort3();
    }
}
```



##### 2.4.7 å¤æ‚åº¦ä¸ç¨³å®šæ€§

ä½¿ç”¨äº†äºŒåˆ†æœç´¢åï¼Œåªæ˜¯å‡å°‘äº†æ¯”è¾ƒæ¬¡æ•°ï¼Œä½†æ’å…¥æ’åºçš„**å¹³å‡æ—¶é—´å¤æ‚åº¦**ä¾ç„¶æ˜¯O(n<sup>2</sup>)

- æœ€åã€å¹³å‡æ—¶é—´å¤æ‚åº¦ï¼šO(n<sup>2</sup>)
- æœ€å¥½æ—¶é—´å¤æ‚åº¦ï¼šO(n)
- ç©ºé—´å¤æ‚åº¦ï¼šO(1)
- å±äºç¨³å®šæ’åº



#### 2.5 å½’å¹¶æ’åº

1945å¹´ç”±çº¦ç¿°Â·**å†¯Â·è¯ºä¼Šæ›¼**ï¼ˆJohn von Neumannï¼‰é¦–æ¬¡æå‡ºã€‚

æ‰§è¡Œæµç¨‹ï¼š

1. ä¸æ–­åœ°å°†å½“å‰åºåˆ—å¹³å‡åˆ†å‰²æˆ2ä¸ªå­åºåˆ—

   ç›´åˆ°ä¸èƒ½å†åˆ†å‰²ï¼ˆåºåˆ—ä¸­åªå‰©1ä¸ªå…ƒç´ ï¼‰

2. ä¸æ–­åœ°å°†2ä¸ªå­åºåˆ—åˆå¹¶æˆä¸€ä¸ªæœ‰åºåºåˆ—

   ç›´åˆ°æœ€ç»ˆåªå‰©ä¸‹1ä¸ªæœ‰åºåºåˆ—

![image-20221003193800030](02-æ‹ä¸Šæ•°æ®ç»“æ„-ç®—æ³•ç¯‡.assets/image-20221003193800030.png)

##### 2.5.1 åºåˆ—åˆ†å‰²--divide

```java
sort(0, array.length);
-----------------------------------------------------
/**
 * å¯¹ [begin, end) èŒƒå›´çš„æ•°æ®è¿›è¡Œå½’å¹¶æ’åº
 */	
private void sort(int begin, int end){
	if(end - begin < 2) return; // è‡³å°‘è¦2ä¸ªå…ƒç´ 
	
	int mid = (begin + end) >> 1;
	sort(begin, mid); // å½’å¹¶æ’åºå·¦åŠå­åºåˆ—
	sort(mid, end);	// å½’å¹¶æ’åºå³åŠå­åºåˆ—
	merge(begin, mid, end); // åˆå¹¶æ•´ä¸ªåºåˆ—
}
```



##### 2.5.2 åºåˆ—åˆå¹¶--merge

1. åˆå¹¶åˆ°æ–°åºåˆ—

å°†ä¸¤ä¸ªåºåˆ—åˆå¹¶çš„æ€è·¯ä¸ºï¼šå·¦åºåˆ—å’Œå³åºåˆ—ä¸­çš„å…ƒç´ æŒ¨ä¸ªæ¯”è¾ƒï¼Œ**å°†è¾ƒå°çš„æ”¾å…¥æ–°åºåˆ—ä¸­**ï¼Œæœ€åæ–°åºåˆ—ä¸­çš„å…ƒç´ å¿…ç„¶å‡åºã€‚

ä¸‹å›¾ä¸­ liï¼Œri åˆ†åˆ«ä»£è¡¨æŒ‡å‘å·¦ã€å³åºåˆ—çš„å…ƒç´ **ç´¢å¼•**ï¼Œai ä¸ºæ–°åºåˆ—ï¼ˆåˆå¹¶åçš„åºåˆ—ï¼‰çš„å…ƒç´ **ç´¢å¼•**ï¼›

ã€liã€‘ä»£è¡¨å·¦åºåˆ— li ä½ç½®çš„**å…ƒç´ **ï¼Œã€riã€‘ä»£è¡¨å³åºåˆ— ri ä½ç½®çš„**å…ƒç´ **ï¼Œã€aiã€‘ä¸ºæ–°åºåˆ— ai ä½ç½®çš„**å…ƒç´ **ï¼›

- ç¬¬ä¸€è½®ï¼šã€liã€‘ < ã€riã€‘ï¼Œã€liã€‘æ”¾å…¥æ–°æ•°ç»„ï¼Œã€aiã€‘=ã€liã€‘ï¼Œli++; ai++;
- ç¬¬äºŒè½®ï¼šã€liã€‘ > ã€riã€‘ï¼Œã€riã€‘æ”¾å…¥æ–°æ•°ç»„ï¼Œã€aiã€‘=ã€riã€‘ï¼Œri++; ai++;
- ç¬¬ä¸‰è½®ï¼šã€liã€‘ < ã€riã€‘ï¼Œã€liã€‘æ”¾å…¥æ–°æ•°ç»„ï¼Œã€aiã€‘=ã€liã€‘ï¼Œli++; ai++ï¼›
- ç¬¬å››è½®ï¼š**å·¦åºåˆ—å·²ç»éå†å®Œæ¯•**ï¼Œç›´æ¥å°†å³åºåˆ—å‰©ä½™å…ƒç´ æ”¾å…¥æ–°åºåˆ—ï¼Œå¾—åˆ°æ–°åºåˆ—ï¼ˆå‡åºï¼‰ã€‚

![image-20221003194655961](02-æ‹ä¸Šæ•°æ®ç»“æ„-ç®—æ³•ç¯‡.assets/image-20221003194655961.png)



2. åŸåœ°åˆå¹¶--merge

å°†ä¸¤ä¸ªåºåˆ—åˆå¹¶æ—¶ï¼Œä¸ä¸€å®šè¦åˆå¹¶åˆ°æ–°ç©ºé—´ï¼Œå¯ä»¥åˆç†çš„åˆ©ç”¨åŸç©ºé—´å®ç°**åŸåœ°åˆå¹¶**ã€‚

ä¾‹å¦‚ï¼š

- å°†**arrayçš„å·¦åŠéƒ¨åˆ†[begin, mid)**ï¼Œå¤‡ä»½åˆ° leftArray ä¸­ï¼›
- ç„¶åå°† **leftArray** è§†ä¸ºå·¦å­åºåˆ—ï¼Œ**arraryçš„å³åŠéƒ¨åˆ†[mid, end)**è§†ä¸ºå³å­åºåˆ—ï¼›
- å°†å·¦å­åºåˆ—å’Œå³å­åºåˆ—åˆå¹¶åˆ° array ä¸­ã€‚

![image-20221003195047280](02-æ‹ä¸Šæ•°æ®ç»“æ„-ç®—æ³•ç¯‡.assets/image-20221003195047280.png)

merge è¿‡ç¨‹ï¼š

- ã€liã€‘ <= ã€riã€‘

  array[ai] = leftArray[li]ï¼›

  li++ï¼Œai++;

- ã€liã€‘ > ã€riã€‘

  array[ai] = array[ri];

  ri++ï¼Œai++;



å¯¹åºåˆ— { 3, 8, 6, 10 } è¿›è¡Œå½’å¹¶æ’åºï¼š

![image-20221003195409467](02-æ‹ä¸Šæ•°æ®ç»“æ„-ç®—æ³•ç¯‡.assets/image-20221003195409467.png)

å¯¹åºåˆ— { 3, 6, 8, 10 } è¿›è¡Œå½’å¹¶æ’åºï¼š**å·¦å­åºåˆ—å…ˆéå†ç»“æŸ**ï¼Œé‚£å°±å½’å¹¶ç»“æŸã€‚

![image-20221003195522294](02-æ‹ä¸Šæ•°æ®ç»“æ„-ç®—æ³•ç¯‡.assets/image-20221003195522294.png)

å¯¹åºåˆ— { 8, 10, 3, 6 } è¿›è¡Œå½’å¹¶æ’åºï¼š**å³å­åºåˆ—å…ˆç»“æŸ**ï¼Œåˆ™å°†å·¦è¾¹å‰©ä½™å…¨éƒ¨æ”¾å…¥ã€‚

![image-20221003195602427](02-æ‹ä¸Šæ•°æ®ç»“æ„-ç®—æ³•ç¯‡.assets/image-20221003195602427.png)



3. åŸåœ°åˆå¹¶-merge-å®ç°

```java
/**
 * å°† [begin, mid) å’Œ [mid, end) èŒƒå›´çš„åºåˆ—åˆå¹¶æˆä¸€ä¸ªæœ‰åºåºåˆ—
 */
private void merge(int begin, int mid, int end){
	int li = 0, le = mid - begin; // å·¦è¾¹æ•°ç»„(åŸºäºleftArray)
	int ri = mid, re = end;	// å³è¾¹æ•°ç»„(array)
	int ai = begin; // arrayçš„ç´¢å¼•
	
	// å¤‡ä»½å·¦è¾¹æ•°ç»„åˆ°leftArray
	for(int i = li; i < le; i++){
		leftArray[i] = array[begin + i];
	}
	
	// å¦‚æœå·¦è¾¹è¿˜æ²¡æœ‰ç»“æŸ	
	while(li < le){ // li == le å·¦è¾¹ç»“æŸ, åˆ™ç›´æ¥ç»“æŸå½’å¹¶
		if(ri < re && cmp(array[ri], leftArray[li]) < 0){ // cmpæ”¹ä¸º<=0ä¼šå¤±å»ç¨³å®šæ€§
			array[ai++] = array[ri++]; // å³è¾¹<å·¦è¾¹, æ‹·è´å³è¾¹æ•°ç»„åˆ°array
		}else{
			array[ai++] = leftArray[li++]; // å·¦è¾¹<=å³è¾¹, æ‹·è´å·¦è¾¹æ•°ç»„åˆ°array
		}
	}
}

```



##### 2.5.3 å½’å¹¶æ’åºå®Œæ•´ä»£ç 

```java
package com.xk._02Algorithmic._01sort.sort;

import com.xk._02Algorithmic._01sort.tools.Integers;

/**
 * @description: å½’å¹¶æ’åº
 * @author: xu
 * @date: 2022/10/2 10:43
 */
public class MergeSort<E extends Comparable<E>> extends Sort<E> {
    private E[] leftArray;

    /**
     * å½’å¹¶æ’åº
     */
    private void mergeSort(){
        this.leftArray = (E[]) new Comparable[array.length >> 1];
        sort(0, array.length);
    }

    /**
     * å¯¹ [begin, end) èŒƒå›´çš„æ•°æ®è¿›è¡Œå½’å¹¶æ’åº
     * T(n) = T(n/2) + T(n/2) + O(n)
     * T(n) = 2 * T(n/2) + O(n)
     * @param begin
     * @param end
     */
    private void sort(int begin, int end) {
        // å…ƒç´ æ•°é‡å°äº2 è¿”å›
        if (end - begin < 2) return;
        int mid = (begin + end) >> 1;
        sort(begin, mid);
        sort(mid, end);
        merge(begin, mid, end);
    }

    /**
     * å°† [begin, mid) å’Œ [mid, end) èŒƒå›´çš„åºåˆ—åˆå¹¶æˆæœ‰åºåºåˆ—
     * @param begin
     * @param mid
     * @param end
     */
    private void merge(int begin, int mid, int end) {
        int li = 0, le = mid - begin;
        int ri = mid, re = end;
        int ai = begin;

        // å¤‡ä»½å·¦è¾¹æ•°ç»„
        for (int i = li; i < le; i++) {
            leftArray[i] = array[begin + i];
        }

        while (li < le) { // å¦‚æœå·¦è¾¹è¿˜æ²¡æœ‰ç»“æŸ
            if (ri < re && cmp(leftArray[li], array[ri]) > 0){
                array[ai++] = array[ri++];
            } else {
                array[ai++] = leftArray[li++];
            }
        }
    }

    @Override
    protected void sort() {
        mergeSort();
    }
}
```



##### 2.5.4 å¤æ‚åº¦ä¸ç¨³å®šæ€§

**å½’å¹¶æ’åºèŠ±è´¹çš„æ—¶é—´é€’æ¨å¼**ï¼š

- T(n) = 2âˆ—T(n/2) + O(n)
- T(1) = O(1)
- T(n)/n = T(n/2)/(n/2) + O(1)

**æ ¹æ®é€’æ¨å¼è®¡ç®—å¤æ‚åº¦**ï¼š

ä»¤Sn = T(n)/n

- S(1) = O(1)
- Sn = S(n/2)+O(1) = S(n/4)+O(2) = S(n/8)+O(3) = S(n/2<sup>k</sup>)+O(k) = S(1)+O(logn) = O(logn)
- Tn = nâˆ—Sn = O(nlogn)

ç”±äºå½’å¹¶æ’åºæ€»æ˜¯**å¹³å‡åˆ†å‰²å­åˆ—**ï¼Œæ‰€ä»¥

- **æœ€å¥½ã€æœ€åæ—¶é—´å¤æ‚åº¦**éƒ½æ˜¯ O(nlogn)

- å½’å¹¶æ’åºå±äº**ç¨³å®šæ’åº**

- å½’å¹¶æ’åºçš„**ç©ºé—´å¤æ‚åº¦**æ˜¯ O(n/2 + logn) = O(n)

  n/2 ç”¨äºä¸´æ—¶å­˜æ”¾å·¦ä¾§æ•°ç»„ï¼Œlogn æ˜¯å› ä¸ºé€’å½’è°ƒç”¨



##### 2.5.5 å¸¸è§çš„é€’æ¨å¼ä¸å¤æ‚åº¦

ä»¥åé‡åˆ°å¤æ‚çš„æ—¶é—´å¤æ‚åº¦è®¡ç®—ï¼Œå†™å‡ºé€’å½’å¼ç›´æ¥çœ‹è¿™å¼ è¡¨å³å¯ã€‚

![image-20221003201024133](02-æ‹ä¸Šæ•°æ®ç»“æ„-ç®—æ³•ç¯‡.assets/image-20221003201024133.png)



##### 2.5.6 LeetCodeçœŸé¢˜

###### åˆå¹¶ä¸¤ä¸ªæœ‰åºæ•°ç»„

é¢˜ç›®åœ°å€ï¼š[88. åˆå¹¶ä¸¤ä¸ªæœ‰åºæ•°ç»„](https://leetcode-cn.com/problems/merge-sorted-array/submissions/)

é¢˜ç›®ï¼š

- ç»™ä½ ä¸¤ä¸ªæœ‰åºæ•´æ•°æ•°ç»„ nums1 å’Œ nums2ï¼Œè¯·ä½ å°† nums2 åˆå¹¶åˆ° nums1 ä¸­ï¼Œä½¿ num1 æˆä¸ºä¸€ä¸ªæœ‰åºæ•°ç»„ã€‚

è¯´æ˜:

- åˆå§‹åŒ– nums1 å’Œ nums2 çš„å…ƒç´ æ•°é‡åˆ†åˆ«ä¸º m å’Œ n ã€‚
- ä½ å¯ä»¥å‡è®¾ nums1 æœ‰è¶³å¤Ÿçš„ç©ºé—´ï¼ˆç©ºé—´å¤§å°å¤§äºæˆ–ç­‰äºm + nï¼‰æ¥ä¿å­˜ nums2 ä¸­çš„å…ƒç´ ã€‚

ç¤ºä¾‹ï¼š

```java
è¾“å…¥:
nums1 = [1,2,3,0,0,0], m = 3
nums2 = [2,5,6],       n = 3

è¾“å‡º: [1,2,2,3,5,6]
```





#### 2.6 å¿«é€Ÿæ’åº

æ‰§è¡Œæµç¨‹ï¼š

1. ä»åºåˆ—ä¸­é€‰æ‹©ä¸€ä¸ª**è½´ç‚¹å…ƒç´ **ï¼ˆpivotï¼‰ï¼šå‡è®¾æ¯æ¬¡é€‰æ‹©`0`ä½ç½®çš„å…ƒç´ ä¸ºè½´ç‚¹å…ƒç´ 
2. åˆ©ç”¨ pivot å°†åºåˆ—åˆ†å‰²æˆ 2 ä¸ªå­åºåˆ—
   - å°†å°äº pivot çš„å…ƒç´ æ”¾åœ¨pivotå‰é¢ï¼ˆå·¦ä¾§ï¼‰
   - å°†å¤§äº pivot çš„å…ƒç´ æ”¾åœ¨pivotåé¢ï¼ˆå³ä¾§ï¼‰
   - ç­‰äºpivotçš„å…ƒç´ æ”¾å“ªè¾¹éƒ½å¯ä»¥
3. å¯¹å­åºåˆ—è¿›è¡Œ*1*ã€*2*æ“ä½œï¼šç›´åˆ°ä¸èƒ½å†åˆ†å‰²ï¼ˆå­åºåˆ—ä¸­åªå‰©ä¸‹1ä¸ªå…ƒç´ ï¼‰

![image-20221004125914298](02-æ‹ä¸Šæ•°æ®ç»“æ„-ç®—æ³•ç¯‡.assets/image-20221004125914298.png)

> å¿«é€Ÿæ’åºçš„æœ¬è´¨å°±æ˜¯ï¼š
>
> - é€æ¸å°†æ¯ä¸€ä¸ªå…ƒç´ éƒ½è½¬æ¢æˆè½´ç‚¹å…ƒç´ 



##### 2.6.1 è½´ç‚¹æ„é€ 

å¯¹äºåºåˆ— { 6<sub>a</sub>, 8<sub>a</sub>, 8<sub>b</sub>, 2, 6<sub>b</sub>, 4, 9, 5, 7 } **æ„é€ è½´ç‚¹**ï¼š

- é¦–å…ˆå°† `0` ä½ç½®çš„å…ƒç´ å¤‡ä»½ï¼Œä½œä¸º**è½´ç‚¹å…ƒç´ **ï¼›

  ![image-20221004130142427](02-æ‹ä¸Šæ•°æ®ç»“æ„-ç®—æ³•ç¯‡.assets/image-20221004130142427.png)

- æœ€ç»ˆç›®æ ‡æ˜¯æ„é€ å‡º**ä»¥è½´ç‚¹å…ƒç´ ä¸ºä¸­å¿ƒçš„åºåˆ—**ï¼š

  å·¦åŠè¾¹æ˜¯**å°äºè½´ç‚¹å…ƒç´ **çš„**åºåˆ—**ï¼›

  å³åŠè¾¹æ˜¯**å¤§äºè½´ç‚¹å…ƒç´ **çš„**åºåˆ—**ï¼›å¦‚ä¸‹å›¾ï¼š

  ![image-20221004130408002](02-æ‹ä¸Šæ•°æ®ç»“æ„-ç®—æ³•ç¯‡.assets/image-20221004130408002.png)

é‚£ä¹ˆå¦‚ä½•æ„é€ å‘¢ï¼Ÿ

begin ä¸ºåºåˆ—é¦–ä½ç½®ï¼Œ

- ä»å³å¾€å·¦æ‰«æï¼Œå¯»æ‰¾æ¯”è½´ç‚¹å…ƒç´ å°çš„å…ƒç´ ï¼›**æ‰¾åˆ°ä»¥å**ï¼Œæ”¾åˆ° begin ä½ç½®ï¼Œbegin++ï¼Œç„¶å**åå‘å¯»æ‰¾**ï¼›
- ä»å·¦å¾€å³æ‰«æï¼Œå¯»æ‰¾æ¯”è½´ç‚¹å…ƒç´ å¤§çš„å…ƒç´ ï¼›**æ‰¾åˆ°ä»¥å**ï¼Œæ”¾åˆ° end ä½ç½®ï¼Œend--ï¼Œç„¶å**åå‘å¯»æ‰¾**ï¼›
- å½“ begin == endï¼Œè¯´æ˜å·¦å³éƒ½æ‰«æå®Œäº†ï¼Œæ­¤æ—¶**å°†ä¸€å¼€å§‹å¤‡ä»½çš„è½´ç‚¹å…ƒç´ æ”¾åˆ°ä¸­é—´**ã€‚

è¿™ä¸ªè¿‡ç¨‹æœ‰ç‚¹è¿·æƒ‘æ€§ï¼Œéœ€è¦å…ˆä»å³å¾€å·¦æ‰¾ï¼Œæ‰¾åˆ°ä»¥åå†ä»å·¦å¾€å³ï¼Œä¸æ–­å¾ªç¯è¿™ä¸ªè¿‡ç¨‹ï¼Œç›´åˆ°**æŠŠæ‰€æœ‰æ¯”è½´ç‚¹å…ƒç´ å°çš„å…ƒç´ æ”¾åˆ°å·¦åŠéƒ¨åˆ†**ï¼Œ**æŠŠæ‰€æœ‰æ¯”è½´ç‚¹å…ƒç´ å¤§çš„å…ƒç´ æ”¾åˆ°å³åŠéƒ¨åˆ†**ï¼Œæ‰ç®—å®Œæˆè¿™ä¸ªè½´ç‚¹çš„æ„é€ ã€‚

![image-20221004130832461](02-æ‹ä¸Šæ•°æ®ç»“æ„-ç®—æ³•ç¯‡.assets/image-20221004130832461.png)



##### 2.6.2 æ„é€ è½´ç‚¹--ä»£ç å®ç°

ä»£ç ä¸­å¦‚ä½•å®ç°**ä»å·¦å¾€å³æ‰«æ**å’Œ**ä»å³å¾€å·¦æ‰«æ**çš„äº¤æ›¿å‘¢ï¼Ÿçœ‹ä¸€çœ¼ä»£ç å°±ä¼šæç„¶å¤§æ‚Ÿã€‚ã€‚ã€‚

```java
/**
 * æ„é€ å‡º [begin, end) èŒƒå›´çš„è½´ç‚¹å…ƒç´ 
 * @param begin
 * @param end
 * @return è½´ç‚¹å…ƒç´ çš„æœ€ç»ˆä½ç½®
 */
private int pivotIndex (int begin, int end) {
    // å¤‡ä»½beginä½ç½®çš„å…ƒç´ 
    E pivot = array[begin];
    // endæŒ‡å‘æœ€åä¸€ä¸ªå…ƒç´ 
    end--;
    while (begin < end) {
        while (begin < end) {
            if (cmp(pivot, array[end]) < 0) { // å³è¾¹å…ƒç´  > è½´ç‚¹å…ƒç´ 
                end--;
            } else { // å³è¾¹å…ƒç´  <= è½´ç‚¹å…ƒç´ 
                array[begin++] = array[end];
                break;
            }
        }
        while (begin < end) {
            if (cmp(pivot, array[begin]) > 0) {// å·¦è¾¹å…ƒç´  < è½´ç‚¹å…ƒç´ 
                begin++;
            } else { // å·¦è¾¹å…ƒç´  >= è½´ç‚¹å…ƒç´ 
                array[end--] = array[begin];
                break;
            }
        }
    }
    //å°†è½´ç‚¹å…ƒç´ æ”¾å…¥æœ€ç»ˆçš„ä½ç½®
    array[begin] = pivot;
    // è¿”å›è½´ç‚¹å…ƒç´ çš„ä½ç½®
    return begin;
}
```



##### 2.6.3 æ„é€ è½´ç‚¹--ä¼˜åŒ–

åœ¨è½´ç‚¹å·¦å³å…ƒç´ æ•°é‡æ¯”è¾ƒå‡åŒ€çš„æƒ…å†µä¸‹ï¼ŒåŒæ—¶ä¹Ÿæ˜¯**æœ€å¥½æƒ…å†µ**ï¼š

- T(n) = 2 âˆ— T(n/2) + O(n) = O(nlogn)

å¦‚æœè½´ç‚¹å·¦å³å…ƒç´ æ•°é‡æåº¦ä¸å‡åŒ€ï¼Œ**æœ€åæƒ…å†µ**ï¼š

- T(n) = T(n âˆ’ 1) + O(n) = O(n<sup>2</sup>)

ä¸ºäº†é™ä½æœ€åæƒ…å†µçš„å‡ºç°æ¦‚ç‡ï¼Œä¸€èˆ¬é‡‡å–çš„åšæ³•æ˜¯ï¼š

- **éšæœºé€‰æ‹©è½´ç‚¹å…ƒç´ **ï¼šå¯ä»¥åœ¨å¤‡ä»½è½´ç‚¹å…ƒç´ å‰ï¼Œå°† begin ä½ç½®çš„å…ƒç´ ä¸åºåˆ—ä¸­çš„éšæœºå…ƒç´ äº¤æ¢ä¸€ä¸‹ã€‚

```java
// éšæœºé€‰æ‹©è½´ç‚¹å…ƒç´ , å°† begin ä½ç½®çš„å…ƒç´ ä¸åºåˆ—ä¸­çš„éšæœºå…ƒç´ äº¤æ¢ä¸€ä¸‹
swap(begin, begin + (int)Math.random()*(end - begin));

// å¤‡ä»½beginä½ç½®çš„å…ƒç´ 
T pivot = array[begin];
.....
```



##### 2.6.4 æ€è€ƒï¼šä¸è½´ç‚¹ç›¸ç­‰çš„å…ƒç´ 

å¦‚æœåºåˆ—ä¸­çš„æ‰€æœ‰å…ƒç´ éƒ½ä¸è½´ç‚¹å…ƒç´ ç›¸ç­‰ï¼Œ**åˆ©ç”¨ä¸Šé¢çš„ç®—æ³•å®ç°**ï¼Œè½´ç‚¹å…ƒç´ å¯ä»¥å°†åºåˆ—åˆ†å‰²æˆ 2 ä¸ªå‡åŒ€çš„å­åºåˆ—

![image-20221004133556562](02-æ‹ä¸Šæ•°æ®ç»“æ„-ç®—æ³•ç¯‡.assets/image-20221004133556562.png)

**æ€è€ƒï¼šæŠŠä¸Šé¢çš„ä»£ç ä¸­ï¼Œcmp ä½ç½®çš„åˆ¤æ–­åˆ†åˆ«æ”¹ä¸º â‰¤ã€â‰¥ ä¼šèµ·åˆ°ä»€ä¹ˆæ•ˆæœ**?

![image-20221004133646582](02-æ‹ä¸Šæ•°æ®ç»“æ„-ç®—æ³•ç¯‡.assets/image-20221004133646582.png)

åæœï¼š

- è½´ç‚¹å…ƒç´ åˆ†å‰²å‡ºæ¥çš„å­åºåˆ—æåº¦ä¸å‡åŒ€
- å¯¼è‡´å‡ºç°æœ€åæ—¶é—´å¤æ‚åº¦ O(n<sup>2</sup>)



##### 2.6.5 å¿«é€Ÿæ’åºå®Œæ•´ä»£ç 

```java
package com.xk._02Algorithmic._01sort.sort.cmp;

import com.xk._02Algorithmic._01sort.sort.Sort;

/**
 * @description: å¿«é€Ÿæ’åº
 * @author: xu
 * @date: 2022/10/2 10:43
 */
public class QuickSort<E extends Comparable<E>> extends Sort<E> {
    /**
     * å¿«é€Ÿæ’åº
     */
    private void quickSort(){
        quickSort(0, array.length);
    }

    /**
     * å¯¹ [begin, end) èŒƒå›´çš„å…ƒç´ è¿›è¡Œå¿«é€Ÿæ’åº
     * æœ€å¥½çš„æƒ…å†µï¼šå·¦å³å‡åŒ€
     *      T(n) = T(n/2) + T(n/2) + O(n)
     *      T(n) = 2 * T(n/2) + O(n) = O(nlogn)
     * æœ€åçš„æƒ…å†µï¼šè½´ç‚¹ä¸€ç›´åœ¨æœ€å³è¾¹æˆ–è€…æœ€æœ€å·¦è¾¹
     *      T(n) = T(n-1) + O(n) = O(n^2)
     * @param begin
     * @param end
     */
    private void quickSort(int begin, int end){
        if (end - begin < 2) return;
        // ç¡®å®šè½´ç‚¹ä½ç½® O(n)
        int mid = pivotIndex(begin, end); // O(n)
        // å¯¹å­åºåˆ—è¿›è¡Œå¿«é€Ÿæ’åº
        quickSort(begin, mid);
        quickSort(mid+1, end);
    }

    /**
     * æ„é€ å‡º [begin, end) èŒƒå›´çš„è½´ç‚¹å…ƒç´ 
     * @param begin
     * @param end
     * @return è½´ç‚¹å…ƒç´ çš„æœ€ç»ˆä½ç½®
     */
    private int pivotIndex (int begin, int end) {
        // éšæœºé€‰æ‹©ä¸€ä¸ªå…ƒç´ è·Ÿ begin ä½ç½®è¿›è¡Œäº¤æ¢
        swap(begin, begin + (int) (Math.random() * (end - begin)));
    
        // å¤‡ä»½beginä½ç½®çš„å…ƒç´ 
        E pivot = array[begin];
        // endæŒ‡å‘æœ€åä¸€ä¸ªå…ƒç´ 
        end--;
        while (begin < end) {
            while (begin < end) {
                if (cmp(pivot, array[end]) < 0) { // å³è¾¹å…ƒç´  > è½´ç‚¹å…ƒç´ 
                    end--;
                } else { // å³è¾¹å…ƒç´  <= è½´ç‚¹å…ƒç´ 
                    array[begin++] = array[end];
                    break;
                }
            }
            while (begin < end) {
                if (cmp(pivot, array[begin]) > 0) {// å·¦è¾¹å…ƒç´  < è½´ç‚¹å…ƒç´ 
                    begin++;
                } else { // å·¦è¾¹å…ƒç´  >= è½´ç‚¹å…ƒç´ 
                    array[end--] = array[begin];
                    break;
                }
            }
        }
        //å°†è½´ç‚¹å…ƒç´ æ”¾å…¥æœ€ç»ˆçš„ä½ç½®
        array[begin] = pivot;
        // è¿”å›è½´ç‚¹å…ƒç´ çš„ä½ç½®
        return begin;
    }

    @Override
    protected void sort() {
        quickSort();
    }
}
```



##### 2.6.6 å¤æ‚åº¦ä¸ç¨³å®šæ€§

**å¿«é€Ÿæ’åºçš„å¤æ‚åº¦ä¸ç¨³å®šæ€§**ï¼š

- æœ€å¥½ã€å¹³å‡æ—¶é—´å¤æ‚åº¦ï¼šO(nlogn)
- æœ€åæ—¶é—´å¤æ‚åº¦ï¼šO(n<sup>2</sup>)
- ç”±äº**é€’å½’**è°ƒç”¨çš„ç¼˜æ•…ï¼Œç©ºé—´å¤æ‚åº¦ï¼šO(logn)
- å±äº**ä¸ç¨³å®šæ’åº**



#### 2.7 å¸Œå°”æ’åº

å¸Œå°”æ’åºæŠŠåºåˆ—çœ‹ä½œæ˜¯ä¸€ä¸ªçŸ©é˜µï¼Œåˆ†æˆ ğ‘š åˆ—ï¼Œé€åˆ—è¿›è¡Œæ’åº

- ğ‘š ä»æŸä¸ªæ•´æ•°é€æ¸å‡ä¸º1
- å½“ ğ‘š ä¸º1æ—¶ï¼Œæ•´ä¸ªåºåˆ—å°†å®Œå…¨æœ‰åº

å› æ­¤ï¼Œå¸Œå°”æ’åºä¹Ÿè¢«ç§°ä¸º**é€’å‡å¢é‡æ’åº**ï¼ˆDiminishing Increment Sortï¼‰

çŸ©é˜µçš„åˆ—æ•°å–å†³äº**æ­¥é•¿åºåˆ—**ï¼ˆstep sequenceï¼‰ï¼š

- æ¯”å¦‚ï¼Œå¦‚æœæ­¥é•¿åºåˆ—ä¸º{ 1, 5, 19, 41, 109 }ï¼Œå°±ä»£è¡¨ä¾æ¬¡åˆ†æˆ109åˆ—ã€41åˆ—ã€19åˆ—ã€5åˆ—ã€1åˆ—è¿›è¡Œæ’åº
- ä¸åŒçš„æ­¥é•¿åºåˆ—ï¼Œæ‰§è¡Œæ•ˆç‡ä¹Ÿä¸åŒ



##### 2.7.1 å®ä¾‹å›¾è§£

å¸Œå°”æœ¬äººç»™å‡ºçš„æ­¥é•¿åºåˆ—æ˜¯ ğ‘›/2<sup>k</sup>(k>=1)ï¼Œæ¯”å¦‚ ğ‘› ä¸º16æ—¶ï¼Œ**æ­¥é•¿åºåˆ—**æ˜¯ { 1, 2, 4, 8 }

å‡è®¾æœ‰å¦‚ä¸‹åºåˆ—ï¼š{ 16, 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1 }

![img](02-æ‹ä¸Šæ•°æ®ç»“æ„-ç®—æ³•ç¯‡.assets/20200328121444368.png)

æŒ‰ç…§æ­¥é•¿åºåˆ—ï¼Œé¦–å…ˆ**åˆ†ä¸º8åˆ—ï¼Œå¯¹æ¯ä¸€åˆ—è¿›è¡Œæ’åº**ï¼š

![image-20221004135100351](02-æ‹ä¸Šæ•°æ®ç»“æ„-ç®—æ³•ç¯‡.assets/image-20221004135100351.png)

ç„¶å**åˆ†ä¸º4åˆ—ï¼Œå¯¹æ¯ä¸€åˆ—è¿›è¡Œæ’åº**ï¼š

![image-20221004135135807](02-æ‹ä¸Šæ•°æ®ç»“æ„-ç®—æ³•ç¯‡.assets/image-20221004135135807.png)

ç„¶å**åˆ†ä¸º2åˆ—ï¼Œå¯¹æ¯ä¸€åˆ—è¿›è¡Œæ’åº**ï¼š

![image-20221004135224388](02-æ‹ä¸Šæ•°æ®ç»“æ„-ç®—æ³•ç¯‡.assets/image-20221004135224388.png)

æœ€å**åˆ†ä¸º1åˆ—è¿›è¡Œæ’åº**ï¼Œå˜æˆå‡åºåºåˆ—ã€‚

![image-20221004135320282](02-æ‹ä¸Šæ•°æ®ç»“æ„-ç®—æ³•ç¯‡.assets/image-20221004135320282.png)

ä¸éš¾çœ‹å‡ºæ¥ï¼Œä»8åˆ—å˜ä¸º1åˆ—çš„è¿‡ç¨‹ä¸­ï¼Œ**é€†åºå¯¹çš„æ•°é‡åœ¨é€æ¸å‡å°‘**

è¿˜è®°å¾—`æ’å…¥æ’åº`çš„è¿™ä¸ªæ€§è´¨å—ï¼š

- æ’å…¥æ’åºçš„**æ—¶é—´å¤æ‚åº¦ä¸é€†åºå¯¹çš„æ•°é‡æˆæ­£æ¯”**å…³ç³»
- é€†åºå¯¹çš„æ•°é‡è¶Šå¤šï¼Œæ’å…¥æ’åºçš„æ—¶é—´å¤æ‚åº¦è¶Šé«˜ã€‚

å› æ­¤å¸Œå°”æ’åºåº•å±‚ä¸€èˆ¬ä½¿ç”¨`æ’å…¥æ’åº`å¯¹æ¯ä¸€åˆ—è¿›è¡Œæ’åºï¼Œå¯ä»¥è®¤ä¸ºå¸Œå°”æ’åºæ˜¯`æ’å…¥æ’åº`çš„æ”¹è¿›ç‰ˆã€‚



##### 2.7.2 åˆ—çš„åˆ’åˆ†æ€è·¯

å‡è®¾æœ‰11ä¸ªå…ƒç´ ï¼Œ**æ­¥é•¿åºåˆ—æ˜¯ {1, 2, 5}**ï¼š

![image-20221004135728798](02-æ‹ä¸Šæ•°æ®ç»“æ„-ç®—æ³•ç¯‡.assets/image-20221004135728798.png)

å‡è®¾å…ƒç´ åœ¨ç¬¬ col åˆ—ã€ç¬¬ row è¡Œï¼Œæ­¥é•¿ï¼ˆæ€»åˆ—æ•°ï¼‰æ˜¯ step

- é‚£ä¹ˆè¿™ä¸ªå…ƒç´ **åœ¨æ•°ç»„ä¸­çš„ç´¢å¼•**æ˜¯ row * step + col
- æ¯”å¦‚ 9 åœ¨æ’åºå‰æ˜¯ç¬¬ 0 è¡Œã€ç¬¬ 2 åˆ—ï¼Œé‚£ä¹ˆå®ƒæ’åºå‰çš„ç´¢å¼•æ˜¯ 0 * 5 + 2 = 2
- æ¯”å¦‚ 4 åœ¨æ’åºå‰æ˜¯ç¬¬ 1 è¡Œã€ç¬¬ 2 åˆ—ï¼Œé‚£ä¹ˆå®ƒæ’åºå‰çš„ç´¢å¼•æ˜¯ 1 * 5 + 2 = 7



##### 2.7.3 æ­¥é•¿åºåˆ—è®¡ç®—ä»£ç 

å¸Œå°”æœ¬äººç»™å‡ºçš„æ­¥é•¿åºåˆ—æ˜¯ ğ‘›/2<sup>k</sup>(k>=1)ï¼Œæ¯”å¦‚ ğ‘› ä¸º16æ—¶ï¼Œ**æ­¥é•¿åºåˆ—**æ˜¯ { 1, 2, 4, 8 }

```java
/**
 * å¸Œå°”æœ¬äººæå‡ºçš„æ­¥é•¿åºåˆ—
 */
private List<Integer> shellStepSequence() {
    List<Integer> stepSequence = new ArrayList<>();
    int step = array.length;
    while ((step >>= 1) > 0) {
        stepSequence.add(step);
    }
    return stepSequence;
}
```



##### 2.7.4 å¸Œå°”æ’åºå®Œæ•´å®ç°

```java
package com.xk._02Algorithmic._01sort.sort.cmp;

import com.xk._02Algorithmic._01sort.sort.Sort;

import java.util.ArrayList;
import java.util.List;

/**
 * @description: å¸Œå°”æ’åº
 * @author: xu
 * @date: 2022/10/2 10:43
 */
public class ShellSort1<E extends Comparable<E>> extends Sort<E> {
    /**
     * å¸Œå°”æ’åº
     */
    private void shellSort(){
        List<Integer> stepSequence = shellStepSequence();
        for (Integer step : stepSequence) {
            shellSort(step);
        }
    }

    /**
     * åˆ†æˆstepåˆ—è¿›è¡Œæ’åº
     * @param step
     */
    private void shellSort(int step) {
        // col: ç¬¬å‡ åˆ—
        for (int col = 0; col < step; col++) { // å¯¹ç¬¬colåˆ—è¿›è¡Œæ’åº
            // å¯¹ [0, array.length) èŒƒå›´çš„å…ƒç´ è¿›è¡Œæ’å…¥å…ƒç´ 
            // colã€col+stepã€col+2*stepã€col+3*step......
            for (int row = col + step; row < array.length; row += step) {
                int curIndex = row;
                while (curIndex > col && cmp(curIndex - step, curIndex) > 0) {
                    swap(curIndex, curIndex - step);
                    curIndex -= step;
                }
            }
        }
    }

    private List<Integer> shellStepSequence() {
        List<Integer> stepSequence = new ArrayList<>();
        int step = array.length;
        while ((step >>= 1) > 0) {
            stepSequence.add(step);
        }
        return stepSequence;
    }

    @Override
    protected void sort() {
        shellSort();
    }
}
```



##### 2.7.5 å¸Œå°”æ’åºä¼˜åŒ–

ç›®å‰**å·²çŸ¥çš„æœ€å¥½çš„æ­¥é•¿åºåˆ—**ï¼Œ**æœ€åæƒ…å†µæ—¶é—´å¤æ‚åº¦**æ˜¯O(n<sup>4/3</sup>) ï¼Œ1986å¹´ç”±Robert Sedgewickæå‡º

![image-20221004141313150](02-æ‹ä¸Šæ•°æ®ç»“æ„-ç®—æ³•ç¯‡.assets/image-20221004141313150.png)

```java
private List<Integer> shellStepSequence() {
    List<Integer> stepSequence = new LinkedList<>();
    int k = 0, step = 0;
    while (true) {
        if (k % 2 == 0) { // even
            int pow = (int) Math.pow(2, k >> 1);
            step = 1 + 9 * (pow * pow - pow);
        } else { // odd
            int pow1 = (int) Math.pow(2, (k - 1) >> 1);
            int pow2 = (int) Math.pow(2, (k + 1) >> 1);
            step = 1 + 8 * pow1 * pow2 - 6 * pow2;
        }
        if (step >= array.length) break;
        stepSequence.add(0, step);
        k++;
    }
    return stepSequence;
}
```



##### 2.7.6 å¤æ‚åº¦ä¸ç¨³å®šæ€§

- æœ€å¥½æƒ…å†µæ˜¯**æ­¥é•¿åºåˆ—åªæœ‰1ï¼Œä¸”åºåˆ—å‡ ä¹æœ‰åº**ï¼Œæ—¶é—´å¤æ‚åº¦ä¸º O(n)
- **æœ€åå’Œå¹³å‡**æ—¶é—´å¤æ‚åº¦å–å†³**æ­¥é•¿åºåˆ—**, èŒƒå›´åœ¨ O(n<sup>3/4</sup>) ~ O(n<sup>2</sup>)
- ç©ºé—´å¤æ‚åº¦ä¸ºO(1)
- å¸Œå°”æ’åºå±äº**ä¸ç¨³å®šæ’åº**



#### 2.8 è®¡æ•°æ’åº

ä¹‹å‰å­¦ä¹ çš„*å†’æ³¡*ã€*é€‰æ‹©*ã€*å †*ã€*æ’å…¥*ã€*å½’å¹¶*ã€*å¿«é€Ÿ*ã€*å¸Œå°”*æ’åºéƒ½æ˜¯**åŸºäºæ¯”è¾ƒ**çš„æ’åºã€‚

*è®¡æ•°*æ’åºã€*æ¡¶*æ’åºã€*åŸºæ•°*æ’åºï¼Œéƒ½**ä¸æ˜¯åŸºäºæ¯”è¾ƒ**çš„æ’åºã€‚

- å®ƒä»¬æ˜¯å…¸å‹çš„**ç”¨ç©ºé—´æ¢æ—¶é—´**ï¼Œåœ¨æŸäº›æ—¶å€™ï¼Œå¹³å‡æ—¶é—´å¤æ‚åº¦å¯ä»¥æ¯” O(nlogn) æ›´ä½

è®¡æ•°æ’åºäº1954å¹´ç”±Harold H.Sewardæå‡ºï¼Œé€‚åˆ**å¯¹ä¸€å®šèŒƒå›´å†…çš„æ•´æ•°**è¿›è¡Œæ’åºã€‚

è®¡æ•°æ’åºçš„æ ¸å¿ƒæ€æƒ³ï¼š

- ç»Ÿè®¡æ¯ä¸ªæ•´æ•°åœ¨åºåˆ—ä¸­å‡ºç°çš„æ¬¡æ•°ï¼Œè¿›è€Œæ¨å¯¼å‡ºæ¯ä¸ªæ•´æ•°åœ¨æœ‰åºåºåˆ—ä¸­çš„ç´¢å¼•



##### 2.8.1 ç®€å•å®ç°--å®ç°æ­¥éª¤

æ€è·¯ï¼š

- é¦–å…ˆæ‰¾å‡ºè¦æ’åºæ•°ç»„çš„ä¸­çš„æœ€å¤§å€¼ maxï¼›
- æ ¹æ®æœ€å¤§å€¼ max å¼€è¾Ÿ max + 1 ç©ºé—´çš„æ•°ç»„ countsï¼›
- counts æ•°ç»„ç»Ÿè®¡æ¯ä¸ªæ•´æ•°å‡ºç°çš„æ¬¡æ•°ï¼›
- æ ¹æ®æ•´æ•°å‡ºç°çš„æ¬¡æ•°ï¼Œå¯¹æ•´æ•°è¿›è¡Œæ’åºï¼š
  - éå† counts æ•°ç»„ï¼Œ**ç´¢å¼•indexå³ä¸ºå…ƒç´ å€¼**ï¼Œ**counts[index]** ä¸ºå…ƒç´ çš„å‡ºç°æ¬¡æ•°
  - å°† counts[index] ä¸ª index ä¾æ¬¡æ”¾å…¥æ•°ç»„ï¼Œå³ä¸ºæ’åºè¿‡çš„åºåˆ—



ä¾‹å¦‚å¯¹ { 7, 3, 5, 8, 6, 7, 4, 5 } è¿›è¡Œè®¡æ•°æ’åºï¼šmax = 8

- counts æ•°ç»„ä¸º [0, 0, 0, 1, 1, 2, 1, 2, 1]

- å¯¹ index = 3, counts[index] = 1ï¼Œå³**å¾€æ–°æ•°ç»„ä¸­æ”¾å…¥ 1 ä¸ª 3**ï¼›

  æ­¤æ—¶æ–°æ•°ç»„ä¸º [3]

- å¯¹ index = 4, counts[index] = 1ï¼Œå³**å¾€æ–°æ•°ç»„ä¸­æ”¾å…¥ 1 ä¸ª 4**ï¼›

  æ­¤æ—¶æ–°æ•°ç»„ä¸º [3, 4]

- å¯¹ index = 5, counts[index] = 2ï¼Œå³**å¾€æ–°æ•°ç»„ä¸­æ”¾å…¥ 2 ä¸ª 5**ï¼›

  æ­¤æ—¶æ–°æ•°ç»„ä¸º [3, 4, 5, 5]

- å¯¹ index = 6, counts[index] = 1ï¼Œå³**å¾€æ–°æ•°ç»„ä¸­æ”¾å…¥ 1 ä¸ª 6**ï¼›

  æ­¤æ—¶æ–°æ•°ç»„ä¸º [3, 4, 5, 5, 6]

- å¯¹ index = 7, counts[index] = 2ï¼Œå³**å¾€æ–°æ•°ç»„ä¸­æ”¾å…¥ 2 ä¸ª 7**ï¼›

  æ­¤æ—¶æ–°æ•°ç»„ä¸º [3, 4, 5, 5, 6, 7, 7]

- å¯¹ index = 8, counts[index] = 1ï¼Œå³**å¾€æ–°æ•°ç»„ä¸­æ”¾å…¥ 1 ä¸ª 8**ï¼›

  æ­¤æ—¶æ–°æ•°ç»„ä¸º [3, 4, 5, 5, 6, 7, 7, 8]

![image-20221004173046091](02-æ‹ä¸Šæ•°æ®ç»“æ„-ç®—æ³•ç¯‡.assets/image-20221004173046091.png)



##### 2.8.2 ç®€å•å®ç°--ä»£ç å®ç°

```java
package com.xk._02Algorithmic._01sort.sort;

import com.xk._02Algorithmic._01sort.tools.Integers;

/**
 * @description: è®¡æ•°æ’åº
 * @author: xu
 * @date: 2022/10/2 10:43
 */
public class CountingSort1 extends Sort<Integer> {
    /**
     * è®¡æ•°æ’åº
     */
    private void countingSort(){
        // æ‰¾å‡ºæœ€å¤§å€¼
        int max = array[0];
        for (int i = 1; i < array.length; i++) {
            if (array[i] > max) max = array[i];
        }
        //å¼€è¾Ÿå†…å­˜ç©ºé—´ï¼Œå­˜å‚¨æ¯ä¸ªæ•´æ•°å‡ºç°çš„æ¬¡æ•°
        int[] counts = new int[max + 1];
        // ç»Ÿè®¡æ¯ä¸ªæ•´æ•°å‡ºç°çš„æ¬¡æ•°
        for (int i = 0; i < array.length; i++) {
            counts[array[i]]++;
        }
        // æ ¹æ®æ•´æ•°çš„å‡ºç°æ¬¡æ•°ï¼Œå¯¹æ•´æ•°è¿›è¡Œæ’åº
        int index = 0;
        for (int i = 0; i < counts.length; i++) {
            while (counts[i]-- > 0){
                array[index++] = i;
            }
        }
    }

    @Override
    protected void sort() {
        countingSort();
    }
}
```

è¿™ä¸ªç‰ˆæœ¬çš„å®ç°å­˜åœ¨ä»¥ä¸‹é—®é¢˜

- æ— æ³•å¯¹**è´Ÿæ•´æ•°**è¿›è¡Œæ’åº
- æå…¶æµªè´¹å†…å­˜ç©ºé—´
- æ˜¯ä¸ª**ä¸ç¨³å®š**çš„æ’åº



##### 2.8.3 æ”¹è¿›--æ€è·¯

æ”¹è¿›æ€è·¯æ˜¯**æ±‚å‡ºæœ€å°å€¼**ã€‚

![image-20221004173722236](02-æ‹ä¸Šæ•°æ®ç»“æ„-ç®—æ³•ç¯‡.assets/image-20221004173722236.png)



##### 2.8.4 æ”¹è¿›--å›¾è§£

æ¯ä¸ªå…ƒç´ ç´¯åŠ ä¸Šå…¶å‰é¢çš„æ‰€æœ‰å…ƒç´ å¾—åˆ°çš„å°±æ˜¯å…ƒç´ åœ¨æœ‰åºåºåˆ—ä¸­çš„ä½ç½®ä¿¡æ¯ã€‚

ä¾‹å¦‚å¯¹ { 7, 3, 5, 8, 6, 7, 4, 5 } è¿›è¡Œæ”¹è¿›è¿‡çš„è®¡æ•°æ’åºï¼šmin = 3ï¼Œmax = 8

newArray ä¸º**æ–°å¼€è¾Ÿçš„æ•°ç»„**ï¼ŒnewArray = [0, 0, 0, 0, 0, 0, 0, 0]ï¼Œç”¨æ¥**å­˜æ”¾æ’åºç»“æœ**ã€‚

- counts = [1, 2, 4, 5, 7, 8]ï¼›

  å…ƒç´  5 åœ¨æœ‰åºåºåˆ—ä¸­çš„çš„ç´¢å¼•ï¼š`counts[5-3] - 1 = counts[2] - 1 = 3`

  newArray[3] = 5; æ­¤æ—¶ newArray = [0, 0, 0, 5, 0, 0, 0, 0]

  counts[2]--;

  ![image-20221004174215023](02-æ‹ä¸Šæ•°æ®ç»“æ„-ç®—æ³•ç¯‡.assets/image-20221004174215023.png)

- counts = [1, 2, 3, 5, 7, 8]ï¼›

  å…ƒç´  4 åœ¨æœ‰åºåºåˆ—ä¸­çš„çš„ç´¢å¼•ï¼š`counts[4-3] - 1 = counts[1] - 1 = 1`

  newArray[1] = 4; æ­¤æ—¶ newArray = [0, 4, 0, 5, 0, 0, 0, 0]

  counts[1]--;

- counts = [1, 1, 3, 5, 7, 8]ï¼›

  å…ƒç´  7 åœ¨æœ‰åºåºåˆ—ä¸­çš„çš„ç´¢å¼•ï¼š`counts[7-3] - 1 = counts[4] - 1 = 6`

  newArray[6] = 7; æ­¤æ—¶ newArray = [0, 4, 0, 5, 0, 0, 7, 0]

  counts[4]--;

  ![image-20221004174637250](02-æ‹ä¸Šæ•°æ®ç»“æ„-ç®—æ³•ç¯‡.assets/image-20221004174637250.png)

- counts = [1, 1, 3, 5, 6, 8]ï¼›

  å…ƒç´  6 åœ¨æœ‰åºåºåˆ—ä¸­çš„çš„ç´¢å¼•ï¼š`counts[6-3] - 1 = counts[3] - 1 = 4`

  newArray[4] = 6; æ­¤æ—¶ newArray = [0, 4, 0, 5, 6, 0, 7, 0]

  counts[3]--;

- counts = [1, 1, 3, 4, 6, 8]ï¼›

  å…ƒç´  8 åœ¨æœ‰åºåºåˆ—ä¸­çš„çš„ç´¢å¼•ï¼š`counts[8-3] - 1 = counts[5] - 1 = 7`

  newArray[7] = 8; æ­¤æ—¶ newArray = [0, 4, 0, 5, 6, 0, 7, 8]

  counts[5]--;

  ![image-20221004175011488](02-æ‹ä¸Šæ•°æ®ç»“æ„-ç®—æ³•ç¯‡.assets/image-20221004175011488.png)

- counts = [1, 1, 3, 4, 6, 7]ï¼›

  å…ƒç´  5 åœ¨æœ‰åºåºåˆ—ä¸­çš„çš„ç´¢å¼•ï¼š`counts[5-3] - 1 = counts[2] - 1 = 2`

  newArray[2] = 5; æ­¤æ—¶ newArray = [0, 4, 5, 5, 6, 0, 7, 8]

  counts[2]--;

- counts = [1, 1, 2, 4, 6, 7]ï¼›

  å…ƒç´  3 åœ¨æœ‰åºåºåˆ—ä¸­çš„çš„ç´¢å¼•ï¼š`counts[3-3] - 1 = counts[0] - 1 = 0`

  newArray[0] = 3; æ­¤æ—¶ newArray = [3, 4, 5, 5, 6, 0, 7, 8]

  counts[0]--;

  ![image-20221004175304523](02-æ‹ä¸Šæ•°æ®ç»“æ„-ç®—æ³•ç¯‡.assets/image-20221004175304523.png)

- counts = [0, 1, 2, 4 ,6, 7]ï¼›

  å…ƒç´  7 åœ¨æœ‰åºåºåˆ—ä¸­çš„çš„ç´¢å¼•ï¼š`counts[7-3] - 1 = counts[4] - 1 = 5`

  newArray[5] = 8; æ­¤æ—¶ newArray = [3, 4, 5, 5, 6, 7, 7, 8]

  counts[5]--;

  ![image-20221004175447623](02-æ‹ä¸Šæ•°æ®ç»“æ„-ç®—æ³•ç¯‡.assets/image-20221004175447623.png)



##### 2.8.5 æ”¹è¿›--ä»£ç å®ç°

```java
package com.xk._02Algorithmic._01sort.sort;

/**
 * @description: è®¡æ•°æ’åº
 * @author: xu
 * @date: 2022/10/2 10:43
 */
public class CountingSort2 extends Sort<Integer> {

    /**
     * è®¡æ•°æ’åº
     */
    private void countingSort(){
        // æ‰¾å‡ºæœ€å¤§å€¼ã€æœ€å°å€¼
        int max = array[0];
        int min = array[0];
        for (int i = 1; i < array.length; i++) {
            if (array[i] > max) max = array[i];
            if (array[i] < min) min = array[i];
        }
        //å¼€è¾Ÿå†…å­˜ç©ºé—´ï¼Œå­˜å‚¨æ¬¡æ•°
        int[] counts = new int[max - min + 1];
        // ç»Ÿè®¡æ¯ä¸ªæ•´æ•°å‡ºç°çš„æ¬¡æ•°
        for (int i = 0; i < array.length; i++) {
            counts[array[i] - min]++;
        }
        // ç´¯åŠ æ¬¡æ•°
        for (int i = 1; i < counts.length; i++) {
            counts[i] += counts[i - 1];
        }
        // ä»åå¾€å‰éå†å…ƒç´ ï¼Œå°†å®ƒæ”¾åˆ°æœ‰åºæ•°ç»„ä¸­çš„åˆé€‚ä½ç½®
        Integer[] newArray = new Integer[array.length];
        for (int i = array.length - 1; i >= 0; i--) {
            int index = --counts[array[i] - min];
            newArray[index] = array[i];
        }
        // å°†æœ‰åºæ•°ç»„èµ‹å€¼åˆ°array
        for (int i = 0; i < newArray.length; i++) {
            array[i] = newArray[i];
        }
    }

    @Override
    protected void sort() {
        countingSort();
    }
}
```



##### 2.8.6 å¤æ‚åº¦ä¸ç¨³å®šæ€§

- **æœ€å¥½ã€æœ€åã€å¹³å‡æ—¶é—´**å¤æ‚åº¦ï¼šO(n + k)
- ç©ºé—´å¤æ‚åº¦ï¼šO(n + k)
- k æ˜¯æ•´æ•°çš„å–å€¼èŒƒå›´
- è®¡æ•°æ’åºå±äº**ç¨³å®šæ’åº**



##### 2.8.7 å¯¹è‡ªå®šä¹‰å¯¹è±¡è¿›è¡Œè®¡æ•°æ’åº

å¦‚æœè‡ªå®šä¹‰å¯¹è±¡å¯ä»¥æä¾›ç”¨ä»¥æ’åºçš„æ•´æ•°ç±»å‹ï¼Œä¾ç„¶å¯ä»¥ä½¿ç”¨è®¡æ•°æ’åº

```java
private static class Person {
	int age;
	String name;
	Person(int age, String name) {
		this.age = age;
		this.name = name;
	}
	@Override
	public String toString() {
		return "Person [age=" + age 
				+ ", name=" + name + "]";
	}
}
```

```java
public static void main(String[] args) {
    Person[] persons = new Person[] {
            new Person(20, "A"),
            new Person(-13, "B"),
            new Person(17, "C"),
            new Person(12, "D"),
            new Person(-13, "E"),
            new Person(20, "F")
    };

    // æ‰¾å‡ºæœ€å€¼
    int max = persons[0].age;
    int min = persons[0].age;
    for (int i = 1; i < persons.length; i++) {
        if (persons[i].age > max) {
            max = persons[i].age;
        }
        if (persons[i].age < min) {
            min = persons[i].age;
        }
    }

    // å¼€è¾Ÿå†…å­˜ç©ºé—´ï¼Œå­˜å‚¨æ¬¡æ•°
    int[] counts = new int[max - min + 1];
    // ç»Ÿè®¡æ¯ä¸ªæ•´æ•°å‡ºç°çš„æ¬¡æ•°
    for (int i = 0; i < persons.length; i++) {
        counts[persons[i].age - min]++;
    }
    // ç´¯åŠ æ¬¡æ•°
    for (int i = 1; i < counts.length; i++) {
        counts[i] += counts[i - 1];
    }

    // ä»åå¾€å‰éå†å…ƒç´ ï¼Œå°†å®ƒæ”¾åˆ°æœ‰åºæ•°ç»„ä¸­çš„åˆé€‚ä½ç½®
    Person[] newArray = new Person[persons.length];
    for (int i = persons.length - 1; i >= 0; i--) {
        newArray[--counts[persons[i].age - min]] = persons[i];
    }

    // å°†æœ‰åºæ•°ç»„èµ‹å€¼åˆ°array
    for (int i = 0; i < newArray.length; i++) {
        persons[i] = newArray[i];
    }

    for (int i = 0; i < persons.length; i++) {
        System.out.println(persons[i]);
    }
}
/*
è¾“å‡ºï¼š
Person [age=-13, name=B]
Person [age=-13, name=E]
Person [age=12, name=D]
Person [age=17, name=C]
Person [age=20, name=A]
Person [age=20, name=F]
*/
```



#### 2.9 åŸºæ•°æ’åº

åŸºæ•°æ’åºéå¸¸é€‚åˆç”¨äºæ•´æ•°æ’åºï¼ˆå°¤å…¶æ˜¯**éè´Ÿæ•´æ•°**ï¼‰ï¼Œè¿™é‡Œåªä»‹ç»å¯¹éè´Ÿæ•´æ•°è¿›è¡ŒåŸºæ•°æ’åºã€‚

æ‰§è¡Œæµç¨‹ï¼šä¾æ¬¡å¯¹**ä¸ªä½æ•°ã€åä½æ•°ã€ç™¾ä½æ•°ã€åƒä½æ•°ã€ä¸‡ä½æ•°**â€¦è¿›è¡Œæ’åºï¼ˆä»ä½ä½åˆ°é«˜ä½ï¼‰

![image-20221004181021976](02-æ‹ä¸Šæ•°æ®ç»“æ„-ç®—æ³•ç¯‡.assets/image-20221004181021976.png)



##### 2.9.1 ä»£ç å®ç°

ä¸ªä½æ•°ã€åä½æ•°ã€ç™¾ä½æ•°çš„å–å€¼èŒƒå›´éƒ½æ˜¯å›ºå®šçš„0~9ï¼Œå¯ä»¥ä½¿ç”¨`è®¡æ•°æ’åº`å¯¹å®ƒä»¬è¿›è¡Œæ’åºã€‚

```java
package com.xk._02Algorithmic._01sort.sort;

import com.xk._02Algorithmic._01sort.tools.Integers;

/**
 * @description: åŸºæ•°æ’åº
 * @author: xu
 * @date: 2022/10/2 10:43
 */
public class RadixSort extends Sort<Integer> {
    /**
     * åŸºæ•°æ’åº
     */
    private void radixSort(){
        // æ‰¾å‡ºæœ€å¤§å€¼
        int max = array[0];
        for (int i = 1; i < array.length; i++) {
            if (array[i] > max) max = array[i];
        }
        for (int divider = 1; divider <= max; divider *= 10){
            countingSort(divider);
        }
    }

    /**
     * è®¡æ•°æ’åº
     */
    private void countingSort(int divider){
        //å¼€è¾Ÿå†…å­˜ç©ºé—´ï¼Œå­˜å‚¨æ¬¡æ•°
        int[] counts = new int[10];
        // ç»Ÿè®¡æ¯ä¸ªä½æ•°å‡ºç°çš„æ¬¡æ•°
        for (int i = 0; i < array.length; i++) {
            counts[array[i] / divider % 10]++;
        }
        // ç´¯åŠ æ¬¡æ•°
        for (int i = 1; i < counts.length; i++) {
            counts[i] += counts[i - 1];
        }
        // ä»åå¾€å‰éå†å…ƒç´ ï¼Œå°†å®ƒæ”¾åˆ°æœ‰åºæ•°ç»„ä¸­çš„åˆé€‚ä½ç½®
        Integer[] newArray = new Integer[array.length];
        for (int i = array.length - 1; i >= 0; i--) {
            int index = --counts[array[i] / divider % 10];
            newArray[index] = array[i];
        }
        // å°†æœ‰åºæ•°ç»„èµ‹å€¼åˆ°array
        for (int i = 0; i < newArray.length; i++) {
            array[i] = newArray[i];
        }
    }

    @Override
    protected void sort() {
        radixSort();
    }
}
```



##### 2.9.2 å¤æ‚åº¦ä¸ç¨³å®šæ€§

- æœ€å¥½ã€æœ€åã€å¹³å‡æ—¶é—´å¤æ‚åº¦ï¼šO(d âˆ— (n + k)) ï¼Œd æ˜¯æœ€å¤§å€¼çš„ä½æ•°ï¼Œk æ˜¯è¿›åˆ¶
- ç©ºé—´å¤æ‚åº¦ï¼šO(n + k)ï¼Œk æ˜¯è¿›åˆ¶
- åŸºæ•°æ’åºå±äº**ç¨³å®šæ’åº**



##### 2.9.3 åŸºæ•°æ’åº--å¦ä¸€ç§æ€è·¯

![image-20221004181841004](02-æ‹ä¸Šæ•°æ®ç»“æ„-ç®—æ³•ç¯‡.assets/image-20221004181841004.png)

*ä»£ç å®ç°*ï¼š

![image-20221004181924474](02-æ‹ä¸Šæ•°æ®ç»“æ„-ç®—æ³•ç¯‡.assets/image-20221004181924474.png)

*å¤æ‚åº¦ä¸ç¨³å®šæ€§*ï¼š

- ç©ºé—´å¤æ‚åº¦æ˜¯ O(kn + k) ï¼Œæ—¶é—´å¤æ‚åº¦æ˜¯ O(dn)
- d æ˜¯æœ€å¤§å€¼çš„ä½æ•°ï¼Œk æ˜¯è¿›åˆ¶



#### 2.10 æ¡¶æ’åº

æ‰§è¡Œæµç¨‹ï¼š

1. åˆ›å»ºä¸€å®šæ•°é‡çš„æ¡¶ï¼ˆæ¯”å¦‚ç”¨æ•°ç»„ã€é“¾è¡¨ä½œä¸ºæ¡¶ï¼‰
2. æŒ‰ç…§ä¸€å®šçš„è§„åˆ™ï¼ˆä¸åŒç±»å‹çš„æ•°æ®ï¼Œè§„åˆ™ä¸åŒï¼‰ï¼Œå°†åºåˆ—ä¸­çš„å…ƒç´ å‡åŒ€åˆ†é…åˆ°å¯¹åº”çš„æ¡¶
3. åˆ†åˆ«å¯¹æ¯ä¸ªæ¡¶è¿›è¡Œå•ç‹¬æ’åº
4. å°†æ‰€æœ‰éç©ºæ¡¶çš„å…ƒç´ åˆå¹¶æˆæœ‰åºåºåˆ—

å…ƒç´ åœ¨æ¡¶ä¸­çš„ç´¢å¼•ï¼š*å…ƒç´ å€¼ \* å…ƒç´ æ•°é‡*

![image-20221004184805255](02-æ‹ä¸Šæ•°æ®ç»“æ„-ç®—æ³•ç¯‡.assets/image-20221004184805255.png)

##### 2.10.1 ä»£ç å®ç°

![image-20221004185045820](02-æ‹ä¸Šæ•°æ®ç»“æ„-ç®—æ³•ç¯‡.assets/image-20221004185045820.png)



##### 2.10.2 å¤æ‚åº¦ä¸ç¨³å®šæ€§

- ç©ºé—´å¤æ‚åº¦ï¼šO(n + m)ï¼Œm æ˜¯æ¡¶çš„æ•°é‡

- æ—¶é—´å¤æ‚åº¦ï¼šO(n) + m âˆ— O(n/m âˆ— log(n/m)) = O(n + n âˆ— log(n/m)) = O(n + n âˆ— logn âˆ’ n âˆ— logm)

  å› æ­¤ä¸º O(n + k)ï¼Œk ä¸º n âˆ— logn âˆ’ n âˆ— logm

- æ¡¶æ’åºå±äº**ç¨³å®šæ’åº**



#### 2.11 'æœ€å¼º'æ’åº--ç¡çœ æ’åº

```java
/**
 * ç¡çœ æ’åº
 */
public class SortThread extends Thread{
	public int value;
	public SortThread(int value) {
		this.value = value;
	}
	public void run(){
		try{
			Thread.sleep(value);
			System.out.println(value);
		}catch (InterruptedException e) {
			e.printStackTrace();
		}
	}
	public static void main(String[] args) {
		int [] array = {10, 100, 50, 30, 60, 61, 64, 47,79, 59};
		for (int i = 0; i < array.length; i++) {
			new SortThread(array[i]).start();
		}
		
	}
}
```

+++

## äºŒã€å¹¶æŸ¥é›†UnionFind

å‡è®¾æœ‰ n ä¸ªæ‘åº„ï¼Œæœ‰äº›æ‘åº„ä¹‹é—´æœ‰è¿æ¥çš„è·¯ï¼Œæœ‰äº›æ‘åº„ä¹‹é—´å¹¶æ²¡æœ‰è¿æ¥çš„è·¯

![image-20221005131822464](02-æ‹ä¸Šæ•°æ®ç»“æ„-ç®—æ³•ç¯‡.assets/image-20221005131822464.png)

è®¾è®¡ä¸€ä¸ªæ•°æ®ç»“æ„ï¼Œèƒ½å¤Ÿå¿«é€Ÿæ‰§è¡Œ 2 ä¸ªæ“ä½œï¼š

- æŸ¥è¯¢ 2 ä¸ªæ‘åº„ä¹‹é—´æ˜¯å¦æœ‰è¿æ¥çš„è·¯
- è¿æ¥ 2 ä¸ªæ‘åº„

å¦‚æœä½¿ç”¨**æ•°ç»„ã€é“¾è¡¨ã€å¹³è¡¡äºŒå‰æ ‘ã€é›†åˆ(Set)**éƒ½å¯ä»¥å®Œæˆéœ€æ±‚ï¼Œä½†æ˜¯æŸ¥è¯¢ã€è¿æ¥çš„æ—¶é—´å¤æ‚åº¦éƒ½æ˜¯ O(n)ã€‚

**å¹¶æŸ¥é›†**èƒ½åšåˆ°æŸ¥è¯¢ã€è¿æ¥çš„å‡æ‘Šæ—¶é—´å¤æ‚åº¦éƒ½æ˜¯ O(Î±(n))ï¼ŒÎ±(n) < 5ï¼Œéå¸¸é€‚åˆè§£å†³è¿™ç±»â€œè¿æ¥â€ç›¸å…³çš„é—®é¢˜ã€‚



### 1 å¹¶æŸ¥é›†UnionFind

å¹¶æŸ¥é›†ä¹Ÿå«ä½œ**ä¸ç›¸äº¤é›†åˆ**ï¼ˆDisjoint Setï¼‰

å¹¶æŸ¥é›†æœ‰2ä¸ªæ ¸å¿ƒæ“ä½œ:

- æŸ¥æ‰¾ï¼ˆFindï¼‰ï¼šæŸ¥æ‰¾å…ƒç´ æ‰€åœ¨çš„é›†åˆ
  (è¿™é‡Œçš„é›†åˆå¹¶ä¸æ˜¯ç‰¹æŒ‡Setè¿™ç§æ•°æ®ç»“æ„ï¼Œæ˜¯æŒ‡**å¹¿ä¹‰çš„æ•°æ®é›†åˆ**)
- åˆå¹¶ï¼ˆUnionï¼‰ï¼šå°†ä¸¤ä¸ªå…ƒç´ æ‰€åœ¨çš„é›†åˆåˆå¹¶ä¸ºä¸€ä¸ªé›†åˆ

æœ‰ 2 ç§å¸¸è§çš„å®ç°æ€è·¯ï¼š

1. Quick Find
   - æŸ¥æ‰¾ï¼ˆFindï¼‰çš„æ—¶é—´å¤æ‚åº¦ï¼šO(1)
   - åˆå¹¶ï¼ˆUnionï¼‰çš„æ—¶é—´å¤æ‚åº¦ï¼šO(n)
2. Quick Union
   - æŸ¥æ‰¾ï¼ˆFindï¼‰çš„æ—¶é—´å¤æ‚åº¦ï¼šO(logn), å¯ä»¥ä¼˜åŒ–è‡³ O(ğ›¼(ğ‘›)), Î±(ğ‘›) < 5
   - åˆå¹¶ï¼ˆUnionï¼‰çš„æ—¶é—´å¤æ‚åº¦ï¼šO(logn), å¯ä»¥ä¼˜åŒ–è‡³ O(ğ›¼(ğ‘›)), Î±(ğ‘›) < 5



#### 1.1 å¦‚ä½•å­˜å‚¨æ•°æ®

å‡è®¾å¹¶æŸ¥é›†å¤„ç†çš„æ•°æ®éƒ½æ˜¯æ•´å‹ï¼Œé‚£ä¹ˆå¯ä»¥ç”¨æ•´å‹æ•°ç»„æ¥å­˜å‚¨æ•°æ®ã€‚

- **æ•°ç»„ç´¢å¼•ä»£è¡¨å…ƒç´ å€¼**
- **ç´¢å¼•å¯¹åº”çš„å€¼ä»£è¡¨è¿™ä¸ªå…ƒç´ çš„çˆ¶èŠ‚ç‚¹**

![image-20221005132431161](02-æ‹ä¸Šæ•°æ®ç»“æ„-ç®—æ³•ç¯‡.assets/image-20221005132431161.png)

å› æ­¤ï¼Œå¹¶æŸ¥é›†æ˜¯**å¯ä»¥ç”¨æ•°ç»„å®ç°çš„æ ‘å½¢ç»“æ„**ï¼ˆäºŒå‰å †ã€ä¼˜å…ˆçº§é˜Ÿåˆ—ä¹Ÿæ˜¯å¯ä»¥ç”¨æ•°ç»„å®ç°çš„æ ‘å½¢ç»“æ„ï¼‰



#### 1.2 æ¥å£å®šä¹‰

```java
/**
 * æŸ¥æ‰¾væ‰€å±çš„é›†åˆ(æ ¹ç»“ç‚¹)
 */
public abstract int find(int v);

/**
 * åˆå¹¶v1ã€v2æ‰€åœ¨çš„é›†åˆ
 */
public abstract void union(int v1, int v2);

/**
 * æ£€æŸ¥v1ã€v2æ˜¯å¦å±äºåŒä¸€é›†åˆ
 */
public boolean isSame(int v1, int v2);
```

`isSame()` çš„å®ç°ååˆ†ç®€å•ï¼š

```java
public boolean isSame(int v1, int v2){
	return find(v1) == find(v2);
}
```



#### 1.3 å…ƒç´ çš„åˆå§‹åŒ–

åˆå§‹åŒ–æ—¶ï¼Œæ¯ä¸ªå…ƒç´ å„è‡ªå±äºä¸€ä¸ª**å•å…ƒç´ é›†åˆ**

![image-20221005132721431](02-æ‹ä¸Šæ•°æ®ç»“æ„-ç®—æ³•ç¯‡.assets/image-20221005132721431.png)

```java
public abstract class UnionFind {
    protected int[] parents;

    public UnionFind(int capacity) {
        if (capacity <= 0) {
            throw new IllegalArgumentException("capacity must be >= 1");
        }
        parents = new int[capacity];
        for (int i = 0; i < parents.length; i++) {
            parents[i] = i;
        }
    }
}
```



#### 1.4 UnionFind.java

è¿™æ˜¯ä¸ªå¹¶æŸ¥é›†çš„æŠ½è±¡ç±»ï¼Œåé¢çš„æ‰€æœ‰å¹¶æŸ¥é›†éƒ½å°†ç»§æ‰¿å®ƒã€‚

```java
/**
 * @description:
 * @author: xu
 * @date: 2022/10/4 20:10
 */
public abstract class UnionFind {
    protected int[] parents;

    public UnionFind(int capacity) {
        if (capacity <= 0) {
            throw new IllegalArgumentException("capacity must be >= 1");
        }
        parents = new int[capacity];
        for (int i = 0; i < parents.length; i++) {
            parents[i] = i;
        }
    }

    /**
     * æŸ¥æ‰¾væ‰€å±çš„é›†åˆï¼ˆæ ¹èŠ‚ç‚¹ï¼‰
     * @param v
     * @return
     */
    public abstract int find(int v);

    /**
     * åˆå¹¶v1ã€v2æ‰€åœ¨çš„é›†åˆ
     * @param v1
     * @param v2
     */
    public abstract void union(int v1, int v2);

    /**
     * æ£€æŸ¥v1ã€v2æ˜¯å¦å±äºåŒä¸€ä¸ªé›†åˆ
     * @param v1
     * @param v2
     * @return
     */
    public boolean isSame(int v1, int v2) {
        return find(v1) == find(v2);
    }

    /**
     * è¾¹ç•Œæ£€æŸ¥: æ£€æŸ¥ä¼ å…¥å€¼çš„åˆæ³•æ€§
     * @param v
     */
    protected void rangeCheck(int v) {
        if (v < 0 || v >= parents.length)
            throw new IndexOutOfBoundsException("v is out of bounds");
    }
}
```



### 2 Quick Find

Quick Findçš„ `union(v1, v2)`ï¼šè®©**v1 æ‰€åœ¨é›†åˆçš„æ‰€æœ‰å…ƒç´ **éƒ½æŒ‡å‘**v2 çš„çˆ¶èŠ‚ç‚¹**ã€‚

å¹¶ä¸” Quick Find çš„é«˜åº¦æ°¸è¿œä¿æŒ <= 2ã€‚



#### 2.1 findå®ç°

Quick FindæŸ¥æ‰¾çš„æ—¶å€™ï¼Œç”±äºæ•°ç»„ä¸­å­˜å‚¨çš„å°±æ˜¯æ ¹ç»“ç‚¹ï¼Œå› æ­¤ç›´æ¥å–å‡ºå³å¯ã€‚

![image-20221005134544652](02-æ‹ä¸Šæ•°æ®ç»“æ„-ç®—æ³•ç¯‡.assets/image-20221005134544652.png)

```java
å¯¹ä¸Šå›¾æ‰§è¡Œ find():
find(0) == 2
find(1) == 2
find(2) == 2
find(3) == 4
```

```java
/**
 * çˆ¶èŠ‚ç‚¹å°±æ˜¯æ ¹èŠ‚ç‚¹
 */
@Override
public int find(int v){
	rangeCheck(v);
	return parents[v];
}
```

Quick Find çš„ find(V v) æ—¶é—´å¤æ‚åº¦ï¼š**O(1)**



#### 2.2 unionç¤ºä¾‹åŠå®ç°

ä¾‹å¦‚ï¼š

å°†ï½›0ï¼Œ1ï¼Œ2ï¼Œ3ï¼Œ4ï¼Œ5ï½åˆå§‹åŒ–ä¸ºå¹¶æŸ¥é›†ï¼Œæ¯ä¸ªå…ƒç´ å„è‡ªå±äºä¸€ä¸ªå•å…ƒç´ é›†åˆï¼š{0}, {1}, {2}, {3}, {4}ã€‚

![image-20221005133244534](02-æ‹ä¸Šæ•°æ®ç»“æ„-ç®—æ³•ç¯‡.assets/image-20221005133244534.png)

åˆå¹¶ 1 å’Œ 0ï¼Œ`union(1, 0)`ï¼Œå³ {1} æŒ‡å‘äº† {0} ã€‚

![image-20221005133332652](02-æ‹ä¸Šæ•°æ®ç»“æ„-ç®—æ³•ç¯‡.assets/image-20221005133332652.png)

ç„¶åï¼Œåˆå¹¶ 1 å’Œ 2ï¼Œ`union(1, 2)`ï¼Œ1 æ‰€åœ¨é›†åˆæœ‰{0, 1}ï¼Œå³ {0, 1} æŒ‡å‘äº† {2}ã€‚

![image-20221005133536201](02-æ‹ä¸Šæ•°æ®ç»“æ„-ç®—æ³•ç¯‡.assets/image-20221005133536201.png)

å†åˆå¹¶ 3 å’Œ 4ï¼Œ`union(3, 4)`ï¼Œå³ {3} æŒ‡å‘äº† {4} ã€‚

![image-20221005133623292](02-æ‹ä¸Šæ•°æ®ç»“æ„-ç®—æ³•ç¯‡.assets/image-20221005133623292.png)

åˆå¹¶ 0 å’Œ 3ï¼Œ`union(0, 3)`ï¼Œ0 æ‰€åœ¨é›†åˆä¸º {0, 1, 2}ï¼Œ3 æ‰€åœ¨é›†åˆä¸º {3,4}ï¼Œå¦‚ä¸‹ï¼š

![image-20221005133814096](02-æ‹ä¸Šæ•°æ®ç»“æ„-ç®—æ³•ç¯‡.assets/image-20221005133814096.png)

```java
/**
 * å°†v1æ‰€åœ¨é›†åˆçš„æ‰€æœ‰å…ƒç´ éƒ½å«æ¥åˆ°v2çš„çˆ¶èŠ‚ç‚¹ä¸Š
 * v1    v2   union(v1,v2)
 *  0    4	     4
 * 1 2   3     0 1 2 3
 */
@Override
public void union(int v1, int v2) {
    int p1 = find(v1);
    int p2 = find(v2);
    if (p1 == p2) return;

    for (int i = 0; i < parents.length; i++) {
        if (parents[i] == p1) {
            parents[i] = p2;
        }
    }
}
```

Quick Find çš„ union(V v1, V v2) æ—¶é—´å¤æ‚åº¦ï¼š**O(n)**



#### 2.3 QuickFindå®Œæ•´ä»£ç 

```java
package com.xk._02Algorithmic._02unionFind.union;

/**
 * @description: Quick Find
 * @author: xu
 * @date: 2022/10/4 20:27
 */
public class UnionFind_QF extends UnionFind{

    public UnionFind_QF(int capacity) {
        super(capacity);
    }

    //O(1)
    // çˆ¶èŠ‚ç‚¹éƒ½æ˜¯æ ¹èŠ‚ç‚¹
    @Override
    public int find(int v){
        rangeCheck(v);
        return parents[v];
    }

    //O(n)
    // å°† v1 æ‰€åœ¨é›†åˆçš„æ‰€æœ‰å…ƒç´ éƒ½å«æ¥åˆ° v2 çš„çˆ¶èŠ‚ç‚¹ä¸Š
    @Override
    public void union(int v1, int v2) {
        int p1 = find(v1);
        int p2 = find(v2);
        if (p1 == p2) return;

        for (int i = 0; i < parents.length; i++) {
            if (parents[i] == p1) {
                parents[i] = p2;
            }
        }
    }

}
```



### 3 Quick Union

> Quick Find çš„ `union(v1, v2)`ï¼šè®©**v1 æ‰€åœ¨é›†åˆçš„æ‰€æœ‰å…ƒç´ (æ ¹èŠ‚ç‚¹ç›¸åŒ)**éƒ½æŒ‡å‘**v2 çš„æ ¹èŠ‚ç‚¹(çˆ¶èŠ‚ç‚¹)**ã€‚

Quick Union çš„ `union(v1, v2)`ï¼šè®©**v1 çš„æ ¹èŠ‚ç‚¹**æŒ‡å‘**v2 çš„æ ¹èŠ‚ç‚¹**ã€‚(ä¸Quick Findè¿›è¡Œå¯¹æ¯”)



#### 3.1 findå®ç°

Quick Unionçš„æŸ¥æ‰¾ï¼Œéœ€è¦é€šè¿‡**çˆ¶èŠ‚ç‚¹**ä¸æ–­å¾€ä¸Šæ‰¾ï¼Œç›´åˆ°æ‰¾åˆ°**æ ¹ç»“ç‚¹**ï¼ˆæŸèŠ‚ç‚¹çš„æ ¹ç»“ç‚¹ä¸ºè‡ªå·±ï¼‰ã€‚

![image-20221005154348043](02-æ‹ä¸Šæ•°æ®ç»“æ„-ç®—æ³•ç¯‡.assets/image-20221005154348043.png)

```java
å¯¹ä¸Šå›¾æ‰§è¡Œ find():
find(0) == 2
find(1) == 2
find(3) == 2
find(4) == 2
```

```java
//O(logn)
// é€šè¿‡parenté“¾æ¡ä¸æ–­åœ°å‘ä¸Šæ‰¾ï¼Œç›´åˆ°æ‰¾åˆ°æ ¹èŠ‚ç‚¹
@Override
public int find(int v){
    rangeCheck(v);
    while (v != parents[v]){
        v = parents[v];
    }
    return v;
}
```

Quick Union çš„ find() æ—¶é—´å¤æ‚åº¦ï¼š**O(logn)**



#### 3.2 unionç¤ºä¾‹åŠå®ç°

å°†ï½›0ï¼Œ1ï¼Œ2ï¼Œ3ï¼Œ4ï¼Œ5ï½åˆå§‹åŒ–ä¸ºå¹¶æŸ¥é›†ï¼Œæ¯ä¸ªå…ƒç´ å„è‡ªå±äºä¸€ä¸ªå•å…ƒç´ é›†åˆã€‚

![image-20221005154824910](02-æ‹ä¸Šæ•°æ®ç»“æ„-ç®—æ³•ç¯‡.assets/image-20221005154824910.png)

`union(1, 0)`ï¼Œ1çš„æ ¹ç»“ç‚¹(è¿˜æ˜¯1) æŒ‡å‘ 0çš„æ ¹ç»“ç‚¹(è¿˜æ˜¯0)ã€‚

![image-20221005154938404](02-æ‹ä¸Šæ•°æ®ç»“æ„-ç®—æ³•ç¯‡.assets/image-20221005154938404.png)

`union(1, 2)`ï¼Œ1çš„æ ¹ç»“ç‚¹(0) æŒ‡å‘ 2çš„æ ¹ç»“ç‚¹(2)ã€‚

![image-20221005155056326](02-æ‹ä¸Šæ•°æ®ç»“æ„-ç®—æ³•ç¯‡.assets/image-20221005155056326.png)

`union(3, 4)`ï¼Œ3çš„æ ¹ç»“ç‚¹(3) æŒ‡å‘ 4çš„æ ¹ç»“ç‚¹(4)ã€‚

![image-20221005155155859](02-æ‹ä¸Šæ•°æ®ç»“æ„-ç®—æ³•ç¯‡.assets/image-20221005155155859.png)

`union(3, 1)`ï¼Œ3çš„æ ¹ç»“ç‚¹(4) æŒ‡å‘ 1çš„æ ¹ç»“ç‚¹(2)ã€‚

![image-20221005155246585](02-æ‹ä¸Šæ•°æ®ç»“æ„-ç®—æ³•ç¯‡.assets/image-20221005155246585.png)

```java
//O(logn)
// å°† v1 çš„æ ¹èŠ‚ç‚¹éƒ½å«æ¥åˆ° v2 çš„æ ¹èŠ‚ç‚¹ä¸Š
@Override
public void union(int v1, int v2) {
    int p1 = find(v1);
    int p2 = find(v2);
    if (p1 == p2) return;

    parents[p1] = p2;
}
```

Quick Union çš„ union() æ—¶é—´å¤æ‚åº¦ï¼š**O(logn)**



#### 3.3 QuickUnionå®Œæ•´å®ç°

```java
package com.xk._02Algorithmic._02unionFind.union;

/**
 * @description: Quick Union
 * @author: xu
 * @date: 2022/10/4 20:27
 */
public class UnionFind_QU extends UnionFind{

    public UnionFind_QU(int capacity) {
        super(capacity);
    }

    //O(logn)
    // é€šè¿‡parenté“¾æ¡ä¸æ–­åœ°å‘ä¸Šæ‰¾ï¼Œç›´åˆ°æ‰¾åˆ°æ ¹èŠ‚ç‚¹
    @Override
    public int find(int v){
        rangeCheck(v);
        while (v != parents[v]){
            v = parents[v];
        }
        return v;
    }

    //O(logn)
    // å°† v1 çš„æ ¹èŠ‚ç‚¹éƒ½å«æ¥åˆ° v2 çš„æ ¹èŠ‚ç‚¹ä¸Š
    @Override
    public void union(int v1, int v2) {
        int p1 = find(v1);
        int p2 = find(v2);
        if (p1 == p2) return;

        parents[p1] = p2;
    }
}
```



### 4 Quick Union--ä¼˜åŒ–

ä¸€èˆ¬ç”¨çš„æ›´å¤šçš„æ˜¯ Quick Unionï¼Œæˆ‘ä»¬ç ”ç©¶ä¸€ä¸‹å®ƒçš„ä¼˜åŒ–æ–¹æ¡ˆã€‚

åœ¨ union çš„è¿‡ç¨‹ä¸­ï¼Œå¯èƒ½ä¼šå‡ºç°**æ ‘ä¸å¹³è¡¡**çš„æƒ…å†µï¼Œç”šè‡³é€€åŒ–æˆé“¾è¡¨ã€‚

![image-20221005155655301](02-æ‹ä¸Šæ•°æ®ç»“æ„-ç®—æ³•ç¯‡.assets/image-20221005155655301.png)

æœ‰ 2 ç§å¸¸è§çš„ä¼˜åŒ–æ–¹æ¡ˆï¼š

- åŸºäº size çš„ä¼˜åŒ–ï¼š*å…ƒç´ å°‘*çš„æ ‘ å«æ¥åˆ° *å…ƒç´ å¤š*çš„æ ‘
- **åŸºäº rank çš„ä¼˜åŒ–**ï¼š*çŸ®*çš„æ ‘ å«æ¥åˆ° *é«˜*çš„æ ‘



#### 4.1 QuickUnion--åŸºäºsizeçš„ä¼˜åŒ–

ä¸æ˜¯å›ºå®šçš„è®©æŸä¸€æ£µæ ‘å«æ¥åˆ°å¦ä¸€æ£µæ ‘ï¼Œ**è®©å…ƒç´ å°‘çš„æ ‘ å«æ¥åˆ° å…ƒç´ å¤šçš„æ ‘**ã€‚

![image-20221005155853243](02-æ‹ä¸Šæ•°æ®ç»“æ„-ç®—æ³•ç¯‡.assets/image-20221005155853243-1664956734622-1.png)

è¯¥ç±»ç»§æ‰¿äº†**UnionFind_QU**ï¼Œè¡¨æ˜å®ƒæ˜¯åœ¨Quick Unionçš„åŸºç¡€ä¸Šä¼˜åŒ–ï¼Œå¹¶ä¸”åªéœ€è¦é‡å†™`uniont(int v1, int v2)`å³å¯ï¼Œ`find(int v)`æ— éœ€åšä»»ä½•å˜åŒ–ã€‚

```java
package com.xk._02Algorithmic._02unionFind.union;

/**
 * @description: Quick Union -- åŸºäº size çš„ä¼˜åŒ–
 * @author: xu
 * @date: 2022/10/4 20:27
 */
public class UnionFind_QU_Size extends UnionFind_QU {
    private int[] sizes;
    public UnionFind_QU_Size(int capacity) {
        super(capacity);
        sizes = new int[capacity];
        for (int i = 0; i < sizes.length; i++) {
            sizes[i] = 1;
        }
    }

    @Override
    public void union(int v1, int v2) {
        int p1 = find(v1);
        int p2 = find(v2);
        if (p1 == p2) return;
        if (sizes[p1] < sizes[p2]) {
            parents[p1] = p2;
            sizes[p2] += sizes[p1];
        } else {
            parents[p2] = p1;
            sizes[p1] += sizes[p2];
        }
    }
}
```



#### 4.2 QuickUnion--åŸºäºrankçš„ä¼˜åŒ–

ä¸Šé¢æ‰€è¯´çš„ï¼ŒåŸºäºsizeçš„ä¼˜åŒ–ï¼Œä¹Ÿå¯èƒ½ä¼šå­˜åœ¨æ ‘ä¸å¹³è¡¡çš„é—®é¢˜ã€‚

![image-20221005160236716](02-æ‹ä¸Šæ•°æ®ç»“æ„-ç®—æ³•ç¯‡.assets/image-20221005160236716.png)

åŸºäºrankçš„ä¼˜åŒ–ï¼Œè®©**çŸ®çš„æ ‘ å«æ¥åˆ° é«˜çš„æ ‘**ã€‚

![image-20221005160306523](02-æ‹ä¸Šæ•°æ®ç»“æ„-ç®—æ³•ç¯‡.assets/image-20221005160306523.png)

è¯¥ç±»ç»§æ‰¿äº†**UnionFind_QU**ï¼Œè¡¨æ˜å®ƒæ˜¯åœ¨Quick Unionçš„åŸºç¡€ä¸Šä¼˜åŒ–ï¼Œå¹¶ä¸”åªéœ€è¦é‡å†™`uniont(int v1, int v2)`å³å¯ï¼Œ`find(int v)`æ— éœ€åšä»»ä½•å˜åŒ–ã€‚

```java
package com.xk._02Algorithmic._02unionFind.union;

/**
 * @description: Quick Union -- åŸºäº rank çš„ä¼˜åŒ–
 * @author: xu
 * @date: 2022/10/4 20:27
 */
public class UnionFind_QU_Rank extends UnionFind_QU {
    private int[] ranks;

    public UnionFind_QU_Rank(int capacity) {
        super(capacity);
        ranks = new int[capacity];
        for (int i = 0; i < ranks.length; i++) {
            ranks[i] = 1;
        }
    }

    @Override
    public void union(int v1, int v2) {
        int p1 = find(v1);
        int p2 = find(v2);
        if (p1 == p2) return;

        if (ranks[p1] < ranks[p2]) {
            parents[p1] = p2;
        } else if (ranks[p1] > ranks[p2]) {
            parents[p2] = p1;
        } else {
            parents[p1] = p2;
            ranks[p2] += 1;
        }
    }
}
```



#### 4.3 è·¯å¾„å‹ç¼©(PathCompression)

è™½ç„¶æœ‰äº†åŸºäº rank çš„ä¼˜åŒ–ï¼Œæ ‘ä¼šç›¸å¯¹å¹³è¡¡ä¸€ç‚¹ï¼Œä½†æ˜¯éšç€ union æ¬¡æ•°çš„å¢å¤šï¼š**æ ‘çš„é«˜åº¦ä¾ç„¶ä¼šè¶Šæ¥è¶Šé«˜**ï¼Œå¯¼è‡´ find æ“ä½œå˜æ…¢ï¼Œå°¤å…¶æ˜¯åº•å±‚èŠ‚ç‚¹ (å› ä¸º find æ˜¯ä¸æ–­å‘ä¸Šæ‰¾åˆ°æ ¹èŠ‚ç‚¹) ã€‚

ä»€ä¹ˆæ˜¯**è·¯å¾„å‹ç¼©**ï¼Ÿ

- åœ¨ find æ—¶ä½¿è·¯å¾„ä¸Šçš„æ‰€æœ‰èŠ‚ç‚¹éƒ½æŒ‡å‘æ ¹èŠ‚ç‚¹ï¼Œä»è€Œé™ä½æ ‘çš„é«˜åº¦ã€‚

å¦‚ä¸‹å›¾ï¼Œ

- `find(1)` ä½¿è·¯å¾„ä¸Šçš„ 1ï¼Œ2 éƒ½æŒ‡å‘äº†æ ¹ç»“ç‚¹ 4ã€‚
- `find(0)` ä½¿è·¯å¾„ä¸Šçš„ 0 æŒ‡å‘äº†æ ¹ç»“ç‚¹ 4ã€‚
- `find(7)` ä½¿è·¯å¾„ä¸Šçš„ 7 æŒ‡å‘äº†æ ¹ç»“ç‚¹ 4ã€‚

![image-20221005160746560](02-æ‹ä¸Šæ•°æ®ç»“æ„-ç®—æ³•ç¯‡.assets/image-20221005160746560.png)

è¯¥ç±»ç»§æ‰¿äº†**UnionFind_QU_Rank**ï¼Œè¡¨æ˜å®ƒæ˜¯åœ¨Quick Unionçš„ rank ä¼˜åŒ–çš„åŸºç¡€ä¸Šï¼Œå†ä¼˜åŒ–ï¼Œå¹¶ä¸”åªéœ€è¦é‡å†™`find(int v)`å³å¯ã€‚

```java
package com.xk._02Algorithmic._02unionFind.union;

/**
 * @description: Quick Union -- åŸºäºrankçš„ä¼˜åŒ– -- è·¯å¾„å‹ç¼©[Path Compression]
 * @author: xu
 * @date: 2022/10/4 20:27
 */
public class UnionFind_QU_R_PC extends UnionFind_QU_Rank{
    public UnionFind_QU_R_PC(int capacity) {
        super(capacity);
    }

    /**
	 * åœ¨findæ—¶ä½¿è·¯å¾„ä¸Šçš„æ‰€æœ‰èŠ‚ç‚¹éƒ½æŒ‡å‘æ ¹èŠ‚ç‚¹ï¼Œä»è€Œé™ä½æ ‘çš„é«˜åº¦
	 */
    @Override
    public int find(int v){
        rangeCheck(v);
        if (parents[v] != v) {
            parents[v] = find(parents[v]);
        }
        return parents[v];
    }
}
```



è·¯å¾„å‹ç¼©ä½¿è·¯å¾„ä¸Šçš„æ‰€æœ‰èŠ‚ç‚¹éƒ½æŒ‡å‘æ ¹èŠ‚ç‚¹ï¼Œæ‰€ä»¥å®ç°æˆæœ¬ç¨é«˜ã€‚

è¿˜æœ‰2ç§æ›´ä¼˜çš„åšæ³•ï¼Œä¸ä½†èƒ½é™ä½æ ‘é«˜ï¼Œå®ç°æˆæœ¬ä¹Ÿæ¯”è·¯å¾„å‹ç¼©ä½ï¼š

- **è·¯å¾„åˆ†è£‚**ï¼ˆPath Splitingï¼‰
- **è·¯å¾„å‡åŠ**ï¼ˆPath Halvingï¼‰

**è·¯å¾„åˆ†è£‚ã€è·¯å¾„å‡åŠ**çš„æ•ˆç‡å·®ä¸å¤šï¼Œä½†éƒ½æ¯”è·¯å¾„å‹ç¼©è¦å¥½ã€‚



#### 4.4 è·¯å¾„åˆ†è£‚(PathSpliting)

è·¯å¾„åˆ†è£‚ï¼š**ä½¿è·¯å¾„ä¸Šçš„æ¯ä¸ªèŠ‚ç‚¹éƒ½æŒ‡å‘å…¶ç¥–çˆ¶èŠ‚ç‚¹**ï¼ˆparentçš„parentï¼‰ã€‚

![image-20221005161320866](02-æ‹ä¸Šæ•°æ®ç»“æ„-ç®—æ³•ç¯‡.assets/image-20221005161320866.png)

è¯¥ç±»ç»§æ‰¿äº†**UnionFind_QU_Rank**ï¼Œè¡¨æ˜å®ƒæ˜¯åœ¨Quick Unionçš„ rank ä¼˜åŒ–çš„åŸºç¡€ä¸Šï¼Œå†ä¼˜åŒ–ï¼Œå¹¶ä¸”åªéœ€è¦é‡å†™`find(int v)`å³å¯ã€‚

```java
package com.xk._02Algorithmic._02unionFind.union;

/**
 * @description: Quick Union -- åŸºäºrankçš„ä¼˜åŒ– -- è·¯å¾„åˆ†è£‚[Path Spliting]
 * @author: xu
 * @date: 2022/10/4 20:27
 */
public class UnionFind_QU_R_PS extends UnionFind_QU_Rank{

    public UnionFind_QU_R_PS(int capacity) {
        super(capacity);
    }

    @Override
    public int find(int v){
        rangeCheck(v);
        while (v != parents[v]){
            int p = parents[v];
            parents[v] = parents[parents[v]];
            v = p;
        }
        return v;
    }
}
```



#### 4.5 è·¯å¾„å‡åŠ(PathHalving)

è·¯å¾„å‡åŠï¼š**ä½¿è·¯å¾„ä¸Šæ¯éš”ä¸€ä¸ªèŠ‚ç‚¹å°±æŒ‡å‘å…¶ç¥–çˆ¶èŠ‚ç‚¹**ï¼ˆparentçš„parentï¼‰ã€‚

![image-20221005161636323](02-æ‹ä¸Šæ•°æ®ç»“æ„-ç®—æ³•ç¯‡.assets/image-20221005161636323.png)

è¯¥ç±»ç»§æ‰¿äº†**UnionFind_QU_Rank**ï¼Œè¡¨æ˜å®ƒæ˜¯åœ¨Quick Unionçš„ rank ä¼˜åŒ–çš„åŸºç¡€ä¸Šï¼Œå†ä¼˜åŒ–ï¼Œå¹¶ä¸”åªéœ€è¦é‡å†™`find(int v)`å³å¯ã€‚

```java
package com.xk._02Algorithmic._02unionFind.union;

/**
 * @description: Quick Union -- åŸºäºrankçš„ä¼˜åŒ– -- è·¯å¾„å‡åŠ[Path Halving]
 * @author: xu
 * @date: 2022/10/4 20:27
 */
public class UnionFind_QU_R_PH extends UnionFind_QU_Rank{

    public UnionFind_QU_R_PH(int capacity) {
        super(capacity);
    }

    @Override
    public int find(int v){
        rangeCheck(v);
        while (v != parents[v]){
            parents[v] = parents[parents[v]];
            v = parents[v];
        }
        return v;
    }
}
```



#### 4.6 å°ç»“

ä½¿ç”¨**è·¯å¾„å‹ç¼©**ã€**åˆ†è£‚**æˆ–**å‡åŠ** + åŸºäºrankæˆ–è€…sizeçš„ä¼˜åŒ–å¯ä»¥ç¡®ä¿æ¯ä¸ªæ“ä½œçš„å‡æ‘Šæ—¶é—´å¤æ‚åº¦ä¸º O(ğ›¼(ğ‘›)) ï¼ŒÎ±(ğ‘›) < 5ã€‚

å»ºè®®æ­é…ï¼š

- Quick Union
- åŸºäº rank çš„ä¼˜åŒ–
- Path Halving æˆ– Path Spiliting



### 5 æ—¶é—´æµ‹è¯•

```java
private static final int COUNT = 500_0000;

public static void main(String[] args) {
     // testTime(new UnionFind_QF(COUNT)); // å¤ªæ…¢,ä¸æµ‹
     // testTime(new UnionFind_QU(COUNT)); // å¤ªæ…¢,ä¸æµ‹
     testTime(new UnionFind_QU_Size(COUNT)); // Quick Union åŸºäºsizeçš„ä¼˜åŒ–
     testTime(new UnionFind_QU_Rank(COUNT)); // Quick Union åŸºäºrankçš„ä¼˜åŒ–
     testTime(new UnionFind_QU_R_PC(COUNT)); // Quick Union åŸºäºrankçš„ä¼˜åŒ– è·¯å¾„å‹ç¼©
     testTime(new UnionFind_QU_R_PS(COUNT)); // Quick Union åŸºäºrankçš„ä¼˜åŒ– è·¯å¾„åˆ†è£‚
     testTime(new UnionFind_QU_R_PH(COUNT)); // Quick Union åŸºäºrankçš„ä¼˜åŒ– è·¯å¾„å‡åŠ
}

static void testTime(UnionFind uf) {
    Times.test(uf.getClass().getSimpleName(), new Times.Task() {
        @Override
        public void execute() {
            for (int i = 0; i < COUNT; i++) {
                uf.union((int) (Math.random() * COUNT), (int) (Math.random() * COUNT));
            }
            for (int i = 0; i < COUNT; i++) {
                uf.isSame((int) (Math.random() * COUNT), (int) (Math.random() * COUNT));
            }
        }
    });
}
```

```
ã€UnionFind_QU_Sizeã€‘
å¼€å§‹ï¼š16:23:23.595
ç»“æŸï¼š16:23:25.848
è€—æ—¶ï¼š2.252ç§’
--------------------------------------------------------------------------
ã€UnionFind_QU_Rankã€‘
å¼€å§‹ï¼š16:23:25.878
ç»“æŸï¼š16:23:27.864
è€—æ—¶ï¼š1.986ç§’
--------------------------------------------------------------------------
ã€UnionFind_QU_R_PCã€‘
å¼€å§‹ï¼š16:23:27.873
ç»“æŸï¼š16:23:29.652
è€—æ—¶ï¼š1.779ç§’
--------------------------------------------------------------------------
ã€UnionFind_QU_R_PSã€‘
å¼€å§‹ï¼š16:23:29.658
ç»“æŸï¼š16:23:31.319
è€—æ—¶ï¼š1.661ç§’
--------------------------------------------------------------------------
ã€UnionFind_QU_R_PHã€‘
å¼€å§‹ï¼š16:23:31.339
ç»“æŸï¼š16:23:32.987
è€—æ—¶ï¼š1.648ç§’
--------------------------------------------------------------------------
```



### 6 è‡ªå®šä¹‰ç±»å‹ä½¿ç”¨å¹¶æŸ¥é›†

- æ–¹æ¡ˆä¸€ï¼šé€šè¿‡ä¸€äº›æ–¹æ³•å°†è‡ªå®šä¹‰ç±»å‹è½¬ä¸ºæ•´å‹åä½¿ç”¨å¹¶æŸ¥é›†ï¼ˆæ¯”å¦‚ç”Ÿæˆå“ˆå¸Œå€¼ï¼‰
- æ–¹æ¡ˆäºŒï¼šä½¿ç”¨**é“¾è¡¨+æ˜ å°„**ï¼ˆMapï¼‰

è¿™é‡Œé‡‡ç”¨æ–¹æ¡ˆäºŒå®ç°ï¼š

```java
package com.xk._02Algorithmic._02unionFind.union;

import com.xk._02Algorithmic._02unionFind.Student;
import com.xk._02Algorithmic._02unionFind.tools.Asserts;

import java.util.HashMap;
import java.util.Map;
import java.util.Objects;

/**
 * @description: Quick Union + åŸºäº rank çš„ä¼˜åŒ– + Path Halving
 * @author: xu
 * @date: 2022/10/5 12:36
 */
public class GenericUnionFind<V> {
    private Map<V, Node<V>> nodes = new HashMap<>();
    
    public GenericUnionFind() {}
    public GenericUnionFind(Collection<V> elements) {
        if (elements.size() < 1) return;
        for (V v : elements) {
            if (nodes.containsKey(v)) continue;
            nodes.put(v, new Node<>(v));
        }
    }
    public GenericUnionFind(V[] elements) {
        if (elements.length < 1) return;
        for (V v : elements) {
            if (nodes.containsKey(v)) continue;
            nodes.put(v, new Node<>(v));
        }
    }

    private static class Node<V> {
        V value;
        Node<V> parent = this;
        int rank = 1;
        Node(V value) {
            this.value = value;
        }
    }

    public void makeSet(V v) {
        if (nodes.containsKey(v)) return;
        nodes.put(v, new Node<>(v));
    }

    public V find(V v) {
        Node<V> node = findNode(v);
        return node == null ? null : node.value;
    }

    public void union(V v1, V v2) {
        Node<V> p1 = findNode(v1);
        Node<V> p2 = findNode(v2);
        if (p1 == null || p2 == null) return;
        if (Objects.equals(p1.value, p2.value)) return;
        if (p1.rank < p2.rank) {
            p1.parent = p2;
        } else if (p1.rank > p2.rank) {
            p2.parent = p1;
        } else {
            p1.parent = p2;
            p2.rank += 1;
        }
    }

    public boolean isSame(V v1, V v2) {
        return Objects.equals(find(v1), find(v2));
    }

    /**
     * æ‰¾åˆ°vçš„æ ¹èŠ‚ç‚¹
     * @param v
     * @return
     */
    private Node<V> findNode(V v) {
        Node<V> node = nodes.get(v);
        if (node == null) return null;
        while (!Objects.equals(node.value, node.parent.value)) {
            node.parent = node.parent.parent;
            node = node.parent;
        }
        return node;
    }
}
```

æ—¶é—´æµ‹è¯•ï¼š

```java
private static final int COUNT = 500_0000;

public static void main(String[] args) {
     testTime(new UnionFind_QU_Size(COUNT));
     testTime(new UnionFind_QU_Rank(COUNT));
     testTime(new UnionFind_QU_R_PC(COUNT));
     testTime(new UnionFind_QU_R_PS(COUNT));
     testTime(new UnionFind_QU_R_PH(COUNT));
     testTime(new GenericUnionFind<Integer>()); // è‡ªå®šä¹‰ç±»å‹
}

static void testTime(UnionFind uf) {
    Times.test(uf.getClass().getSimpleName(), new Times.Task() {
        @Override
        public void execute() {
            for (int i = 0; i < COUNT; i++) {
                uf.union((int) (Math.random() * COUNT), (int) (Math.random() * COUNT));
            }
            for (int i = 0; i < COUNT; i++) {
                uf.isSame((int) (Math.random() * COUNT), (int) (Math.random() * COUNT));
            }
        }
    });
}

static void testTime(GenericUnionFind<Integer> uf) {
    for (int i = 0; i < COUNT; i++) {
        uf.makeSet(i);
    }

    Times.test(uf.getClass().getSimpleName(), new Times.Task() {
        @Override
        public void execute() {
            for (int i = 0; i < COUNT; i++) {
                uf.union((int) (Math.random() * COUNT), (int) (Math.random() * COUNT));
            }
            for (int i = 0; i < COUNT; i++) {
                uf.isSame((int) (Math.random() * COUNT), (int) (Math.random() * COUNT));
            }
        }
    });
}
```

```
ã€UnionFind_QU_Sizeã€‘
å¼€å§‹ï¼š16:32:41.419
ç»“æŸï¼š16:32:44.159
è€—æ—¶ï¼š2.739ç§’
--------------------------------------------------------------------------
ã€UnionFind_QU_Rankã€‘
å¼€å§‹ï¼š16:32:44.203
ç»“æŸï¼š16:32:46.787
è€—æ—¶ï¼š2.583ç§’
--------------------------------------------------------------------------
ã€UnionFind_QU_R_PCã€‘
å¼€å§‹ï¼š16:32:46.796
ç»“æŸï¼š16:32:48.700
è€—æ—¶ï¼š1.904ç§’
--------------------------------------------------------------------------
ã€UnionFind_QU_R_PSã€‘
å¼€å§‹ï¼š16:32:48.706
ç»“æŸï¼š16:32:50.388
è€—æ—¶ï¼š1.682ç§’
--------------------------------------------------------------------------
ã€UnionFind_QU_R_PHã€‘
å¼€å§‹ï¼š16:32:50.417
ç»“æŸï¼š16:32:52.107
è€—æ—¶ï¼š1.69ç§’
--------------------------------------------------------------------------
ã€GenericUnionFindã€‘
å¼€å§‹ï¼š16:32:54.511
ç»“æŸï¼š16:32:59.866
è€—æ—¶ï¼š5.354ç§’
--------------------------------------------------------------------------
```

+++

## ä¸‰ã€å›¾Graph

### 1 æ•°æ®ç»“æ„å›é¡¾

å›é¡¾ä¸€ä¸‹ç›®å‰ä¸ºæ­¢æŒæ¡çš„å­¦è¿‡çš„æ•°æ®ç»“æ„ã€‚

![image-20221010040124654](02-æ‹ä¸Šæ•°æ®ç»“æ„-ç®—æ³•ç¯‡.assets/image-20221010040124654.png)

- **çº¿æ€§ç»“æ„**ï¼šæ•°ç»„ã€é“¾è¡¨ã€æ ˆã€é˜Ÿåˆ—ã€å“ˆå¸Œè¡¨
- **æ ‘å½¢ç»“æ„**ï¼šäºŒå‰æ ‘ã€Bæ ‘ã€å †ã€Trieã€å“ˆå¤«æ›¼æ ‘ã€å¹¶æŸ¥é›†
- å›¾æ˜¯ä¸å±äºä»¥ä¸Šä¸¤ç±»çš„æ•°æ®ç»“æ„ã€‚



### 2 å›¾Graph--åŸºç¡€æ¦‚å¿µ

å›¾ç”±**é¡¶ç‚¹**ï¼ˆvertexï¼‰å’Œ**è¾¹**ï¼ˆedgeï¼‰ç»„æˆï¼Œé€šå¸¸è¡¨ç¤ºä¸º G = (V, E)

- G è¡¨ç¤ºä¸€ä¸ªå›¾ï¼ŒV æ˜¯é¡¶ç‚¹é›†ï¼ŒE æ˜¯è¾¹é›†
- **é¡¶ç‚¹é›† V æœ‰ç©·ä¸”éç©º**
- ä»»æ„ä¸¤ä¸ªé¡¶ç‚¹ä¹‹é—´éƒ½å¯ä»¥ç”¨è¾¹æ¥è¡¨ç¤ºå®ƒä»¬ä¹‹é—´çš„å…³ç³»ï¼Œ**è¾¹é›† E å¯ä»¥ä¸ºç©º**

ä»¥ä¸‹éƒ½å±äºå›¾ã€‚

![image-20221010040554111](02-æ‹ä¸Šæ•°æ®ç»“æ„-ç®—æ³•ç¯‡.assets/image-20221010040554111.png)

å›¾ç»“æ„çš„åº”ç”¨æå…¶å¹¿æ³›ï¼š

- ç¤¾äº¤ç½‘ç»œ
- åœ°å›¾å¯¼èˆª
- æ¸¸æˆå¼€å‘
- ......

![image-20221010040658322](02-æ‹ä¸Šæ•°æ®ç»“æ„-ç®—æ³•ç¯‡.assets/image-20221010040658322.png)

![image-20221010040702856](02-æ‹ä¸Šæ•°æ®ç»“æ„-ç®—æ³•ç¯‡.assets/image-20221010040702856.png)



#### 2.1 æœ‰å‘å›¾Directed Graph

æœ‰å‘å›¾çš„**è¾¹æ˜¯æœ‰æ˜ç¡®æ–¹å‘**çš„ï¼š

![image-20221010040732946](02-æ‹ä¸Šæ•°æ®ç»“æ„-ç®—æ³•ç¯‡.assets/image-20221010040732946.png)

æœ‰å‘æ— ç¯å›¾ï¼ˆDirected Acyclic Graphï¼Œç®€ç§° DAGï¼‰

å¦‚æœä¸€ä¸ªæœ‰å‘å›¾ï¼Œä»ä»»æ„é¡¶ç‚¹å‡ºå‘æ— æ³•ç»è¿‡è‹¥å¹²æ¡è¾¹å›åˆ°è¯¥é¡¶ç‚¹ï¼Œé‚£ä¹ˆå®ƒå°±æ˜¯ä¸€ä¸ªæœ‰å‘æ— ç¯å›¾

![image-20221010040832074](02-æ‹ä¸Šæ•°æ®ç»“æ„-ç®—æ³•ç¯‡.assets/image-20221010040832074.png)

- *å‡ºåº¦*ã€*å…¥åº¦*:

å‡ºåº¦ã€å…¥åº¦é€‚ç”¨äº**æœ‰å‘å›¾**ï¼›

![image-20221010040953289](02-æ‹ä¸Šæ•°æ®ç»“æ„-ç®—æ³•ç¯‡.assets/image-20221010040953289.png)

å‡ºåº¦ï¼ˆOut-degreeï¼‰:

- ä¸€ä¸ªé¡¶ç‚¹çš„å‡ºåº¦ä¸º xï¼Œæ˜¯æŒ‡æœ‰ x æ¡è¾¹ä»¥è¯¥é¡¶ç‚¹ä¸ºèµ·ç‚¹
- é¡¶ç‚¹ 11 çš„å‡ºåº¦æ˜¯ 3

å…¥åº¦ï¼ˆIn-degreeï¼‰:

- ä¸€ä¸ªé¡¶ç‚¹çš„å…¥åº¦ä¸º xï¼Œæ˜¯æŒ‡æœ‰ x æ¡è¾¹ä»¥è¯¥é¡¶ç‚¹ä¸ºç»ˆç‚¹
- é¡¶ç‚¹ 11 çš„å…¥åº¦æ˜¯ 2



#### 2.2 æ— å‘å›¾Undirected Graph

æ— å‘å›¾çš„è¾¹æ˜¯**æ— æ–¹å‘**çš„

![image-20221010041118008](02-æ‹ä¸Šæ•°æ®ç»“æ„-ç®—æ³•ç¯‡.assets/image-20221010041118008.png)

**æ— å‘å›¾å¯ä»¥é€šè¿‡æœ‰å‘å›¾è¡¨ç¤ºå‡ºæ¥ï¼Œä½†æ˜¯æœ‰å‘å›¾æ— æ³•é€šè¿‡æ— å‘å›¾æ¥è¡¨ç¤ºã€‚**

ä¸‹é¢è¿™ä¸ªæœ‰å‘å›¾å°±ç›¸å½“äºä¸Šé¢çš„æ— å‘å›¾ã€‚

![image-20221010041148649](02-æ‹ä¸Šæ•°æ®ç»“æ„-ç®—æ³•ç¯‡.assets/image-20221010041148649.png)



#### 2.3 æ··åˆå›¾Mixed Graph

æ··åˆå›¾çš„è¾¹**å¯èƒ½æ˜¯æ— å‘çš„ï¼Œä¹Ÿå¯èƒ½æ˜¯æœ‰å‘çš„**ã€‚

![image-20221010041245929](02-æ‹ä¸Šæ•°æ®ç»“æ„-ç®—æ³•ç¯‡.assets/image-20221010041245929.png)



#### 2.4 ç®€å•å›¾ã€å¤šé‡å›¾

å¹³è¡Œè¾¹ï¼š

- åœ¨æ— å‘å›¾ä¸­ï¼Œå…³è”ä¸€å¯¹é¡¶ç‚¹çš„æ— å‘è¾¹å¦‚æœå¤šäº1æ¡ï¼Œåˆ™ç§°è¿™äº›è¾¹ä¸ºå¹³è¡Œè¾¹
- åœ¨æœ‰å‘å›¾ä¸­ï¼Œå…³è”ä¸€å¯¹é¡¶ç‚¹çš„æœ‰å‘è¾¹å¦‚æœå¤šäº1æ¡ï¼Œå¹¶ä¸”å®ƒä»¬çš„çš„æ–¹å‘ç›¸åŒï¼Œåˆ™ç§°è¿™äº›è¾¹ä¸ºå¹³è¡Œè¾¹

å¤šé‡å›¾ï¼ˆMultigraphï¼‰ï¼š

- æœ‰å¹³è¡Œè¾¹æˆ–è€…æœ‰è‡ªç¯çš„å›¾

ç®€å•å›¾ï¼ˆSimple Graphï¼‰ï¼š

- æ—¢æ²¡æœ‰å¹³è¡Œè¾¹ä¹Ÿä¸æ²¡æœ‰è‡ªç¯çš„å›¾
- ç¬”è®°ä¸­è®¨è®ºçš„åŸºæœ¬éƒ½æ˜¯ç®€å•å›¾

![image-20221010041409762](02-æ‹ä¸Šæ•°æ®ç»“æ„-ç®—æ³•ç¯‡.assets/image-20221010041409762.png)



#### 2.5 æ— å‘å®Œå…¨å›¾Undirected Complete Graph

æ— å‘å®Œå…¨å›¾çš„ä»»æ„ä¸¤ä¸ªé¡¶ç‚¹ä¹‹é—´éƒ½å­˜åœ¨è¾¹

- n ä¸ªé¡¶ç‚¹çš„æ— å‘å®Œå…¨å›¾æœ‰ `n(nâˆ’1)/2` æ¡è¾¹
- (n âˆ’ 1) + (n âˆ’ 2) + (n âˆ’ 3) + â‹¯ + 3 + 2 + 1 = n(n-1)/2

![image-20221010041700038](02-æ‹ä¸Šæ•°æ®ç»“æ„-ç®—æ³•ç¯‡.assets/image-20221010041700038.png)



#### 2.6 æœ‰å‘å®Œå…¨å›¾Directed Complete Graph

æœ‰å‘å®Œå…¨å›¾çš„ä»»æ„ä¸¤ä¸ªé¡¶ç‚¹ä¹‹é—´éƒ½å­˜åœ¨æ–¹å‘ç›¸åçš„ä¸¤æ¡è¾¹

- n ä¸ªé¡¶ç‚¹çš„æœ‰å‘å®Œå…¨å›¾æœ‰ `n(nâˆ’1)` æ¡è¾¹

![image-20221010041929066](02-æ‹ä¸Šæ•°æ®ç»“æ„-ç®—æ³•ç¯‡.assets/image-20221010041929066.png)

- ç¨ å¯†å›¾ï¼ˆDense Graphï¼‰ï¼šè¾¹æ•°æ¥è¿‘äºæˆ–ç­‰äºå®Œå…¨å›¾
- ç¨€ç–å›¾ï¼ˆSparse Graphï¼‰ï¼šè¾¹æ•°è¿œè¿œå°‘äºå®Œå…¨å›¾



#### 2.7 æœ‰æƒå›¾Weighted Graph

æœ‰æƒå›¾çš„è¾¹å¯ä»¥æ‹¥æœ‰æƒå€¼ï¼ˆWeightï¼‰

![image-20221010042124863](02-æ‹ä¸Šæ•°æ®ç»“æ„-ç®—æ³•ç¯‡.assets/image-20221010042124863.png)



#### 2.8 è¿é€šå›¾Connected Graph

å¦‚æœé¡¶ç‚¹ x å’Œ y ä¹‹é—´å­˜åœ¨**å¯ç›¸äº’æŠµè¾¾çš„è·¯å¾„ï¼ˆç›´æ¥æˆ–é—´æ¥çš„è·¯å¾„ï¼‰**ï¼Œåˆ™ç§° x å’Œ y æ˜¯è¿é€šçš„

å¦‚æœ*æ— å‘å›¾* G ä¸­**ä»»æ„** 2 ä¸ªé¡¶ç‚¹éƒ½æ˜¯è¿é€šçš„ï¼Œåˆ™ç§°Gä¸º**è¿é€šå›¾**ã€‚

![image-20221010042242815](02-æ‹ä¸Šæ•°æ®ç»“æ„-ç®—æ³•ç¯‡.assets/image-20221010042242815.png)

*è¿é€šåˆ†é‡*ï¼ˆConnected Componentï¼‰

è¿é€šåˆ†é‡ï¼šæ— å‘å›¾çš„æå¤§è¿é€šå­å›¾

- è¿é€šå›¾åªæœ‰ä¸€ä¸ªè¿é€šåˆ†é‡ï¼Œå³å…¶è‡ªèº«
- éè¿é€šçš„*æ— å‘å›¾*æœ‰å¤šä¸ªè¿é€šåˆ†é‡

ä¸‹é¢çš„æ— å‘å›¾æœ‰ 3 ä¸ªè¿é€šåˆ†é‡ï¼š

![image-20221010042620086](02-æ‹ä¸Šæ•°æ®ç»“æ„-ç®—æ³•ç¯‡.assets/image-20221010042620086.png)



#### 2.9 å¼ºè¿é€šå›¾Strongly Connected Graph

å¦‚æœ*æœ‰å‘å›¾* G ä¸­**ä»»æ„**2ä¸ªé¡¶ç‚¹éƒ½æ˜¯è¿é€šçš„ï¼Œåˆ™ç§°Gä¸º**å¼ºè¿é€šå›¾**

![image-20221010042830023](02-æ‹ä¸Šæ•°æ®ç»“æ„-ç®—æ³•ç¯‡.assets/image-20221010042830023.png)

*å¼ºè¿é€šåˆ†é‡*ï¼ˆStrongly Connected Componentï¼‰

å¼ºè¿é€šåˆ†é‡ï¼šæœ‰å‘å›¾çš„æå¤§å¼ºè¿é€šå­å›¾

- å¼ºè¿é€šå›¾åªæœ‰ä¸€ä¸ªå¼ºè¿é€šåˆ†é‡ï¼Œå³å…¶è‡ªèº«ï¼›
- éå¼ºè¿é€šçš„*æœ‰å‘å›¾*æœ‰å¤šä¸ªå¼ºè¿é€šåˆ†é‡

![image-20221010043003234](02-æ‹ä¸Šæ•°æ®ç»“æ„-ç®—æ³•ç¯‡.assets/image-20221010043003234.png)



### 3 å›¾çš„å®ç°æ–¹æ¡ˆ

å›¾æœ‰2ç§å¸¸è§çš„å®ç°æ–¹æ¡ˆï¼š

- é‚»æ¥çŸ©é˜µï¼ˆAdjacency Matrixï¼‰
- é‚»æ¥è¡¨ï¼ˆAdjacency Listï¼‰



#### 3.1 é‚»æ¥çŸ©é˜µAdjacency Matrix

é‚»æ¥çŸ©é˜µçš„å­˜å‚¨æ–¹å¼

- ä¸€ç»´æ•°ç»„å­˜æ”¾é¡¶ç‚¹ä¿¡æ¯
- äºŒç»´æ•°ç»„å­˜æ”¾è¾¹ä¿¡æ¯

é‚»æ¥çŸ©é˜µæ¯”è¾ƒé€‚åˆç¨ å¯†å›¾

- ä¸ç„¶ä¼šæ¯”è¾ƒæµªè´¹å†…å­˜

![image-20221010043333755](02-æ‹ä¸Šæ•°æ®ç»“æ„-ç®—æ³•ç¯‡.assets/image-20221010043333755.png)

*é‚»æ¥çŸ©é˜µ--æœ‰æƒå›¾*ï¼š

![image-20221010043511391](02-æ‹ä¸Šæ•°æ®ç»“æ„-ç®—æ³•ç¯‡.assets/image-20221010043511391.png)



#### 3.2 é‚»æ¥è¡¨Adjacency List

é‚»æ¥çŸ©é˜µçš„å­˜å‚¨æ–¹å¼

- ä¸€ç»´æ•°ç»„å­˜æ”¾é¡¶ç‚¹é›†
- æ•°ç»„ä¸­çš„é¡¶ç‚¹é›†åé¢è·Ÿç€è¾¹é›†ï¼ˆé“¾è¡¨ï¼‰

é‚»æ¥çŸ©é˜µæ¯”è¾ƒé€‚åˆç¨€ç–å›¾

![image-20221010044443560](02-æ‹ä¸Šæ•°æ®ç»“æ„-ç®—æ³•ç¯‡.assets/image-20221010044443560.png)

*é‚»æ¥è¡¨--æœ‰æƒå›¾*ï¼š

![image-20221010044530319](02-æ‹ä¸Šæ•°æ®ç»“æ„-ç®—æ³•ç¯‡.assets/image-20221010044530319.png)



### 4 å›¾çš„åŸºç¡€ä»£ç 

![image-20221006225502980](02-æ‹ä¸Šæ•°æ®ç»“æ„-ç®—æ³•ç¯‡.assets/image-20221006225502980.png)

#### 4.1 å›¾çš„æ¥å£è®¾è®¡

```java
public interface Graph<V, E> {
	int edgesSize(); 		// è¾¹çš„æ•°é‡
	int verticesSize();		// é¡¶ç‚¹æ•°é‡
	
	void addVertex(V v); 		// æ·»åŠ é¡¶ç‚¹
	void addEdge(V from, V to); // æ·»åŠ è¾¹
	void addEdge(V from, V to, E weight);// æ·»åŠ è¾¹--æœ‰æƒå€¼
	
	void removeVertex(V v); 		// åˆ é™¤é¡¶ç‚¹
	void removeEdge(V from, V to);	 // åˆ é™¤è¾¹
	
	interface vertexVisitor<V>{
		boolean visit(V v);
	}
 }
```



#### 4.2 é¡¶ç‚¹å’Œè¾¹çš„è®¾è®¡

- é¡¶ç‚¹`Vertex`çš„å®šä¹‰

```java
// é¡¶ç‚¹
private static class Vertex<V, E> {
    V value;
    Set<Edge<V,E>> inEdges = new HashSet<>(); // å…¥åº¦è¾¹
    Set<Edge<V,E>> outEdges = new HashSet<>(); // å‡ºåº¦è¾¹
    public Vertex(V value) {
        this.value = value;
    }
    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (!(o instanceof Vertex)) return false;
        Vertex<?, ?> vertex = (Vertex<?, ?>) o;
        return Objects.equals(value, vertex.value);
    }
    @Override
    public int hashCode() {
        return Objects.hash(value);
    }
    @Override
    public String toString() {
        return value == null ? "null" : value.toString();
    }
}
```

- è¾¹`Edge`çš„å®šä¹‰

```java
// è¾¹
private static class Edge<V, E> {
    Vertex<V,E> from; // èµ·ç‚¹
    Vertex<V,E> to; // ç»ˆç‚¹
    E weight; // æƒå€¼
    Edge(Vertex<V, E> from, Vertex<V, E> to) {
        this(from, to, null);
    }
    Edge(Vertex<V, E> from, Vertex<V, E> to, E weight) {
        this.from = from;
        this.to = to;
        this.weight = weight;
    }
    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (!(o instanceof Edge)) return false;
        Edge<V, E> edge = (Edge<V, E>) o;
        return Objects.equals(from, edge.from) && Objects.equals(to, edge.to);
    }
    @Override
    public int hashCode() {
        return Objects.hash(from, to);
    }
    @Override
    public String toString() {
        return "Edge [from=" + from + ", to=" + to + ", weight=" + weight + "]";
    }
}
```

ä¸€äº›ç¨å¾®å¤æ‚çš„æ“ä½œå•ç‹¬åˆ—å‡ºæ¥ï¼Œç®€å•åœ°æ“ä½œç›´æ¥ä»**å®Œæ•´æºç **ä¸­æŸ¥çœ‹å³å¯ã€‚



#### 4.3 æ·»åŠ è¾¹addEdge

```java
private Map<V, Vertex<V,E>> vertices = new HashMap<>(); // å›¾é›†
private Set<Edge<V, E>> edges = new HashSet<>(); // è¾¹é›†

/**
 * æ·»åŠ æ— æƒå€¼çš„è¾¹
 */
@Override
public void addEdge(V from, V to) {
	addEdge(from, to, null);
}

/*
 * æ·»åŠ æœ‰æƒå€¼çš„è¾¹
 */
@Override
public void addEdge(V from, V to, E weight) {
	// æ ¹æ®ä¼ å…¥çš„å‚æ•°fromæ‰¾åˆ°å‡ºå‘ç‚¹,å¦‚æœä¸å­˜åœ¨åˆ™åˆ›å»º
	Vertex<V, E> fromVertex = vertices.get(from);
	if(fromVertex == null){ 
		vertices.put(from, fromVertex = new Vertex<>(from));
	}
	// æ ¹æ®ä¼ å…¥çš„å‚æ•°toæ‰¾åˆ°ç»ˆç‚¹,å¦‚æœä¸å­˜åœ¨åˆ™åˆ›å»º
	Vertex<V, E> toVertex = vertices.get(to);
	if(toVertex == null){
		vertices.put(to, toVertex = new Vertex<>(to));
	}
	
	// æ ¹æ®å‡ºå‘ç‚¹ä¸ç»ˆç‚¹,åˆ›å»ºè¾¹
	Edge<V, E> edge = new Edge<>(fromVertex, toVertex, weight);
	
	// ä¸ç®¡åŸæ¥æ˜¯å¦å­˜åœ¨,éƒ½å…ˆåˆ é™¤æ­¤è¾¹,å†æ·»åŠ è¿›å»
	if(fromVertex.outEdges.remove(edge)){ 
		toVertex.inEdges.remove(edge);
		edges.remove(edge);
	}
	fromVertex.outEdges.add(edge);
	toVertex.inEdges.add(edge);
	edges.add(edge);
}
```



#### 4.4 åˆ é™¤è¾¹removeEdge

```java
private Map<V, Vertex<V,E>> vertices = new HashMap<>(); // å›¾é›†
private Set<Edge<V, E>> edges = new HashSet<>(); // è¾¹é›†

/*
 * åˆ é™¤è¾¹
 */
@Override
public void removeEdge(V from, V to) {
	// æ ¹æ®ä¼ å…¥çš„fromè·å¾—èµ·ç‚¹,ä¸å­˜åœ¨åˆ™ä¸éœ€è¦åˆ é™¤
	Vertex<V, E> fromVertex = vertices.get(from);
	// æ ¹æ®ä¼ å…¥çš„toæ‰¾åˆ°ç»ˆç‚¹,ä¸å­˜åœ¨åˆ™ä¸éœ€è¦åˆ é™¤
	Vertex<V, E> toVertex = vertices.get(to);
    if (fromVertex == null || toVertex == null) return;
	
	// æ ¹æ®èµ·ç‚¹å’Œç»ˆç‚¹è·å¾—è¾¹,ç„¶ååˆ é™¤
	Edge<V, E> edge = new Edge<>(fromVertex, toVertex);
	if(fromVertex.outEdges.remove(edge)){
		toVertex.inEdges.remove(edge);
		edges.remove(edge);
	}
}
```



#### 4.5 åˆ é™¤ç‚¹removeVertex

```java
private Map<V, Vertex<V,E>> vertices = new HashMap<>(); // å›¾é›†
private Set<Edge<V, E>> edges = new HashSet<>(); // è¾¹é›†

/*
 * åˆ é™¤ç‚¹
 */
@Override
public void removeVertex(V v) {
	// æ ¹æ®ä¼ å…¥çš„å€¼æ‰¾åˆ°ç‚¹å¹¶åˆ é™¤,ä¸å­˜åœ¨åˆ™ä¸åšæ“ä½œ
	Vertex<V, E> vertex = vertices.remove(v);
	if(vertex == null) return;
	
	// è¿­ä»£å™¨éå†é›†åˆvertex.outEdges, åˆ é™¤æ‰€æœ‰ä»è¯¥ç‚¹å‡ºå»çš„è¾¹
	Iterator<Edge<V, E>> outIterator = vertex.outEdges.iterator();
    while (outIterator.hasNext()) {
        Edge<V, E> edge = outIterator.next(); // éå†åˆ°çš„è¯¥ç‚¹å‡ºå»çš„è¾¹
        edge.to.inEdges.remove(edge); // è·å–ç»ˆç‚¹è¿›å…¥çš„è¾¹,å¹¶ä»ä¸­åˆ é™¤éå†åˆ°çš„è¾¹
        outIterator.remove(); // å°†å½“å‰éå†åˆ°çš„å…ƒç´ edgeä»é›†åˆvertex.outEdgesä¸­åˆ é™¤
        edges.remove(edge);
    }
	
	// è¿­ä»£å™¨éå†é›†åˆvertex.inEdges, åˆ é™¤æ‰€æœ‰è¿›å…¥è¯¥ç‚¹çš„è¾¹
	Iterator<Edge<V, E>> inIterator = vertex.inEdges.iterator();
    while (inIterator.hasNext()) {
        Edge<V, E> edge = inIterator.next(); // éå†åˆ°çš„è¿›å…¥è¯¥ç‚¹çš„è¾¹
        edge.from.outEdges.remove(edge); // è·å–èµ·ç‚¹å‡ºå»çš„è¾¹,å¹¶ä»ä¸­åˆ é™¤éå†åˆ°çš„è¾¹
        inIterator.remove(); // å°†å½“å‰éå†åˆ°çš„å…ƒç´ edgeä»é›†åˆvertex.inEdgesä¸­åˆ é™¤
        edges.remove(edge);
    }
}
```



#### 4.6 å®Œæ•´æºç 

```java
package com.xk._02Algorithmic._03graph.graph;

import com.xk._02Algorithmic._03graph.GenericUnionFind;
import com.xk._02Algorithmic._03graph.MinHeap;

import java.util.*;

/**
 * @description:
 * @author: xu
 * @date: 2022/10/5 20:28
 */
public class ListGraph<V, E> extends Graph<V, E>{
    // ä¼ å…¥çš„Vä¸é¡¶ç‚¹ç±»Vertexçš„æ˜ å°„
    private Map<V, Vertex<V,E>> vertices = new HashMap<>();
    // è¾¹ç±»Edgeçš„Seté›†åˆ
    private Set<Edge<V, E>> edges = new HashSet<>();

    // é¡¶ç‚¹
    private static class Vertex<V, E> {
        V value;
        Set<Edge<V,E>> inEdges = new HashSet<>();
        Set<Edge<V,E>> outEdges = new HashSet<>();
        Vertex(V value) {
            this.value = value;
        }
        @Override
        public boolean equals(Object o) {
            if (this == o) return true;
            if (!(o instanceof Vertex)) return false;
            Vertex<?, ?> vertex = (Vertex<?, ?>) o;
            return Objects.equals(value, vertex.value);
        }
        @Override
        public int hashCode() {
            return Objects.hash(value);
        }

        @Override
        public String toString() {
            return value == null ? "null" : value.toString();
        }
    }

    // è¾¹
    private static class Edge<V, E> {
        Vertex<V,E> from;
        Vertex<V,E> to;
        E weight; // æƒå€¼
        Edge(Vertex<V, E> from, Vertex<V, E> to) {
            this(from, to, null);
        }
        Edge(Vertex<V, E> from, Vertex<V, E> to, E weight) {
            this.from = from;
            this.to = to;
            this.weight = weight;
        }

        @Override
        public boolean equals(Object o) {
            if (this == o) return true;
            if (!(o instanceof Edge)) return false;
            Edge<V, E> edge = (Edge<V, E>) o;
            return Objects.equals(from, edge.from) && Objects.equals(to, edge.to);
        }
        @Override
        public int hashCode() {
            return Objects.hash(from, to);
        }
        @Override
        public String toString() {
            return "Edge{" +
                    "from=" + from +
                    ", to=" + to +
                    ", weight=" + weight +
                    '}';
        }
    }

    public void print(){
		System.out.println("[é¡¶ç‚¹]-------------------");
		vertices.forEach((V v, Vertex<V, E> vertex) -> {
			System.out.println(v);
			System.out.println("out-----------");
			System.out.println(vertex.outEdges);
			System.out.println("int-----------");
			System.out.println(vertex.inEdges);
		});
		System.out.println("[è¾¹]-------------------");
		edges.forEach((Edge<V, E> edge) -> {
			System.out.println(edge);
		});
	}

    /**
     * è¿”å›è¾¹çš„æ•°é‡
     * @return
     */
    @Override
    public int edgesSize() {
        return edges.size();
    }

    /**
     * è¿”å›é¡¶ç‚¹çš„æ•°é‡
     * @return
     */
    @Override
    public int verticsSize() {
        return vertices.size();
    }

    /**
     * æ·»åŠ é¡¶ç‚¹
     * @param v
     */
    @Override
    public void  addVertex(V v) {
        if (vertices.containsKey(v)) return;
        vertices.put(v, new Vertex<>(v));
    }

    /**
     * æ·»åŠ è¾¹ï¼šæ— æƒå€¼
     * @param from
     * @param to
     */
    @Override
    public void addEdge(V from, V to) {
        addEdge(from, to, null);
    }

    /**
     * æ·»åŠ è¾¹ï¼šæœ‰æƒå€¼
     * @param from
     * @param to
     * @param weight
     */
    @Override
    public void addEdge(V from, V to, E weight) {
        // åˆ¤æ–­ from ã€to é¡¶ç‚¹æ˜¯å¦å­˜åœ¨
        Vertex<V, E> fromVertex = vertices.get(from);
        Vertex<V, E> toVertex = vertices.get(to);
        if (fromVertex == null) {
            vertices.put(from, fromVertex = new Vertex<>(from));
        }
        if (toVertex == null) {
            vertices.put(to, toVertex = new Vertex<>(to));
        }
        Edge<V, E> edge = new Edge<>(fromVertex, toVertex, weight);

        if (fromVertex.outEdges.remove(edge)){
            toVertex.inEdges.remove(edge);
            edges.remove(edge);
        }
        fromVertex.outEdges.add(edge);
        toVertex.inEdges.add(edge);
        edges.add(edge);
    }

    /**
     * åˆ é™¤é¡¶ç‚¹
     * @param v
     */
    @Override
    public void removeVertex(V v) {
        Vertex<V, E> vertex = vertices.remove(v);
        if (vertex == null) return;

        // è¿­ä»£å™¨
        Iterator<Edge<V, E>> outIterator = vertex.outEdges.iterator();
        while (outIterator.hasNext()) {
            Edge<V, E> edge = outIterator.next();
            edge.to.inEdges.remove(edge);
            // å°†å½“å‰éå†åˆ°çš„å…ƒç´ edgeä»é›†åˆvertex.outEdgesä¸­åˆ é™¤
            outIterator.remove();
            edges.remove(edge);
        }

        Iterator<Edge<V, E>> inIterator = vertex.inEdges.iterator();
        while (inIterator.hasNext()) {
            Edge<V, E> edge = inIterator.next();
            edge.from.outEdges.remove(edge);
            // å°†å½“å‰éå†åˆ°çš„å…ƒç´ edgeä»é›†åˆvertex.inEdgesä¸­åˆ é™¤
            inIterator.remove();
            edges.remove(edge);
        }
    }

    /**
     * åˆ é™¤è¾¹
     * @param from
     * @param to
     */
    @Override
    public void removeEdge(V from, V to) {
        Vertex<V, E> fromVertex = vertices.get(from);
        Vertex<V, E> toVertex = vertices.get(to);
        if (fromVertex == null || toVertex == null) return;
        Edge<V, E> edge = new Edge<>(fromVertex, toVertex);
        if (fromVertex.outEdges.remove(edge)) {
            toVertex.inEdges.remove(edge);
            edges.remove(edge);
        }
    }
}
```



### 5 å›¾çš„éå†

å›¾çš„éå†ï¼š

- ä»å›¾ä¸­æŸä¸€é¡¶ç‚¹å‡ºå‘è®¿é—®å›¾ä¸­å…¶ä½™é¡¶ç‚¹ï¼Œä¸”*æ¯ä¸€ä¸ªé¡¶ç‚¹ä»…è¢«è®¿é—®ä¸€æ¬¡*ã€‚

å›¾æœ‰2ç§å¸¸è§çš„éå†æ–¹å¼ï¼ˆæœ‰å‘å›¾ã€æ— å‘å›¾éƒ½é€‚ç”¨ï¼‰

- **å¹¿åº¦ä¼˜å…ˆæœç´¢ï¼ˆBreadth First Searchï¼ŒBFSï¼‰**ï¼Œåˆç§°ä¸º**å®½åº¦ä¼˜å…ˆæœç´¢**ã€**æ¨ªå‘ä¼˜å…ˆæœç´¢**ã€‚

- **æ·±åº¦ä¼˜å…ˆæœç´¢ï¼ˆDepth First Searchï¼ŒDFSï¼‰**ï¼Œ

  å‘æ˜**æ·±åº¦ä¼˜å…ˆæœç´¢**ç®—æ³•çš„2ä½ç§‘å­¦å®¶åœ¨1986å¹´å…±åŒè·å¾—è®¡ç®—æœºé¢†åŸŸçš„æœ€é«˜å¥–ï¼šå›¾çµå¥–ã€‚

åœ¨æ¥å£ä¸­å¢åŠ  `bfs` ä¸ `dfs` æ–¹æ³•ã€‚

```java
public interface Graph<V, E> {
	int edgesSize(); // è¾¹çš„æ•°é‡
	int verticesSize();	// é¡¶ç‚¹æ•°é‡
	
	void addVertex(V v); // æ·»åŠ é¡¶ç‚¹
	void addEdge(V from, V to); // æ·»åŠ è¾¹
	void addEdge(V from, V to, E weight);// æ·»åŠ è¾¹
	
	void removeVertex(V v); // åˆ é™¤é¡¶ç‚¹
	void removeEdge(V from, V to); // åˆ é™¤è¾¹
	
	void bfs(V begin, vertexVisitor<V> visitor); // å¹¿åº¦ä¼˜å…ˆæœç´¢
	void dfs(V begin, vertexVisitor<V> visitor); // æ·±åº¦ä¼˜å…ˆæœç´¢
	
	interface vertexVisitor<V>{
		boolean visit(V v);
	}	
}
```



#### 5.1 å¹¿åº¦ä¼˜å…ˆæœç´¢BFS

ä¹‹å‰æ‰€å­¦çš„**äºŒå‰æ ‘å±‚åºéå†**å°±æ˜¯ä¸€ç§**å¹¿åº¦ä¼˜å…ˆæœç´¢**ã€‚

æ³¨ï¼š**BFSç»“æœä¸å”¯ä¸€**ã€‚

![image-20221010052922096](02-æ‹ä¸Šæ•°æ®ç»“æ„-ç®—æ³•ç¯‡.assets/image-20221010052922096.png)

![image-20221010053239782](02-æ‹ä¸Šæ•°æ®ç»“æ„-ç®—æ³•ç¯‡.assets/image-20221010053239782.png)

**æ€è·¯**ï¼š

![image-20221010053631101](02-æ‹ä¸Šæ•°æ®ç»“æ„-ç®—æ³•ç¯‡.assets/image-20221010053631101.png)

ä»æŸä¸ªç‚¹å¼€å§‹ï¼Œå°†å®ƒå¯ä»¥åˆ°è¾¾çš„ç‚¹æ”¾å…¥é˜Ÿåˆ—ï¼Œå¦‚æœå·²ç»è®¿é—®è¿‡åˆ™è·³è¿‡ï¼Œç„¶åä»é˜Ÿåˆ—ä¸­å–å‡ºç‚¹é‡å¤è¯¥è¿‡ç¨‹ã€‚

- `ç¬¬ä¸€å±‚`ï¼šå‡è®¾ä»ç‚¹Aå¼€å§‹ï¼Œå®ƒå¯ä»¥åˆ°è¾¾Bã€Fï¼Œåˆ™**å°†Bã€Få…¥é˜Ÿ**ã€‚

  æ­¤æ—¶é˜Ÿåˆ—ä¸­å…ƒç´  [Bã€F]

- `ç¬¬äºŒå±‚`ï¼šé˜Ÿå¤´Bå‡ºé˜Ÿï¼ŒBå¯ä»¥åˆ°è¾¾Cã€Iã€Gï¼Œ**å°†Cã€Iã€Gå…¥é˜Ÿ**ã€‚

  æ­¤æ—¶é˜Ÿåˆ—ä¸­å…ƒç´  [Fã€Cã€Iã€G]

- `ç¬¬ä¸‰å±‚`ï¼šé˜Ÿå¤´Få‡ºé˜Ÿï¼ŒFå¯ä»¥åˆ°è¾¾Gã€Eï¼Œä½†Gå·²è®¿é—®è¿‡ï¼Œ**å°†Eå…¥é˜Ÿ**ã€‚

  æ­¤æ—¶é˜Ÿåˆ—ä¸­å…ƒç´  [Cã€Iã€Gã€E]

- `ç¬¬å››å±‚`ï¼šé˜Ÿå¤´Cå‡ºé˜Ÿï¼ŒCå¯ä»¥åˆ°è¾¾Iã€Dï¼Œä½†Iå·²è®¿é—®è¿‡ï¼Œ**å°†Då…¥é˜Ÿ**ã€‚

  æ­¤æ—¶é˜Ÿåˆ—ä¸­å…ƒç´  [Iã€Gã€Eã€D]

- `ç¬¬äº”å±‚`ï¼šé˜Ÿå¤´Iå‡ºé˜Ÿï¼ŒIå¯ä»¥åˆ°è¾¾Dï¼Œä½†Då·²è®¿é—®è¿‡ï¼Œä¸æ‰§è¡Œæ“ä½œã€‚

  æ­¤æ—¶é˜Ÿåˆ—ä¸­å…ƒç´  [Gã€Eã€D]

- `ç¬¬å…­å±‚`ï¼šé˜Ÿå¤´Gå‡ºé˜Ÿï¼ŒGå¯ä»¥åˆ°è¾¾Dã€Hï¼Œä½†Då·²è®¿é—®è¿‡ï¼Œ**å°†Hå…¥é˜Ÿ**ã€‚

  æ­¤æ—¶é˜Ÿåˆ—ä¸­å…ƒç´  [Eã€Dã€H]

- `ç¬¬ä¸ƒå±‚`ï¼šé˜Ÿå¤´Eå‡ºé˜Ÿï¼ŒEå¯ä»¥åˆ°è¾¾Dã€Hã€Fï¼Œéƒ½è®¿é—®è¿‡ï¼Œä¸æ‰§è¡Œæ“ä½œã€‚

  æ­¤æ—¶é˜Ÿåˆ—ä¸­å…ƒç´  [Dã€H]

- `ç¬¬å…«å±‚`ï¼šé˜Ÿå¤´Då‡ºé˜Ÿï¼ŒDå¯ä»¥åˆ°è¾¾Cã€Hã€Eï¼Œéƒ½è®¿é—®è¿‡ï¼Œä¸æ‰§è¡Œæ“ä½œã€‚

  æ­¤æ—¶é˜Ÿåˆ—ä¸­å…ƒç´  [H]

- `ç¬¬ä¹å±‚`ï¼šé˜Ÿå¤´Hå‡ºé˜Ÿï¼ŒHå¯ä»¥åˆ°è¾¾Dã€Gã€Eï¼Œéƒ½è®¿é—®è¿‡ï¼Œä¸æ‰§è¡Œæ“ä½œã€‚

  æ­¤æ—¶é˜Ÿåˆ—ä¸­å…ƒç´  []

- é˜Ÿåˆ—ä¸ºç©ºï¼Œå¹¿åº¦ä¼˜å…ˆæœç´¢ç»“æŸã€‚

ä»£ç å®ç°ï¼š

```java
/**
 * å¹¿åº¦ä¼˜å…ˆéå†
 * @param begin
 */
@Override
public void bfs(V begin, VertexVisitor<V> visitor) {
    if (visitor == null) return;
    // æ ¹æ®ä¼ å…¥çš„å€¼beginæ‰¾åˆ°é¡¶ç‚¹
    Vertex<V, E> beginVertex = vertices.get(begin);
    if (beginVertex == null) return; // è¯¥é¡¶ç‚¹ä¸å­˜åœ¨,ä¸åšæ“ä½œ

    // å­˜æ”¾å·²ç»è®¿é—®è¿‡çš„èŠ‚ç‚¹
    Set<Vertex<V, E>> visitedVertices = new HashSet<>();
    Deque<Vertex<V, E>> queue = new LinkedList<>();
    queue.offer(beginVertex); // å…ƒç´ å…¥é˜Ÿ
    visitedVertices.add(beginVertex);

    // æ€è·¯å‚è€ƒäºŒå‰æ ‘å±‚æ¬¡éå†,é˜Ÿåˆ—å­˜æ”¾æ¯ä¸€å±‚çš„é¡¶ç‚¹,ç”¨é›†åˆè®°å½•å·²ç»è®¿é—®è¿‡çš„ç‚¹
    while (!queue.isEmpty()) {
        Vertex<V, E> vertex = queue.poll(); // é˜Ÿåˆ—ä¸­å–å‡ºä¸€ä¸ªé¡¶ç‚¹
        if (visitor.visit(vertex.value)) return;
        // éå†[é˜Ÿåˆ—ä¸­å–å‡ºçš„é¡¶ç‚¹]çš„å‡ºå»çš„è¾¹,å°†[è¿™äº›è¾¹çš„ç»ˆç‚¹]å…¥é˜Ÿ,å¹¶ä¸”æ ‡è®°ä¸ºå·²ç»è®¿é—®è¿‡
        for (Edge<V, E> edge : vertex.outEdges) {
            // å¦‚æœé›†åˆä¸­å·²ç»è®°å½•è¯¥é¡¶ç‚¹,è¯´æ˜å·²ç»è®¿é—®è¿‡,è·³è¿‡è¿›è¡Œä¸‹ä¸€è½®
            if (visitedVertices.contains(edge.to)) continue;
            queue.offer(edge.to);
            visitedVertices.add(edge.to);
        }
    }
}
```



#### 5.2 æ·±åº¦ä¼˜å…ˆæœç´¢DFS

ä¹‹å‰æ‰€å­¦çš„**äºŒå‰æ ‘å‰åºéå†**å°±æ˜¯ä¸€ç§**æ·±åº¦ä¼˜å…ˆæœç´¢**ã€‚

æ³¨ï¼š**DFSç»“æœä¸å”¯ä¸€**ã€‚

![image-20221010054744476](02-æ‹ä¸Šæ•°æ®ç»“æ„-ç®—æ³•ç¯‡.assets/image-20221010054744476.png)

![image-20221010055020758](02-æ‹ä¸Šæ•°æ®ç»“æ„-ç®—æ³•ç¯‡.assets/image-20221010055020758.png)



##### 5.2.1 é€’å½’å®ç°

```java
/**
 * æ·±åº¦ä¼˜å…ˆéå†ï¼šé€’å½’å®ç°
 * @param begin
 */
@Override
public void dfs(V begin, VertexVisitor<V> visitor) {
    if (visitor == null) return;
    // æ ¹æ®ä¼ å…¥çš„å€¼è·å–é¡¶ç‚¹
    Vertex<V, E> beginVertex = vertices.get(begin);
    // é¡¶ç‚¹ä¸å­˜åœ¨åˆ™ä¸æ‰§è¡Œæ“ä½œ
    if (beginVertex == null) return;

    dfs(beginVertex, visitor, new HashSet<>());// ä¼ å…¥çš„é›†åˆ,ç”¨æ¥è®°å½•è®¿é—®è¿‡çš„é¡¶ç‚¹
}
private void dfs(Vertex<V, E> vertex, VertexVisitor<V> visitor, Set<Vertex<V, E>> visitedVertices) {
    if (visitor.visit(vertex.value)) return;
    visitedVertices.add(vertex);
    for (Edge<V, E> outEdge : vertex.outEdges) {
        if (visitedVertices.contains(outEdge.to)) continue;
        dfs1(outEdge.to, visitor, visitedVertices);
    }
}
```



##### 5.2.2 éé€’å½’å®ç°

*æ€è·¯*ï¼š

![image-20221014125724558](02-æ‹ä¸Šæ•°æ®ç»“æ„-ç®—æ³•ç¯‡.assets/image-20221014125724558.png)

æ­¥éª¤ï¼šå…ˆå°†1é¡¶ç‚¹å…¥æ ˆå¹¶è®¿é—®ï¼Œé›†åˆæ›´æ–°è®°å½•è®¿é—®è¿‡çš„é¡¶ç‚¹ï¼Œè¿›è¡Œä»¥ä¸‹å¾ªç¯

1. å¼¹å‡ºä¸€ä¸ªé¡¶ç‚¹ï¼Œä»outEdgesä¸­é€‰æ‹©ä¸€æ¡è¾¹
2. é€‰æ‹©è¾¹çš„fromã€toæŒ‰é¡ºåºå…¥æ ˆ
3. æ‰“å°é€‰æ‹©è¾¹çš„toé¡¶ç‚¹

```java
/**
 * æ·±åº¦ä¼˜å…ˆéå†ï¼šéé€’å½’
 * @param begin
 */
public void dfs(V begin, VertexVisitor<V> visitor) {
    if (visitor == null) return;
    Vertex<V, E> vertex = vertices.get(begin);
    if (vertex == null) return;

    Set<Vertex<V, E>> visitedVertices = new HashSet<>();
    Deque<Vertex<V, E>> stack = new LinkedList<>();

    //å…ˆè®¿é—®èµ·ç‚¹
    stack.push(vertex);
    visitedVertices.add(vertex);
    if (visitor.visit(vertex.value)) return;

    while (!stack.isEmpty()) {
        Vertex<V, E> pop = stack.pop();

        for (Edge<V, E> outEdge : pop.outEdges) {
            if (visitedVertices.contains(outEdge.to)) continue;
            stack.push(outEdge.from);
            stack.push(outEdge.to);
            visitedVertices.add(outEdge.to);
            if (visitor.visit(outEdge.to.value)) return;
            break;
        }
    }
}
```



### 6 æ‹“æ‰‘æ’åºTopological Sort

#### 6.1 AOVç½‘

AOVï¼šActivity On Vertex Network

ä¸€é¡¹å¤§çš„å·¥ç¨‹å¸¸è¢«åˆ†ä¸ºå¤šä¸ªå°çš„å­å·¥ç¨‹

- å­å·¥ç¨‹ä¹‹é—´å¯èƒ½å­˜åœ¨ä¸€å®šçš„å…ˆåé¡ºåºï¼Œå³æŸäº›å­å·¥ç¨‹å¿…é¡»åœ¨å…¶ä»–çš„ä¸€äº›å­å·¥ç¨‹å®Œæˆåæ‰èƒ½å¼€å§‹ã€‚

åœ¨ç°ä»£åŒ–ç®¡ç†ä¸­ï¼Œäººä»¬å¸¸ç”¨**æœ‰å‘å›¾**æ¥**æè¿°å’Œåˆ†æä¸€é¡¹å·¥ç¨‹çš„è®¡åˆ’å’Œå®æ–½è¿‡ç¨‹**ï¼Œ**å­å·¥ç¨‹**è¢«ç§°**ä¸ºæ´»åŠ¨**ï¼ˆActivityï¼‰

- ä»¥**é¡¶ç‚¹è¡¨ç¤ºæ´»åŠ¨**ã€**æœ‰å‘è¾¹è¡¨ç¤ºæ´»åŠ¨ä¹‹é—´çš„å…ˆåå…³ç³»**ï¼Œè¿™æ ·çš„å›¾ç®€ç§°ä¸º **AOVç½‘**ã€‚



**æ ‡å‡†çš„AOVç½‘å¿…é¡»æ˜¯ä¸€ä¸ªæœ‰å‘æ— ç¯å›¾**ï¼ˆDirected Acyclic Graphï¼Œç®€ç§° DAGï¼‰

![image-20221014131829940](02-æ‹ä¸Šæ•°æ®ç»“æ„-ç®—æ³•ç¯‡.assets/image-20221014131829940.png)



#### 6.2 æ‹“æ‰‘æ’åº

å‰é©±æ´»åŠ¨ï¼š**æœ‰å‘è¾¹èµ·ç‚¹çš„æ´»åŠ¨**ç§°ä¸º**ç»ˆç‚¹çš„å‰é©±æ´»åŠ¨**ï¼›

- åªæœ‰å½“ä¸€ä¸ªæ´»åŠ¨çš„å‰é©±å…¨éƒ¨éƒ½å®Œæˆåï¼Œè¿™ä¸ªæ´»åŠ¨æ‰èƒ½è¿›è¡Œ

åç»§æ´»åŠ¨ï¼š**æœ‰å‘è¾¹ç»ˆç‚¹çš„æ´»åŠ¨**ç§°ä¸º**èµ·ç‚¹çš„åç»§æ´»åŠ¨**ï¼›

![image-20221014132028183](02-æ‹ä¸Šæ•°æ®ç»“æ„-ç®—æ³•ç¯‡.assets/image-20221014132028183.png)

- A æ˜¯ B çš„å‰é©±æ´»åŠ¨ï¼ŒB æ˜¯ A çš„åç»§æ´»åŠ¨
- B æ˜¯ C çš„å‰é©±æ´»åŠ¨ï¼ŒC æ˜¯ B çš„åç»§æ´»åŠ¨
- ......



#### 6.3 æ‹“æ‰‘æ’åº--æ€è·¯

å¯ä»¥ä½¿ç”¨**å¡æ©ç®—æ³•**ï¼ˆKahnäº1962å¹´æå‡ºï¼‰å®Œæˆæ‹“æ‰‘æ’åºã€‚

å‡è®¾ L æ˜¯å­˜æ”¾æ‹“æ‰‘æ’åºç»“æœçš„åˆ—è¡¨ï¼š

- 1. æŠŠæ‰€æœ‰å…¥åº¦ä¸º 0 çš„é¡¶ç‚¹æ”¾å…¥ L ä¸­ï¼Œç„¶åæŠŠè¿™äº›é¡¶ç‚¹ä»å›¾ä¸­å»æ‰
  2. é‡å¤æ“ä½œ*1*ï¼Œç›´åˆ°æ‰¾ä¸åˆ°å…¥åº¦ä¸º 0 çš„é¡¶ç‚¹
- å¦‚æœæ­¤æ—¶ L ä¸­çš„å…ƒç´ ä¸ªæ•°å’Œé¡¶ç‚¹æ€»æ•°ç›¸åŒï¼Œè¯´æ˜æ‹“æ‰‘æ’åºå®Œæˆ
- å¦‚æœæ­¤æ—¶ L ä¸­çš„å…ƒç´ ä¸ªæ•°å°‘äºé¡¶ç‚¹æ€»æ•°ï¼Œè¯´æ˜åŸå›¾ä¸­å­˜åœ¨ç¯ï¼Œæ— æ³•è¿›è¡Œæ‹“æ‰‘æ’åº

![image-20221014132334251](02-æ‹ä¸Šæ•°æ®ç»“æ„-ç®—æ³•ç¯‡.assets/image-20221014132334251.png)

*å®ç°*ï¼š

```java
/**
 * æ‹“æ‰‘æ’åºï¼šå¡æ©ç®—æ³•
 * @return
 */
@Override
public List<V> topologicalSort() {
    List<V> list = new ArrayList<>(); // ç»“æœé›†
    Queue<Vertex<V, E>> queue = new LinkedList<>(); // é˜Ÿåˆ—å­˜å‚¨å…¥åº¦ä¸º0çš„èŠ‚ç‚¹
    Map<Vertex<V, E>, Integer> ins = new HashMap<>(); // mapè®°å½•å…¥åº¦ä¸ä¸º0çš„èŠ‚ç‚¹ 

    // åˆå§‹åŒ–ï¼ˆå°†å…¥åº¦ä¸º0çš„èŠ‚ç‚¹éƒ½æ”¾å…¥é˜Ÿåˆ—ï¼‰
    vertices.forEach((V v, Vertex<V, E> vertex) -> {
        int inSize = vertex.inEdges.size(); // å…¥åº¦
        if (inSize == 0) queue.offer(vertex); // å…¥åº¦ä¸º0ï¼Œæ”¾å…¥é˜Ÿåˆ—
        else ins.put(vertex, inSize);  // å…¥åº¦ä¸ä¸º0ï¼Œç”¨mapè®°å½•å®ƒçš„å…¥åº¦
    });

    while (!queue.isEmpty()) {
        Vertex<V, E> vertex = queue.poll(); // ä»é˜Ÿåˆ—ä¸­å–èŠ‚ç‚¹
        list.add(vertex.value); // æ”¾å…¥è¿”å›ç»“æœä¸­

        for (Edge<V, E> outEdge : vertex.outEdges) {
            int in = ins.get(outEdge.to) - 1; // é˜Ÿåˆ—ä¸­å–å‡ºèŠ‚ç‚¹æ‰€é€šå‘èŠ‚ç‚¹çš„å…¥åº¦
            if (in == 0) queue.offer(outEdge.to);  // å…¥åº¦ä¸º0ï¼Œæ”¾å…¥é˜Ÿåˆ—
            else ins.put(outEdge.to, in); // å…¥åº¦ä¸ä¸º0ï¼Œç”¨mapè®°å½•å®ƒçš„å…¥åº¦
        }
    }
    return list;
}
```



### 7 æœ€å°ç”Ÿæˆæ ‘Minimum Spanning Tree

**ç”Ÿæˆæ ‘**ï¼ˆSpanning Treeï¼‰ï¼Œä¹Ÿç§°ä¸º**æ”¯æ’‘æ ‘**ï¼›

- è¿é€šå›¾çš„**æå°è¿é€šå­å›¾**ï¼Œå®ƒå«æœ‰å›¾ä¸­å…¨éƒ¨çš„ n ä¸ªé¡¶ç‚¹ï¼Œæ°å¥½åªæœ‰ n â€“ 1 æ¡è¾¹

![image-20221014133300354](02-æ‹ä¸Šæ•°æ®ç»“æ„-ç®—æ³•ç¯‡.assets/image-20221014133300354.png)

æœ€å°ç”Ÿæˆæ ‘ï¼ˆMinimum Spanning Treeï¼Œç®€ç§°MSTï¼‰

- ä¹Ÿç§°ä¸º**æœ€å°æƒé‡ç”Ÿæˆæ ‘**ï¼ˆMinimum Weight Spanning Treeï¼‰ã€**æœ€å°æ”¯æ’‘æ ‘**ï¼›
- æ˜¯æ‰€æœ‰ç”Ÿæˆæ ‘ä¸­ï¼Œ**æ€»æƒå€¼æœ€å°**çš„é‚£æ£µï¼›
- é€‚ç”¨äº**æœ‰æƒçš„è¿é€šå›¾**ï¼ˆæ— å‘ï¼‰ã€‚

![image-20221014133413486](02-æ‹ä¸Šæ•°æ®ç»“æ„-ç®—æ³•ç¯‡.assets/image-20221014133413486.png)

æœ€å°ç”Ÿæˆæ ‘åœ¨è®¸å¤šé¢†åŸŸéƒ½æœ‰é‡è¦çš„ä½œç”¨ï¼Œä¾‹å¦‚ï¼š

- è¦åœ¨ n ä¸ªåŸå¸‚ä¹‹é—´é“ºè®¾å…‰ç¼†ï¼Œä½¿å®ƒä»¬éƒ½å¯ä»¥é€šä¿¡
- é“ºè®¾å…‰ç¼†çš„è´¹ç”¨å¾ˆé«˜ï¼Œä¸”å„ä¸ªåŸå¸‚ä¹‹é—´å› ä¸ºè·ç¦»ä¸åŒç­‰å› ç´ ï¼Œé“ºè®¾å…‰ç¼†çš„è´¹ç”¨ä¹Ÿä¸åŒ
- å¦‚ä½•ä½¿é“ºè®¾å…‰ç¼†çš„æ€»è´¹ç”¨æœ€ä½ï¼Ÿâ€”â€” æœ€å°ç”Ÿæˆæ ‘çš„åº”ç”¨

**å¦‚æœå›¾çš„æ¯ä¸€æ¡è¾¹çš„æƒå€¼éƒ½äº’ä¸ç›¸åŒï¼Œé‚£ä¹ˆæœ€å°ç”Ÿæˆæ ‘å°†åªæœ‰ä¸€ä¸ªï¼Œå¦åˆ™å¯èƒ½ä¼šæœ‰å¤šä¸ªæœ€å°ç”Ÿæˆæ ‘**ã€‚

æ±‚æœ€å°ç”Ÿæˆæ ‘çš„2ä¸ªç»å…¸ç®—æ³•ï¼š

1. **Prim**ï¼ˆæ™®é‡Œå§†ç®—æ³•ï¼‰
2. **Kruskal**ï¼ˆå…‹é²æ–¯å¡å°”ç®—æ³•ï¼‰



#### 7.1 Primç®—æ³•

##### 7.1.1 åˆ‡åˆ†å®šç†

*åˆ‡åˆ†*ï¼š

- **æŠŠå›¾ä¸­çš„èŠ‚ç‚¹åˆ†ä¸ºä¸¤éƒ¨åˆ†ï¼Œç§°ä¸ºä¸€ä¸ªåˆ‡åˆ†**ã€‚

  ä¸‹å›¾æœ‰ä¸ªåˆ‡åˆ† C = (S, T)ï¼ŒS = { A, B, D }ï¼ŒT = { C, E }

  ![image-20221014134014194](02-æ‹ä¸Šæ•°æ®ç»“æ„-ç®—æ³•ç¯‡.assets/image-20221014134014194.png)

- *æ¨ªåˆ‡è¾¹ï¼ˆCrossing Edgeï¼‰*ï¼šå¦‚æœä¸€ä¸ªè¾¹çš„ä¸¤ä¸ªé¡¶ç‚¹ï¼Œåˆ†åˆ«å±äºåˆ‡åˆ†çš„ä¸¤éƒ¨åˆ†ï¼Œè¿™ä¸ªè¾¹ç§°ä¸º**æ¨ªåˆ‡è¾¹**ï¼Œ

  æ¯”å¦‚ä¸Šå›¾çš„è¾¹ BCã€BEã€DE å°±æ˜¯æ¨ªåˆ‡è¾¹

**åˆ‡åˆ†å®šç†**ï¼š**ç»™å®šä»»æ„åˆ‡åˆ†ï¼Œæ¨ªåˆ‡è¾¹ä¸­æƒå€¼æœ€å°çš„è¾¹å¿…ç„¶å±äºæœ€å°ç”Ÿæˆæ ‘**ã€‚



##### 7.1.2 Primç®—æ³•--æ‰§è¡Œè¿‡ç¨‹

å‡è®¾ G = (Vï¼ŒE) æ˜¯æœ‰æƒçš„è¿é€šå›¾ï¼ˆæ— å‘ï¼‰ï¼ŒA æ˜¯ G ä¸­æœ€å°ç”Ÿæˆæ ‘çš„è¾¹é›†

- ç®—æ³•ä» S = { u0 }ï¼ˆu0 âˆˆ Vï¼‰ï¼ŒA = { } å¼€å§‹ï¼Œé‡å¤æ‰§è¡Œä¸‹è¿°æ“ä½œï¼Œç›´åˆ° S = V ä¸ºæ­¢

  æ‰¾åˆ°åˆ‡åˆ† C = (Sï¼ŒV â€“ S) çš„æœ€å°æ¨ªåˆ‡è¾¹ (u0ï¼Œv0) å¹¶å…¥é›†åˆ Aï¼ŒåŒæ—¶å°† v0 å¹¶å…¥é›†åˆ S

![image-20221014134417840](02-æ‹ä¸Šæ•°æ®ç»“æ„-ç®—æ³•ç¯‡.assets/image-20221014134417840.png)

![image-20221014134422053](02-æ‹ä¸Šæ•°æ®ç»“æ„-ç®—æ³•ç¯‡.assets/image-20221014134422053.png)

![image-20221014134424536](02-æ‹ä¸Šæ•°æ®ç»“æ„-ç®—æ³•ç¯‡.assets/image-20221014134424536.png)

*ä»£ç å®ç°*ï¼š

åœ¨æ¥å£ä¸­å¢åŠ `EdgeInfo<V, E>`å†…éƒ¨ç±»ä¸`WeightManager<E>`å†…éƒ¨æ¥å£ã€‚

```java
protected WeightManager<E> weightManager;
public Graph(WeightManager<E> weightManager) {
    this.weightManager = weightManager;
}
public Graph() {}

//æƒå€¼ç®¡ç†å™¨ï¼šæœ‰å¤–é¢æä¾›å¯¹æƒå€¼çš„æ¯”è¾ƒã€åŠ æ³•å¤„ç†
public interface WeightManager<E> {
    int compare(E w1, E w2);
    E add(E w1, E w2);
    E zero();
}
//æä¾›å¤–é¢è®¿é—®çš„è¾¹çš„ä¿¡æ¯
public static class EdgeInfo<V, E>{
    private V from;
    private V to;
    private E weight;
    protected EdgeInfo(V from, V to, E weight) {
        this.from = from;
        this.to = to;
        this.weight = weight;
    }
    public V getFrom() {
        return from;
    }
    public void setFrom(V from) {
        this.from = from;
    }
    public V getTo() {
        return to;
    }
    public void setTo(V to) {
        this.to = to;
    }
    public E getWeight() {
        return weight;
    }
    public void setWeight(E weight) {
        this.weight = weight;
    }
    @Override
    public String toString() {
        return "EdgeInfo{" +
                "from=" + from +
                ", to=" + to +
                ", weight=" + weight +
                '}';
    }
}
```

```java
private Comparator<Edge<V, E>> edgeComparator = (Edge<V, E> e1, Edge<V, E> e2) -> {
    return weightManager.compare(e1.weight, e2.weight);
};
public ListGraph(WeightManager<E> weightManager) {
    super(weightManager);
}
public ListGraph() {}

// è¾¹
private static class Edge<V, E> {
    ......
    EdgeInfo<V, E> info(){
        return new EdgeInfo<>(from.value, to.value, weight);
    }
    ......
}

/**
 * æœ€å°ç”Ÿæˆæ ‘ï¼šprimç®—æ³•
 * @return
 */
private Set<EdgeInfo<V, E>> mst_prim() {
    Iterator<Vertex<V, E>> it = vertices.values().iterator();
    if (!it.hasNext()) return null;
    Vertex<V, E> vertex = it.next(); // éšæœºå–å‡ºä¸€ä¸ªé¡¶ç‚¹
    Set<EdgeInfo<V, E>> edgeInfos = new HashSet<>();
    Set<Vertex<V, E>> addedVertices = new HashSet<>(); // æ ‡è®°å·²ç»æ·»åŠ çš„é¡¶ç‚¹
    addedVertices.add(vertex);

    // å°é¡¶äºŒå‰å †ï¼Œæ¯æ¬¡è·å–æƒå€¼æœ€å°çš„è¾¹
    MinHeap<Edge<V, E>> heap = new MinHeap<>(vertex.outEdges, edgeComparator);

    while (!heap.isEmpty() && verticsSize() > addedVertices.size()) {
        Edge<V, E> edge = heap.remove();
        if (addedVertices.contains(edge.to)) continue;
        edgeInfos.add(edge.info());
        addedVertices.add(edge.to);
        heap.addAll(edge.to.outEdges);
    }
    return edgeInfos;
}
```



#### 7.2 Kruskalç®—æ³•

*Kruskalç®—æ³•--æ‰§è¡Œè¿‡ç¨‹*ï¼š

æŒ‰ç…§è¾¹çš„æƒé‡é¡ºåºï¼ˆä»å°åˆ°å¤§ï¼‰å°†è¾¹åŠ å…¥ç”Ÿæˆæ ‘ä¸­ï¼Œç›´åˆ°ç”Ÿæˆæ ‘ä¸­å«æœ‰ Vâ€“1 æ¡è¾¹ä¸ºæ­¢ï¼ˆ V æ˜¯é¡¶ç‚¹æ•°é‡ï¼‰

- è‹¥åŠ å…¥è¯¥è¾¹ä¼šä¸ç”Ÿæˆæ ‘å½¢æˆç¯ï¼Œåˆ™ä¸åŠ å…¥è¯¥è¾¹
- ä»ç¬¬ 3 æ¡è¾¹å¼€å§‹ï¼Œå¯èƒ½ä¼šä¸ç”Ÿæˆæ ‘å½¢æˆç¯

![image-20221014140319868](02-æ‹ä¸Šæ•°æ®ç»“æ„-ç®—æ³•ç¯‡.assets/image-20221014140319868.png)

![image-20221014140322178](02-æ‹ä¸Šæ•°æ®ç»“æ„-ç®—æ³•ç¯‡.assets/image-20221014140322178.png)

![image-20221014140325753](02-æ‹ä¸Šæ•°æ®ç»“æ„-ç®—æ³•ç¯‡.assets/image-20221014140325753.png)

*ä»£ç å®ç°*ï¼š

```java
/**
 * æœ€å°ç”Ÿæˆæ ‘ï¼škruskalç®—æ³•
 * @return
 */
private Set<EdgeInfo<V, E>> mst_kruskal(){
    int edgeSize = verticsSize() - 1;
    if (edgeSize < 2) return null;

    // ç»“æœé›†
    Set<EdgeInfo<V, E>> edgeInfos = new HashSet<>();
    // å°†æ‰€æœ‰è¾¹çš„ä¿¡æ¯æ”¾å…¥å°é¡¶å †å½“ä¸­
    MinHeap<Edge<V,E>> heap = new MinHeap<>(edges, edgeComparator);

    // å¹¶æŸ¥é›†ï¼šç”¨äºç¯çš„åˆ¤æ–­ï¼Œä»£ç åº”ç”¨çš„æ˜¯è‡ªå®šä¹‰ç±»å‹å¹¶æŸ¥é›†
    // å°†æ‰€æœ‰çš„é¡¶ç‚¹æ”¾å…¥å¹¶æŸ¥é›†å½“ä¸­
    GenericUnionFind<Vertex<V, E>> unionFind = new GenericUnionFind<>(vertices.values());

    while (!heap.isEmpty() && edgeInfos.size() < edgeSize) {
        Edge<V, E> edge = heap.remove();
        if (unionFind.isSame(edge.from, edge.to)) continue;
        edgeInfos.add(edge.info());
        unionFind.union(edge.from, edge.to);
    }
    return edgeInfos;
}
```



### 8 æœ€çŸ­è·¯å¾„Shortest Path

**æœ€çŸ­è·¯å¾„**æ˜¯æŒ‡ä¸¤é¡¶ç‚¹ä¹‹é—´æƒå€¼ä¹‹å’Œæœ€å°çš„è·¯å¾„ï¼ˆ**æœ‰å‘å›¾ã€æ— å‘å›¾å‡é€‚ç”¨ï¼Œä¸èƒ½æœ‰è´Ÿæƒç¯**ï¼‰

*æœ‰å‘å›¾*ï¼š

![image-20221014141624468](02-æ‹ä¸Šæ•°æ®ç»“æ„-ç®—æ³•ç¯‡.assets/image-20221014141624468.png)

*æ— å‘å›¾*ï¼š

![image-20221014141629899](02-æ‹ä¸Šæ•°æ®ç»“æ„-ç®—æ³•ç¯‡.assets/image-20221014141629899.png)

æœ€çŸ­è·¯å¾„çš„å…¸å‹åº”ç”¨ä¹‹ä¸€ï¼š**è·¯å¾„è§„åˆ’é—®é¢˜**ï¼›

æ±‚è§£æœ€çŸ­è·¯å¾„çš„3ä¸ªç»å…¸ç®—æ³•ï¼š

- å•æºæœ€çŸ­è·¯å¾„ç®—æ³•
  - Dijkstraï¼ˆè¿ªæ°æ–¯ç‰¹æ‹‰ç®—æ³•ï¼‰
  - Bellman-Fordï¼ˆè´å°”æ›¼-ç¦ç‰¹ç®—æ³•ï¼‰
- å¤šæºæœ€çŸ­è·¯å¾„ç®—æ³•
  - Floydï¼ˆå¼—æ´›ä¼Šå¾·ç®—æ³•ï¼‰



#### 8.1 æœ€çŸ­è·¯å¾„--æ¦‚å¿µ

*æ— æƒå›¾*ï¼š**æ— æƒå›¾**ç›¸å½“äºæ˜¯**å…¨éƒ¨è¾¹æƒå€¼ä¸º1çš„æœ‰æƒå›¾**ï¼›

![image-20221014142017041](02-æ‹ä¸Šæ•°æ®ç»“æ„-ç®—æ³•ç¯‡.assets/image-20221014142017041.png)



*è´Ÿæƒè¾¹*ï¼šæœ‰è´Ÿæƒè¾¹ï¼Œä½†æ²¡æœ‰è´Ÿæƒç¯æ—¶ï¼Œå­˜åœ¨æœ€çŸ­è·¯å¾„

![image-20221014142023361](02-æ‹ä¸Šæ•°æ®ç»“æ„-ç®—æ³•ç¯‡.assets/image-20221014142023361.png)

Aåˆ°Eçš„æœ€çŸ­è·¯å¾„æ˜¯ï¼šA â†’ B â†’ E



*è´Ÿæƒç¯*ï¼šæœ‰è´Ÿæƒç¯æ—¶ï¼Œä¸å­˜åœ¨æœ€çŸ­è·¯å¾„

![image-20221014142149320](02-æ‹ä¸Šæ•°æ®ç»“æ„-ç®—æ³•ç¯‡.assets/image-20221014142149320.png)

é€šè¿‡è´Ÿæƒç¯ï¼ŒAåˆ°Eçš„è·¯å¾„å¯ä»¥æ— é™çŸ­

A â†’ E <font color="red">â†’ D â†’ F â†’ E</font> <font color="gree">â†’ D â†’ F â†’ E</font> <font color="red">â†’ D â†’ F â†’ E</font> <font color="gree">â†’ D â†’ F â†’ E</font> â†’ â€¦



#### 8.2 Dijkstraç®—æ³•

Dijkstra å±äºå•æºæœ€çŸ­è·¯å¾„ç®—æ³•ï¼Œç”¨äºè®¡ç®—**ä¸€ä¸ªé¡¶ç‚¹åˆ°å…¶ä»–æ‰€æœ‰é¡¶ç‚¹çš„æœ€çŸ­è·¯å¾„**ï¼›

- ä½¿ç”¨å‰æï¼šä¸èƒ½æœ‰**è´Ÿæƒè¾¹**ï¼›
- æ—¶é—´å¤æ‚åº¦ï¼šå¯ä¼˜åŒ–è‡³`O(ElogV)`ï¼ŒE æ˜¯è¾¹æ•°é‡ï¼ŒV æ˜¯èŠ‚ç‚¹æ•°é‡
- ç”±è·å…°çš„ç§‘å­¦å®¶ Edsger Wybe Dijkstra å‘æ˜ï¼Œæ›¾åœ¨1972å¹´è·å¾—å›¾çµå¥–



##### 8.2.1 Dijkstraç®—æ³•åˆ†æ

*Dijkstraç­‰ä»·æ€è€ƒ*ï¼š

![image-20221014142728513](02-æ‹ä¸Šæ•°æ®ç»“æ„-ç®—æ³•ç¯‡.assets/image-20221014142728513.png)



*Dijkstra--æ‰§è¡Œè¿‡ç¨‹*ï¼š

![image-20221014142950181](02-æ‹ä¸Šæ•°æ®ç»“æ„-ç®—æ³•ç¯‡.assets/image-20221014142950181.png)

![image-20221014142952171](02-æ‹ä¸Šæ•°æ®ç»“æ„-ç®—æ³•ç¯‡.assets/image-20221014142952171.png)

æ¾å¼›æ“ä½œï¼ˆRelaxationï¼‰ï¼šæ›´æ–°2ä¸ªé¡¶ç‚¹ä¹‹é—´çš„æœ€çŸ­è·¯å¾„

- è¿™é‡Œä¸€èˆ¬æ˜¯æŒ‡ï¼šæ›´æ–°æºç‚¹åˆ°å¦ä¸€ä¸ªç‚¹çš„æœ€çŸ­è·¯å¾„
- æ¾å¼›æ“ä½œçš„æ„ä¹‰ï¼šå°è¯•æ‰¾å‡ºæ›´çŸ­çš„æœ€çŸ­è·¯å¾„

ç¡®å®šAåˆ°Dçš„æœ€çŸ­è·¯å¾„åï¼Œå¯¹DCã€DEè¾¹è¿›è¡Œæ¾å¼›æ“ä½œï¼Œæ›´æ–°äº†Aåˆ°Cã€Aåˆ°Eçš„æœ€çŸ­è·¯å¾„

![image-20221014143231188](02-æ‹ä¸Šæ•°æ®ç»“æ„-ç®—æ³•ç¯‡.assets/image-20221014143231188.png)



##### 8.2.2 Dijkstra--ä»£ç å®ç°ç‰ˆæœ¬1

å®ç°ç‰ˆæœ¬1ï¼šåªè¿”å›æ¯æ¡æœ€çŸ­è·¯å¾„çš„æ€»æƒå€¼

```java
/**
 * å•æºæœ€çŸ­è·¯å¾„ï¼šDijkstraå®ç°ï¼Œè¿ªæ°æ–¯ç‰¹æ‹‰ç®—æ³•å®ç°
 * @param begin
 * @return
 */
public Map<V, E> shortestPath(V begin) {
    Vertex<V, E> vertex = vertices.get(begin); // æºç‚¹
    if (vertex == null) return null;

    Map<V, E> selectedPaths = new HashMap<>(); // æœ€ç»ˆçš„æœ€çŸ­è·¯å¾„
    Map<Vertex<V, E>, E> paths = new HashMap<>(); // å½“å‰æœ€çŸ­è·¯å¾„
    //åˆå§‹åŒ–paths
    for (Edge<V, E> outEdge : vertex.outEdges) {
        paths.put(outEdge.to, outEdge.weight);
    }

    while (!paths.isEmpty()){
        // æŒ‘é€‰å‡ºå½“å‰æœ€çŸ­è·¯å¾„ä¸­æœ€çŸ­çš„ç‚¹
        Map.Entry<Vertex<V, E>, E> minEntry = getShortestPath11(paths);
        // minVertexç¦»å¼€æ¡Œé¢ï¼Œè¢«ç¡®å®šä¸ºæœ€ç»ˆçš„æœ€çŸ­è·¯å¾„
        Vertex<V, E> minVertex = minEntry.getKey();
        E minPath = minEntry.getValue();
        selectedPaths.put(minVertex.value, minPath);
        paths.remove(minVertex);
        // å¯¹å®ƒçš„ minVertex çš„ outEdges è¿›è¡Œæ¾å¼›æ“ä½œ
        for (Edge<V, E> edge : minVertex.outEdges) {
            // å¦‚æœedge.toå·²ç»ç¦»å¼€æ¡Œé¢ï¼Œå°±æ²¡å¿…è¦è¿›è¡Œæ¾å¼›æ“ä½œ
            if (selectedPaths.containsKey(edge.to.value)) continue;
            // æ–°çš„å¯é€‰æ‹©çš„æœ€çŸ­è·¯å¾„ï¼šbeginVertexåˆ°edge.fromçš„æœ€çŸ­è·¯å¾„ + edge.weight
            E newWeight = weightManager.add(minPath, edge.weight);
            // ä»¥å‰çš„æœ€çŸ­è·¯å¾„ï¼šbeginVertexåˆ°edge.toçš„æœ€çŸ­è·¯å¾„
            E oldWeight = paths.get(edge.to);
            if (oldWeight == null || weightManager.compare(newWeight, oldWeight) < 0) {
                paths.put(edge.to, newWeight);
            }
        }
    }
    selectedPaths.remove(vertex);
    return selectedPaths;
}

/**
 * ä»pathsä¸­æŒ‘ä¸€ä¸ªæœ€å°çš„è·¯å¾„å‡ºæ¥
 * @param paths
 * @return
 */
private Map.Entry<Vertex<V, E>, E> getShortestPath11(Map<Vertex<V, E>, E> paths){
    Iterator<Map.Entry<Vertex<V, E>, E>> iterator = paths.entrySet().iterator();
    Map.Entry<Vertex<V, E>, E> minEntry = iterator.next();
    while (iterator.hasNext()){
        Map.Entry<Vertex<V, E>, E> entry = iterator.next();
        if (weightManager.compare(entry.getValue(), minEntry.getValue()) < 0) {
            minEntry = entry;
        }
    }
    return minEntry;
}
```



##### 8.2.3 Dijkstra--ä»£ç å®ç°ç‰ˆæœ¬2

å®ç°ç‰ˆæœ¬2ï¼šè¿”å›æœ€çŸ­è·¯å¾„çš„æ€»æƒå€¼å’Œè¾¹ä¿¡æ¯

*æŠ½è±¡ç±»Graph.java*ï¼š

æŠ½è±¡ç±»Graph.javaï¼šä¿®æ”¹äº†`shortestPath`æ–¹æ³•æ¥å£ï¼Œå¢åŠ äº† `PathInfo` å†…éƒ¨ç±»ã€‚

```java
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Set;

/**
 * @description:
 * @author: xu
 * @date: 2022/10/5 20:20
 */
public abstract class Graph<V, E> {
    protected WeightManager<E> weightManager;
    public Graph(WeightManager<E> weightManager) {
        this.weightManager = weightManager;
    }
    public Graph() {}

    //è·å–é¡¶ç‚¹ã€è¾¹çš„æ•°é‡
    public abstract int edgesSize();
    public abstract int verticsSize();

    //æ·»åŠ æ–°çš„é¡¶ç‚¹ã€è¾¹
    public abstract void addVertex(V v);
    public abstract void addEdge(V from, V to);
    public abstract void addEdge(V from, V to, E weight);

    //åˆ é™¤é¡¶ç‚¹ã€è¾¹
    public abstract void removeVertex(V v);
    public abstract void removeEdge(V from, V to);

    //éå†å›¾ï¼š
    //bfsï¼šå¹¿åº¦ä¼˜å…ˆéå†ï¼›dfsï¼šæ·±åº¦ä¼˜å…ˆéå†
    public abstract void bfs(V begin, VertexVisitor<V> visitor);
    public abstract void dfs(V begin, VertexVisitor<V> visitor);
    public abstract void dfs1(V begin, VertexVisitor<V> visitor);

    //æ‹“æ‰‘æ’åºï¼šå¡æ©ç®—æ³•
    public abstract List<V> topologicalSort();

    //æœ€å°ç”Ÿæˆæ ‘
    //primï¼šæ™®åˆ©å§†ç®—æ³•
    //kruskalï¼šå…‹é²æ–¯å¡å°”ç®—æ³•
    public abstract Set<EdgeInfo<V, E>> mst();

    //æœ€çŸ­è·¯å¾„
    //public abstract Map<V, E> shortestPath1(V begin);
    public abstract Map<V, PathInfo<V, E>> shortestPath(V begin);

    //è®¿é—®å™¨ï¼šæœ‰å¤–é¢æä¾›å®šä¹‰çš„èŠ‚ç‚¹è®¿é—®
    public interface VertexVisitor<V> {
        boolean visit(V v);
    }
    //æƒå€¼ç®¡ç†å™¨ï¼šæœ‰å¤–é¢æä¾›å¯¹æƒå€¼çš„æ¯”è¾ƒã€åŠ æ³•å¤„ç†
    public interface WeightManager<E> {
        int compare(E w1, E w2);
        E add(E w1, E w2);
        E zero();
    }
    //æä¾›å¤–é¢è®¿é—®çš„è¾¹çš„ä¿¡æ¯
    public static class EdgeInfo<V, E>{
        private V from;
        private V to;
        private E weight;
        protected EdgeInfo(V from, V to, E weight) {
            this.from = from;
            this.to = to;
            this.weight = weight;
        }
        public V getFrom() {
            return from;
        }
        public void setFrom(V from) {
            this.from = from;
        }
        public V getTo() {
            return to;
        }
        public void setTo(V to) {
            this.to = to;
        }
        public E getWeight() {
            return weight;
        }
        public void setWeight(E weight) {
            this.weight = weight;
        }
        @Override
        public String toString() {
            return "EdgeInfo{" +
                    "from=" + from +
                    ", to=" + to +
                    ", weight=" + weight +
                    '}';
        }
    }
    public static class PathInfo<V, E>{
        protected E weight;
        protected List<EdgeInfo<V, E>> edgeInfos = new LinkedList<>();
        public E getWeight() {
            return weight;
        }
        public void setWeight(E weight) {
            this.weight = weight;
        }
        public List<EdgeInfo<V, E>> getEdgeInfos() {
            return edgeInfos;
        }
        public void setEdgeInfos(List<EdgeInfo<V, E>> edgeInfos) {
            this.edgeInfos = edgeInfos;
        }

        @Override
        public String toString() {
            return "PathInfo{" +
                    "weight=" + weight +
                    ", edgeInfos=" + edgeInfos +
                    '}';
        }
    }
}
```

dijkstraå®ç°ï¼šå°è£…äº†relaxæ¾å¼›æ“ä½œ

```java
/**
 * å•æºæœ€çŸ­è·¯å¾„
 * @param begin
 * @return
 */
@Override
public Map<V, PathInfo<V, E>> shortestPath(V begin) {
    return dijkstra(begin);
}

/**
 * å•æºæœ€çŸ­è·¯å¾„ï¼šDijkstraï¼Œè¿ªæ°æ–¯ç‰¹æ‹‰ç®—æ³•å®ç°
 * @param begin
 * @return
 */
private Map<V, PathInfo<V, E>> dijkstra(V begin) {
    Vertex<V, E> beginVertex = vertices.get(begin);
    if (beginVertex == null) return null;

    Map<V, PathInfo<V, E>> selectedPaths = new HashMap<>(); // æœ€ç»ˆçš„æœ€çŸ­è·¯å¾„
    Map<Vertex<V, E>, PathInfo<V, E>> paths = new HashMap<>(); // å½“å‰çš„æœ€çŸ­è·¯å¾„
    // åˆå§‹åŒ–æºç‚¹çš„æœ€çŸ­è·¯å¾„ä¿¡æ¯
    paths.put(beginVertex, new PathInfo<>(weightManager.zero()));
    //åˆå§‹åŒ–paths 
    //for (Edge<V, E> outEdge : beginVertex.outEdges) {
    //    PathInfo<V, E> pathInfo = new PathInfo<>();
    //    pathInfo.setWeight(outEdge.weight);
    //    pathInfo.edgeInfos.add(outEdge.info());
    //    paths.put(outEdge.to, pathInfo);
    //}

    while (!paths.isEmpty()) {
        // æŒ‘é€‰å‡ºå½“å‰æœ€çŸ­è·¯å¾„ä¸­æœ€çŸ­çš„ç‚¹
        Map.Entry<Vertex<V, E>, PathInfo<V, E>> minEntry = getShortestPath(paths);
        // minVertexç¦»å¼€æ¡Œé¢
        Vertex<V, E> minVertex = minEntry.getKey();
        PathInfo<V, E> minPath = minEntry.getValue();
        selectedPaths.put(minVertex.value, minPath);
        paths.remove(minVertex);
        // å¯¹å®ƒçš„ minVertex çš„ outEdges è¿›è¡Œæ¾å¼›æ“ä½œ
        for (Edge<V, E> edge : minVertex.outEdges) {
            // å¦‚æœedge.toå·²ç»ç¦»å¼€æ¡Œé¢ï¼Œå°±æ²¡å¿…è¦è¿›è¡Œæ¾å¼›æ“ä½œ
            if (selectedPaths.containsKey(edge.to.value)) continue;
            relaxForDijkstra(edge, minPath, paths);
        }
    }
    selectedPaths.remove(begin);
    return selectedPaths;
}
/**
 * ä»pathsä¸­æŒ‘ä¸€ä¸ªæœ€å°çš„è·¯å¾„å‡ºæ¥ï¼ˆéå†ï¼‰
 * @param paths
 * @return
 */
private Map.Entry<Vertex<V, E>, PathInfo<V, E>> getShortestPath(Map<Vertex<V, E>, PathInfo<V, E>> paths){
    Iterator<Map.Entry<Vertex<V, E>, PathInfo<V, E>>> iterator = paths.entrySet().iterator();
    Map.Entry<Vertex<V, E>, PathInfo<V, E>> minEntry = iterator.next();
    while (iterator.hasNext()){
        Map.Entry<Vertex<V, E>, PathInfo<V, E>> entry = iterator.next();
        if (weightManager.compare(entry.getValue().weight, minEntry.getValue().weight) < 0) {
            minEntry = entry;
        }
    }
    return minEntry;
}
/**
 * æ¾å¼›æ“ä½œ -- Dijkstra
 * @param edge éœ€è¦è¿›è¡Œæ¾å¼›çš„è¾¹
 * @param fromPath edgeçš„fromçš„æœ€çŸ­è·¯å¾„ä¿¡æ¯
 * @param paths å­˜æ”¾ç€å…¶ä»–ç‚¹ï¼ˆå¯¹äºdijkstraæ¥è¯´ï¼Œè¿˜æ²¡æœ‰ç¦»å¼€æ¡Œé¢çš„ç‚¹ï¼‰çš„æœ€çŸ­è·¯å¾„ä¿¡æ¯
 */
private void relaxForDijkstra(Edge<V, E> edge, PathInfo<V, E> fromPath, Map<Vertex<V, E>, PathInfo<V, E>> paths){
    // æ–°çš„å¯é€‰æ‹©çš„æœ€çŸ­è·¯å¾„ï¼šbeginVertexåˆ°edge.fromçš„æœ€çŸ­è·¯å¾„ + edge.weight
    E newWeight = weightManager.add(fromPath.weight, edge.weight);
    // ä»¥å‰çš„æœ€çŸ­è·¯å¾„ï¼šbeginVertexåˆ°edge.toçš„æœ€çŸ­è·¯å¾„
    PathInfo<V, E> oldPath = paths.get(edge.to);

    if (oldPath != null && weightManager.compare(newWeight, oldPath.weight) >= 0) return;

    if (oldPath == null) { // æ–°åˆ›å»ºçš„è¾¹
        oldPath = new PathInfo<>();
        paths.put(edge.to, oldPath);
    } else { // ä»¥å‰å°±å­˜åœ¨çš„è¾¹
        oldPath.edgeInfos.clear();
    }
    oldPath.setWeight(newWeight);
    oldPath.edgeInfos.addAll(fromPath.edgeInfos);
    oldPath.edgeInfos.add(edge.info());
}
```



#### 8.3 Bellman-Fordç®—æ³•

Bellman-Ford ä¹Ÿå±äº**å•æºæœ€çŸ­è·¯å¾„ç®—æ³•**ï¼Œ**æ”¯æŒè´Ÿæƒè¾¹**ï¼Œè¿˜**èƒ½æ£€æµ‹å‡ºæ˜¯å¦æœ‰è´Ÿæƒç¯**ï¼›

- ç®—æ³•åŸç†ï¼šå¯¹æ‰€æœ‰çš„è¾¹è¿›è¡Œ`Vâ€“1`æ¬¡**æ¾å¼›æ“ä½œ**ï¼ˆ`V`æ˜¯èŠ‚ç‚¹æ•°é‡ï¼‰ï¼Œ**å¾—åˆ°æ‰€æœ‰å¯èƒ½çš„æœ€çŸ­è·¯å¾„**ï¼›
- æ—¶é—´å¤æ‚åº¦ï¼šO(EV)ï¼ŒE æ˜¯è¾¹æ•°é‡ï¼ŒV æ˜¯èŠ‚ç‚¹æ•°é‡ã€‚

ä¸‹å›¾çš„**æœ€å¥½æƒ…å†µ**æ˜¯æ°å¥½**ä»å·¦åˆ°å³**çš„é¡ºåºå¯¹è¾¹è¿›è¡Œæ¾å¼›æ“ä½œï¼š

- å¯¹æ‰€æœ‰è¾¹ä»…éœ€è¿›è¡Œ 1 æ¬¡æ¾å¼›æ“ä½œå°±èƒ½è®¡ç®—å‡ºAåˆ°è¾¾å…¶ä»–æ‰€æœ‰é¡¶ç‚¹çš„æœ€çŸ­è·¯å¾„


![image-20221015152456804](02-æ‹ä¸Šæ•°æ®ç»“æ„-ç®—æ³•ç¯‡.assets/image-20221015152456804.png)

**æœ€åæƒ…å†µ**æ˜¯æ°å¥½æ¯æ¬¡éƒ½**ä»å³åˆ°å·¦**çš„é¡ºåºå¯¹è¾¹è¿›è¡Œæ¾å¼›æ“ä½œï¼š

- å¯¹æ‰€æœ‰è¾¹éœ€è¿›è¡Œ `Vâ€“1` æ¬¡æ¾å¼›æ“ä½œæ‰èƒ½è®¡ç®—å‡ºAåˆ°è¾¾å…¶ä»–æ‰€æœ‰é¡¶ç‚¹çš„æœ€çŸ­è·¯å¾„

![image-20221015152637134](02-æ‹ä¸Šæ•°æ®ç»“æ„-ç®—æ³•ç¯‡.assets/image-20221015152637134.png)



*Bellman-Fordå®ä¾‹*ï¼š

![image-20221015152850278](02-æ‹ä¸Šæ•°æ®ç»“æ„-ç®—æ³•ç¯‡.assets/image-20221015152850278.png)

![image-20221015152852811](02-æ‹ä¸Šæ•°æ®ç»“æ„-ç®—æ³•ç¯‡.assets/image-20221015152852811.png)

![image-20221015152854859](02-æ‹ä¸Šæ•°æ®ç»“æ„-ç®—æ³•ç¯‡.assets/image-20221015152854859.png)

**Bellman-Fordä»£ç å®ç°**ï¼š

```java
/**
 * å•æºæœ€çŸ­è·¯å¾„ï¼šBellman-Fordï¼Œè´å°”æ›¼-ç¦ç‰¹ç®—æ³•å®ç°
 * @param begin
 * @return
 */
private Map<V, PathInfo<V, E>> bellmanFord(V begin) {
    Vertex<V, E> beginVertex = vertices.get(begin); // æºç‚¹
    if (beginVertex == null) return null;
	// å­˜æ”¾å½“å‰æœ€çŸ­è·¯å¾„ä¿¡æ¯ï¼ˆä¸æ–­çš„è¿›è¡Œæ¾å¼›æ“ä½œ, ä¼šå˜æˆæœ€ç»ˆçš„æœ€çŸ­è·¯å¾„ï¼‰
    Map<V, PathInfo<V, E>> selectedPaths = new HashMap<>();
    // åˆå§‹åŒ–æºç‚¹çš„æœ€çŸ­è·¯å¾„ä¿¡æ¯
    selectedPaths.put(begin, new PathInfo<>(weightManager.zero()));

    int count = verticsSize() - 1; // è¿›è¡Œ V -1 æ¬¡æ¾å¼›æ“ä½œ, å¿…ç„¶èƒ½æ‰¾åˆ°æœ€çŸ­è·¯å¾„
    for (int i = 0; i < count; i++) {
        for (Edge<V, E> edge : edges) { // å¯¹æ‰€æœ‰è¾¹è¿›è¡Œæ¾å¼›æ“ä½œ
            // è·å–è¯¥è¾¹çš„å§‹ç‚¹çš„æœ€çŸ­è·¯å¾„ä¿¡æ¯, ç”¨äºåé¢è¿›è¡Œæ¾å¼›æ“ä½œ
            PathInfo<V, E> fromPath = selectedPaths.get(edge.from.value);
            // å¦‚æœè¯¥ç‚¹çš„å§‹ç‚¹æ²¡æœ‰æœ€çŸ­è·¯å¾„ä¿¡æ¯,æ¾å¼›å¿…ç„¶å¤±è´¥,ç›´æ¥è¿›å…¥ä¸‹ä¸€è½®
            if (fromPath == null) continue;
            // æ¾å¼›æ“ä½œ
            relaxForBellmanFord(edge, fromPath, selectedPaths);
        }
    }

    // æ£€æµ‹è´Ÿæƒç¯, å‰é¢å·²ç»æ¾å¼›äº†V-1æ¬¡,è¿™é‡Œå¦‚æœæ¾å¼›ç¬¬ V æ¬¡ä»ç„¶å¯ä»¥æˆåŠŸ, è¯´æ˜æœ‰è´Ÿæƒç¯
    for (Edge<V, E> edge : edges) {
        PathInfo<V, E> fromPath = selectedPaths.get(edge.from.value);
        if (fromPath == null) continue;
        if (relaxForBellmanFord(edge, fromPath, selectedPaths)) {
            throw new RuntimeException("æœ‰è´Ÿæƒç¯ï¼Œæ— æœ€çŸ­è·¯å¾„");
        }
    }
    selectedPaths.remove(begin);
    return selectedPaths;
}
/**
 * æ¾å¼›æ“ä½œ -- BellmanFord
 * @param edge éœ€è¦è¿›è¡Œæ¾å¼›çš„è¾¹
 * @param fromPath edgeçš„fromçš„æœ€çŸ­è·¯å¾„ä¿¡æ¯
 * @param paths å­˜æ”¾ç€å…¶ä»–ç‚¹ï¼ˆå¯¹äºdijkstraæ¥è¯´ï¼Œè¿˜æ²¡æœ‰ç¦»å¼€æ¡Œé¢çš„ç‚¹ï¼‰çš„æœ€çŸ­è·¯å¾„ä¿¡æ¯
 */
private boolean relaxForBellmanFord(Edge<V, E> edge, PathInfo<V, E> fromPath, Map<V, PathInfo<V, E>> paths){
    // æ–°çš„å¯é€‰æ‹©çš„æœ€çŸ­è·¯å¾„ï¼šbeginVertexåˆ°edge.fromçš„æœ€çŸ­è·¯å¾„ + edge.weight
    E newWeight = weightManager.add(fromPath.weight, edge.weight);
    // ä»¥å‰çš„æœ€çŸ­è·¯å¾„ï¼šbeginVertexåˆ°edge.toçš„æœ€çŸ­è·¯å¾„
    PathInfo<V, E> oldPath = paths.get(edge.to.value);

    if (oldPath != null && weightManager.compare(newWeight, oldPath.weight) >= 0) return false;

    if (oldPath == null) {
        oldPath = new PathInfo<>();
        paths.put(edge.to.value, oldPath);
    } else {
        oldPath.edgeInfos.clear();
    }
    oldPath.setWeight(newWeight);
    oldPath.edgeInfos.addAll(fromPath.edgeInfos);
    oldPath.edgeInfos.add(edge.info());
    return true;
}
```



#### 8.4 Floydç®—æ³•

Floyd å±äº**å¤šæºæœ€çŸ­è·¯å¾„**ç®—æ³•ï¼Œ**èƒ½å¤Ÿæ±‚å‡ºä»»æ„2ä¸ªé¡¶ç‚¹ä¹‹é—´çš„æœ€çŸ­è·¯å¾„**ï¼Œ**æ”¯æŒè´Ÿæƒè¾¹**ï¼›

- æ—¶é—´å¤æ‚åº¦ï¼šO(V<sup>3</sup>)ï¼Œæ•ˆç‡æ¯”æ‰§è¡Œ V æ¬¡ Dijkstra ç®—æ³•è¦å¥½ï¼ˆVæ˜¯é¡¶ç‚¹æ•°é‡ï¼‰

æ³¨ï¼š**å•æºæœ€çŸ­è·¯å¾„ç®—æ³•å¯¹æ¯ä¸ªé¡¶ç‚¹æ±‚ä¸€æ¬¡**ï¼ŒåŒæ ·**å¯ä»¥æ±‚å‡ºä»»æ„2ä¸ªé¡¶ç‚¹ä¹‹é—´çš„æœ€çŸ­è·¯å¾„**ï¼›

ç®—æ³•åŸç†ï¼š

- ä»ä»»æ„é¡¶ç‚¹ `i` åˆ°ä»»æ„é¡¶ç‚¹ `j` çš„æœ€çŸ­è·¯å¾„ä¸å¤–ä¹ä¸¤ç§å¯èƒ½

  1. ç›´æ¥ä» `i` åˆ° `j`
  2. ä» `i` ç»è¿‡è‹¥å¹²ä¸ªé¡¶ç‚¹åˆ° `j`

- å‡è®¾ `dist(i, j)` ä¸ºé¡¶ç‚¹ `i` åˆ°é¡¶ç‚¹ `j` çš„æœ€çŸ­è·¯å¾„çš„è·ç¦»

- å¯¹äºæ¯ä¸€ä¸ªé¡¶ç‚¹ `k`ï¼Œæ£€æŸ¥ `dist(i, k)` + `dist(k, j)` < `dist(i, j)` æ˜¯å¦æˆç«‹

  å¦‚æœæˆç«‹ï¼Œè¯æ˜ä» `i` åˆ° `k` å†åˆ° `j` çš„è·¯å¾„æ¯” `i`ç›´æ¥åˆ° `j` çš„è·¯å¾„çŸ­ï¼Œ

  è®¾ç½® `dist(i, j)` = `dist(i, k)` + `dist(k, j)`ï¼›

- å½“æˆ‘ä»¬éå†å®Œæ‰€æœ‰ç»“ç‚¹ `k`ï¼Œ`dist(i, j)` ä¸­è®°å½•çš„ä¾¿æ˜¯ `i` åˆ° `j` çš„æœ€çŸ­è·¯å¾„çš„è·ç¦»

ç®—æ³•åŸç†ä¼ªä»£ç ï¼š

```java
for(int k = 0; k < V; k++){
    for(int i = 0; i < V; i++){
        for(int j = 0; j < V; j++){
            if(dist(i,k) + dist(k,j) < dist(i,j)){
                dist(i,j) = dist(i,k) + dist(k,j);
            }
        }
    }
}
```



*Floydç®—æ³•å®ç°*ï¼š

Graph.javaæŠ½è±¡ç±»ä¸­ï¼š

```java
public abstract Map<V, Map<V, PathInfo<V, E>>> shortestPaths(); // å¤šæºæœ€çŸ­è·¯å¾„
```

ListGraph.javaç±»ä¸­ï¼š

```java
/**
 * å¤šæºæœ€çŸ­è·¯å¾„
 * @return
 */
@Override
public Map<V, Map<V, PathInfo<V, E>>> shortestPaths() {
    return floyd();
}
/**
 * å¤šæºæœ€çŸ­è·¯å¾„ï¼šfloydï¼Œå¼—æ´›ä¼Šå¾·ç®—æ³•å®ç°
 * @return
 */
private Map<V, Map<V, PathInfo<V, E>>> floyd(){
    // æœ€ç»ˆçš„è¿”å›å€¼, å­˜æ”¾ç€æ¯ä¸ªé¡¶ç‚¹, ä»¥åŠæ¯ä¸ªé¡¶ç‚¹åˆ°å…¶ä»–é¡¶ç‚¹çš„æœ€çŸ­è·¯å¾„
    Map<V, Map<V, PathInfo<V, E>>> paths = new HashMap<>();
    // åˆå§‹åŒ–: éå†æ‰€æœ‰é¡¶ç‚¹, åˆå§‹åŒ–æ¯ä¸ªé¡¶ç‚¹åˆ°å®ƒçš„å‡ºå»çš„ç‚¹çš„æœ€çŸ­è·¯å¾„ä¿¡æ¯
    for (Edge<V, E> edge : edges) {
        Map<V, PathInfo<V, E>> map = paths.get(edge.from.value);
        if (map == null) {
            map = new HashMap<>();
            paths.put(edge.from.value, map);
        }
        PathInfo<V, E> pathInfo = new PathInfo<>(edge.weight);
        pathInfo.edgeInfos.add(edge.info());
        map.put(edge.to.value, pathInfo);
    } 

    vertices.forEach((V v2, Vertex<V, E> vertex2) -> {
        vertices.forEach((V v1, Vertex<V, E> vertex1) -> {
            vertices.forEach((V v3, Vertex<V, E> vertex3) -> {
                if (Objects.equals(v1, v2) || Objects.equals(v2, v3) || Objects.equals(v1, v3)) 
                    return;
                // v1 --> v2
                PathInfo<V, E> path12 = getPathInfo(v1, v2, paths);
                if (path12 == null) return;
                // v2 --> v3
                PathInfo<V, E> path23 = getPathInfo(v2, v3, paths);
                if (path23 == null) return;
                // v1 --> v3
                PathInfo<V, E> path13 = getPathInfo(v1, v3, paths);

                E newWeight = weightManager.add(path12.weight, path23.weight);
                if (path13 != null && weightManager.compare(newWeight, path13.weight) >= 0) return;
                if (path13 == null) {
                    path13 = new PathInfo<>();
                    paths.get(v1).put(v3, path13);
                } else {
                    path13.edgeInfos.clear();
                }
                path13.setWeight(newWeight);
                path13.edgeInfos.addAll(path12.edgeInfos);
                path13.edgeInfos.addAll(path23.edgeInfos);
            });
        });
    });
    return paths;
}
private PathInfo<V, E> getPathInfo(V from, V to, Map<V, Map<V, PathInfo<V, E>>> paths){
    Map<V, PathInfo<V, E>> map = paths.get(from);
    return map == null ? null : map.get(to);
}
```



### 9 å›¾çš„å®Œæ•´æºç 

#### 9.1 ä½“ç³»ç»“æ„

![image-20221015170401336](02-æ‹ä¸Šæ•°æ®ç»“æ„-ç®—æ³•ç¯‡.assets/image-20221015170401336.png)



#### 9.2 è¾…åŠ©æ•°æ®ç»“æ„

å°é¡¶å †ï¼šMinHeap.java

```java
import java.util.Collection;
import java.util.Comparator;

/**
 * äºŒå‰å †ï¼ˆæœ€å°å †ï¼‰
 * @author MJ Lee
 *
 * @param <E>
 */
@SuppressWarnings("unchecked")
public class MinHeap<E> {
   private int size;
   private Comparator<E> comparator;
   private int compare(E e1, E e2) {
      return comparator != null ? comparator.compare(e1, e2) 
            : ((Comparable<E>)e1).compareTo(e2);
   }
   private E[] elements;
   private static final int DEFAULT_CAPACITY = 10;
   
   public MinHeap(Collection<E> elements, Comparator<E> comparator) {
      this.comparator = comparator;
      
      size = elements == null ? 0 : elements.size();
      if (size == 0) {
         this.elements = (E[]) new Object[DEFAULT_CAPACITY];
      } else {
         int capacity = Math.max(size, DEFAULT_CAPACITY);
         this.elements = (E[]) new Object[capacity];
         int i = 0;
         for (E element : elements) {
            this.elements[i++] = element;
         }
         heapify();
      }
   }
   
   public MinHeap(E[] elements, Comparator<E> comparator)  {
      this.comparator = comparator;
      
      if (elements == null || elements.length == 0) {
         this.elements = (E[]) new Object[DEFAULT_CAPACITY];
      } else {
         size = elements.length;
         int capacity = Math.max(elements.length, DEFAULT_CAPACITY);
         this.elements = (E[]) new Object[capacity];
         for (int i = 0; i < elements.length; i++) {
            this.elements[i] = elements[i];
         }
         heapify();
      }
   }
   
   public MinHeap(Collection<E> elements)  {
      this(elements, null);
   }
   
   public MinHeap(E[] elements)  {
      this(elements, null);
   }
   
   public MinHeap(Comparator<E> comparator) {
      this.comparator = comparator;
      this.elements = (E[]) new Object[DEFAULT_CAPACITY];
   }
   
   public MinHeap() {
      this.elements = (E[]) new Object[DEFAULT_CAPACITY];
   }

   public int size() {
      return size;
   }

   public boolean isEmpty() {
      return size == 0;
   }
   
   public void addAll(Collection<E> elements) {
      if (elements == null) return;
      for (E element : elements) {
         add(element);
      }
   }
   
   public void addAll(E[] elements) {
      if (elements == null) return;
      for (E element : elements) {
         add(element);
      }
   }
   
   public void clear() {
      for (int i = 0; i < size; i++) {
         elements[i] = null;
      }
      size = 0;
   }

   public void add(E element) {
      elementNotNullCheck(element);
      ensureCapacity(size + 1);
      elements[size++] = element;
      siftUp(size - 1);
   }

   public E get() {
      emptyCheck();
      return elements[0];
   }

   public E remove() {
      emptyCheck();
      
      int lastIndex = --size;
      E root = elements[0];
      elements[0] = elements[lastIndex];
      elements[lastIndex] = null;
      
      siftDown(0);
      return root;
   }

   public E replace(E element) {
      elementNotNullCheck(element);
      
      E root = null;
      if (size == 0) {
         elements[0] = element;
         size++;
      } else {
         root = elements[0];
         elements[0] = element;
         siftDown(0);
      }
      return root;
   }
   
   /**
    * æ‰¹é‡å»ºå †
    */
   protected void heapify() {
      // è‡ªä¸‹è€Œä¸Šçš„ä¸‹æ»¤
      for (int i = (size >> 1) - 1; i >= 0; i--) {
         siftDown(i);
      }
   }
   
   /**
    * è®©indexä½ç½®çš„å…ƒç´ ä¸‹æ»¤
    * @param index
    */
   private void siftDown(int index) {
      E element = elements[index];
      int half = size >> 1;
      // ç¬¬ä¸€ä¸ªå¶å­èŠ‚ç‚¹çš„ç´¢å¼• == éå¶å­èŠ‚ç‚¹çš„æ•°é‡
      // index < ç¬¬ä¸€ä¸ªå¶å­èŠ‚ç‚¹çš„ç´¢å¼•
      // å¿…é¡»ä¿è¯indexä½ç½®æ˜¯éå¶å­èŠ‚ç‚¹
      while (index < half) { 
         // indexçš„èŠ‚ç‚¹æœ‰2ç§æƒ…å†µ
         // 1.åªæœ‰å·¦å­èŠ‚ç‚¹
         // 2.åŒæ—¶æœ‰å·¦å³å­èŠ‚ç‚¹
         
         // é»˜è®¤ä¸ºå·¦å­èŠ‚ç‚¹è·Ÿå®ƒè¿›è¡Œæ¯”è¾ƒ
         int childIndex = (index << 1) + 1;
         E child = elements[childIndex];
         
         // å³å­èŠ‚ç‚¹
         int rightIndex = childIndex + 1;
         
         // é€‰å‡ºå·¦å³å­èŠ‚ç‚¹æœ€å°çš„é‚£ä¸ª
         if (rightIndex < size && compare(elements[rightIndex], child) < 0) {
            child = elements[childIndex = rightIndex];
         }
         
         if (compare(element, child) <= 0) break;

         // å°†å­èŠ‚ç‚¹å­˜æ”¾åˆ°indexä½ç½®
         elements[index] = child;
         // é‡æ–°è®¾ç½®index
         index = childIndex;
      }
      elements[index] = element;
   }
   
   /**
    * è®©indexä½ç½®çš„å…ƒç´ ä¸Šæ»¤
    * @param index
    */
   private void siftUp(int index) {
      E element = elements[index];
      while (index > 0) {
         int parentIndex = (index - 1) >> 1;
         E parent = elements[parentIndex];
         if (compare(element, parent) >= 0) break;
         
         // å°†çˆ¶å…ƒç´ å­˜å‚¨åœ¨indexä½ç½®
         elements[index] = parent;
         
         // é‡æ–°èµ‹å€¼index
         index = parentIndex;
      }
      elements[index] = element;
   }
   
   private void ensureCapacity(int capacity) {
      int oldCapacity = elements.length;
      if (oldCapacity >= capacity) return;
      
      // æ–°å®¹é‡ä¸ºæ—§å®¹é‡çš„1.5å€
      int newCapacity = oldCapacity + (oldCapacity >> 1);
      E[] newElements = (E[]) new Object[newCapacity];
      for (int i = 0; i < size; i++) {
         newElements[i] = elements[i];
      }
      elements = newElements;
   }
   
   private void emptyCheck() {
      if (size == 0) {
         throw new IndexOutOfBoundsException("Heap is empty");
      }
   }
   
   private void elementNotNullCheck(E element) {
      if (element == null) {
         throw new IllegalArgumentException("element must not be null");
      }
   }
}
```



åŸºäºæ³›å‹çš„å¹¶æŸ¥é›†ï¼šGenericUnionFind.java

```java
import java.util.Collection;
import java.util.HashMap;
import java.util.Map;
import java.util.Objects;

/**
 * @description:
 * @author: xu
 * @date: 2022/10/5 12:36
 */
public class GenericUnionFind<V> {
    private Map<V, Node<V>> nodes = new HashMap<>();

    public GenericUnionFind() {}
    public GenericUnionFind(Collection<V> elements) {
        if (elements.size() < 1) return;
        for (V v : elements) {
            if (nodes.containsKey(v)) continue;
            nodes.put(v, new Node<>(v));
        }
    }
    public GenericUnionFind(V[] elements) {
        if (elements.length < 1) return;
        for (V v : elements) {
            if (nodes.containsKey(v)) continue;
            nodes.put(v, new Node<>(v));
        }
    }

    private static class Node<V> {
        V value;
        Node<V> parent = this;
        int rank = 1;
        Node(V value) {
            this.value = value;
        }
    }

    public void makeSet(V v) {
        if (nodes.containsKey(v)) return;
        nodes.put(v, new Node<>(v));
    }

    public V find(V v) {
        Node<V> node = findNode(v);
        return node == null ? null : node.value;
    }

    public void union(V v1, V v2) {
        Node<V> p1 = findNode(v1);
        Node<V> p2 = findNode(v2);
        if (p1 == null || p2 == null) return;
        if (Objects.equals(p1.value, p2.value)) return;
        if (p1.rank < p2.rank) {
            p1.parent = p2;
        } else if (p1.rank > p2.rank) {
            p2.parent = p1;
        } else {
            p1.parent = p2;
            p2.rank += 1;
        }
    }

    public boolean isSame(V v1, V v2) {
        return Objects.equals(find(v1), find(v2));
    }

    /**
     * æ‰¾åˆ°vçš„æ ¹èŠ‚ç‚¹
     * @param v
     * @return
     */
    private Node<V> findNode(V v) {
        Node<V> node = nodes.get(v);
        if (node == null) return null;
        while (!Objects.equals(node.value, node.parent.value)) {
            node.parent = node.parent.parent;
            node = node.parent;
        }
        return node;
    }
}
```



#### 9.3 Graph.java

```java
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Set;

/**
 * @description:
 * @author: xu
 * @date: 2022/10/5 20:20
 */
public abstract class Graph<V, E> {
    protected WeightManager<E> weightManager;
    public Graph(WeightManager<E> weightManager) {
        this.weightManager = weightManager;
    }
    public Graph() {}

    //è·å–é¡¶ç‚¹ã€è¾¹çš„æ•°é‡
    public abstract int edgesSize();
    public abstract int verticsSize();

    //æ·»åŠ æ–°çš„é¡¶ç‚¹ã€è¾¹
    public abstract void addVertex(V v);
    public abstract void addEdge(V from, V to);
    public abstract void addEdge(V from, V to, E weight);

    //åˆ é™¤é¡¶ç‚¹ã€è¾¹
    public abstract void removeVertex(V v);
    public abstract void removeEdge(V from, V to);

    //éå†å›¾ï¼š
    //bfsï¼šå¹¿åº¦ä¼˜å…ˆéå†ï¼›dfsï¼šæ·±åº¦ä¼˜å…ˆéå†
    public abstract void bfs(V begin, VertexVisitor<V> visitor);
    public abstract void dfs(V begin, VertexVisitor<V> visitor);
    public abstract void dfs1(V begin, VertexVisitor<V> visitor);

    //æ‹“æ‰‘æ’åºï¼šå¡æ©ç®—æ³•
    public abstract List<V> topologicalSort();

    //æœ€å°ç”Ÿæˆæ ‘
    //primï¼šæ™®åˆ©å§†ç®—æ³•
    //kruskalï¼šå…‹é²æ–¯å¡å°”ç®—æ³•
    public abstract Set<EdgeInfo<V, E>> mst();

    //æœ€çŸ­è·¯å¾„
    //public abstract Map<V, E> shortestPath1(V begin);
    public abstract Map<V, PathInfo<V, E>> shortestPath(V begin); // å•æº
    public abstract Map<V, Map<V, PathInfo<V, E>>> shortestPaths(); // å¤šæº

    //è®¿é—®å™¨ï¼šæœ‰å¤–é¢æä¾›å®šä¹‰çš„èŠ‚ç‚¹è®¿é—®
    public interface VertexVisitor<V> {
        boolean visit(V v);
    }
    //æƒå€¼ç®¡ç†å™¨ï¼šæœ‰å¤–é¢æä¾›å¯¹æƒå€¼çš„æ¯”è¾ƒã€åŠ æ³•å¤„ç†
    public interface WeightManager<E> {
        int compare(E w1, E w2);
        E add(E w1, E w2);
        E zero();
    }
    //æä¾›å¤–é¢è®¿é—®çš„è¾¹çš„ä¿¡æ¯
    public static class EdgeInfo<V, E>{
        private V from;
        private V to;
        private E weight;
        protected EdgeInfo(V from, V to, E weight) {
            this.from = from;
            this.to = to;
            this.weight = weight;
        }
        public V getFrom() {
            return from;
        }
        public void setFrom(V from) {
            this.from = from;
        }
        public V getTo() {
            return to;
        }
        public void setTo(V to) {
            this.to = to;
        }
        public E getWeight() {
            return weight;
        }
        public void setWeight(E weight) {
            this.weight = weight;
        }
        @Override
        public String toString() {
            return "EdgeInfo{" +
                    "from=" + from +
                    ", to=" + to +
                    ", weight=" + weight +
                    '}';
        }
    }
    public static class PathInfo<V, E>{
        protected E weight;
        protected List<EdgeInfo<V, E>> edgeInfos = new LinkedList<>();
        public PathInfo() {}
        public PathInfo(E weight) {
            this.weight = weight;
        }
        public E getWeight() {
            return weight;
        }
        public void setWeight(E weight) {
            this.weight = weight;
        }
        public List<EdgeInfo<V, E>> getEdgeInfos() {
            return edgeInfos;
        }
        public void setEdgeInfos(List<EdgeInfo<V, E>> edgeInfos) {
            this.edgeInfos = edgeInfos;
        }

        @Override
        public String toString() {
            return "PathInfo{" +
                    "weight=" + weight +
                    ", edgeInfos=" + edgeInfos +
                    '}';
        }
    }
}
```



#### 9.4 ListGraph.java

```java
package com.xk._02Algorithmic._03graph.graph;

import com.xk._02Algorithmic._03graph.GenericUnionFind;
import com.xk._02Algorithmic._03graph.MinHeap;

import java.util.*;

/**
 * @description:
 * @author: xu
 * @date: 2022/10/5 20:28
 */
public class ListGraph<V, E> extends Graph<V, E>{
    private Map<V, Vertex<V,E>> vertices = new HashMap<>();
    private Set<Edge<V, E>> edges = new HashSet<>();
    private Comparator<Edge<V, E>> edgeComparator = (Edge<V, E> e1, Edge<V, E> e2) -> {
        return weightManager.compare(e1.weight, e2.weight);
    };

    public ListGraph(WeightManager<E> weightManager) {
        super(weightManager);
    }
    public ListGraph() {}

    // é¡¶ç‚¹
    private static class Vertex<V, E> {
        V value;
        Set<Edge<V,E>> inEdges = new HashSet<>();
        Set<Edge<V,E>> outEdges = new HashSet<>();
        Vertex(V value) {
            this.value = value;
        }

        @Override
        public boolean equals(Object o) {
            if (this == o) return true;
            if (!(o instanceof Vertex)) return false;
            Vertex<?, ?> vertex = (Vertex<?, ?>) o;
            return Objects.equals(value, vertex.value);
        }
        @Override
        public int hashCode() {
            return Objects.hash(value);
        }

        @Override
        public String toString() {
            return value == null ? "null" : value.toString();
        }
    }

    // è¾¹
    private static class Edge<V, E> {
        Vertex<V,E> from;
        Vertex<V,E> to;
        E weight;

        Edge(Vertex<V, E> from, Vertex<V, E> to) {
            this(from, to, null);
        }
        Edge(Vertex<V, E> from, Vertex<V, E> to, E weight) {
            this.from = from;
            this.to = to;
            this.weight = weight;
        }

        EdgeInfo<V, E> info(){
            return new EdgeInfo<>(from.value, to.value, weight);
        }

        @Override
        public boolean equals(Object o) {
            if (this == o) return true;
            if (!(o instanceof Edge)) return false;
            Edge<V, E> edge = (Edge<V, E>) o;
            return Objects.equals(from, edge.from) && Objects.equals(to, edge.to);
        }

        @Override
        public int hashCode() {
            return Objects.hash(from, to);
        }

        @Override
        public String toString() {
            return "Edge{" +
                    "from=" + from +
                    ", to=" + to +
                    ", weight=" + weight +
                    '}';
        }
    }

    public void print(){
        vertices.forEach((V key, Vertex<V,E> vertex) -> {
            System.out.println(key);
            System.out.println("out: " + vertex.outEdges);
            System.out.println("in : " + vertex.inEdges);
        });
        System.out.println("================================");
        edges.forEach((Edge<V,E> edge) -> {
            System.out.println(edge);
        });
    }

    /**
     * è¿”å›è¾¹çš„æ•°é‡
     * @return
     */
    @Override
    public int edgesSize() {
        return edges.size();
    }

    /**
     * è¿”å›é¡¶ç‚¹çš„æ•°é‡
     * @return
     */
    @Override
    public int verticsSize() {
        return vertices.size();
    }

    /**
     * æ·»åŠ é¡¶ç‚¹
     * @param v
     */
    @Override
    public void  addVertex(V v) {
        if (vertices.containsKey(v)) return;
        vertices.put(v, new Vertex<>(v));
    }

    /**
     * æ·»åŠ è¾¹ï¼šæ— æƒå€¼
     * @param from
     * @param to
     */
    @Override
    public void addEdge(V from, V to) {
        addEdge(from, to, null);
    }

    /**
     * æ·»åŠ è¾¹ï¼šæœ‰æƒå€¼
     * @param from
     * @param to
     * @param weight
     */
    @Override
    public void addEdge(V from, V to, E weight) {
        // åˆ¤æ–­ from ã€to é¡¶ç‚¹æ˜¯å¦å­˜åœ¨
        Vertex<V, E> fromVertex = vertices.get(from);
        Vertex<V, E> toVertex = vertices.get(to);
        if (fromVertex == null) {
            vertices.put(from, fromVertex = new Vertex<>(from));
        }
        if (toVertex == null) {
            vertices.put(to, toVertex = new Vertex<>(to));
        }
        Edge<V, E> edge = new Edge<>(fromVertex, toVertex, weight);

        if (fromVertex.outEdges.remove(edge)){
            toVertex.inEdges.remove(edge);
            edges.remove(edge);
        }
        fromVertex.outEdges.add(edge);
        toVertex.inEdges.add(edge);
        edges.add(edge);
    }

    /**
     * åˆ é™¤é¡¶ç‚¹
     * @param v
     */
    @Override
    public void removeVertex(V v) {
        Vertex<V, E> vertex = vertices.remove(v);
        if (vertex == null) return;

        // è¿­ä»£å™¨
        Iterator<Edge<V, E>> outIterator = vertex.outEdges.iterator();
        while (outIterator.hasNext()) {
            Edge<V, E> edge = outIterator.next();
            edge.to.inEdges.remove(edge);
            // å°†å½“å‰éå†åˆ°çš„å…ƒç´ edgeä»é›†åˆvertex.outEdgesä¸­åˆ é™¤
            outIterator.remove();
            edges.remove(edge);
        }

        Iterator<Edge<V, E>> inIterator = vertex.inEdges.iterator();
        while (inIterator.hasNext()) {
            Edge<V, E> edge = inIterator.next();
            edge.from.outEdges.remove(edge);
            // å°†å½“å‰éå†åˆ°çš„å…ƒç´ edgeä»é›†åˆvertex.inEdgesä¸­åˆ é™¤
            inIterator.remove();
            edges.remove(edge);
        }
    }

    /**
     * åˆ é™¤è¾¹
     * @param from
     * @param to
     */
    @Override
    public void removeEdge(V from, V to) {
        Vertex<V, E> fromVertex = vertices.get(from);
        Vertex<V, E> toVertex = vertices.get(to);
        if (fromVertex == null || toVertex == null) return;
        Edge<V, E> edge = new Edge<>(fromVertex, toVertex);
        if (fromVertex.outEdges.remove(edge)) {
            toVertex.inEdges.remove(edge);
            edges.remove(edge);
        }
    }

    /*BFS===================================================================================*/
    /**
     * å¹¿åº¦ä¼˜å…ˆéå†
     * @param begin
     */
    @Override
    public void bfs(V begin, VertexVisitor<V> visitor) {
        if (visitor == null) return;
        Vertex<V, E> beginVertex = vertices.get(begin);
        if (beginVertex == null) return;

        Set<Vertex<V, E>> visitedVertices = new HashSet<>();
        Deque<Vertex<V, E>> queue = new LinkedList<>();
        queue.offer(beginVertex);
        visitedVertices.add(beginVertex);

        while (!queue.isEmpty()) {
            Vertex<V, E> vertex = queue.poll();
            if (visitor.visit(vertex.value)) return;
            for (Edge<V, E> edge : vertex.outEdges) {
                if (visitedVertices.contains(edge.to)) continue;
                queue.offer(edge.to);
                visitedVertices.add(edge.to);
            }
        }
    }
    /*DFS===================================================================================*/
    /**
     * æ·±åº¦ä¼˜å…ˆéå†ï¼šé€’å½’
     * @param begin
     */
    @Override
    public void dfs1(V begin, VertexVisitor<V> visitor) {
        if (visitor == null) return;
        Vertex<V, E> beginVertex = vertices.get(begin);
        if (beginVertex == null) return;

        dfs1(beginVertex, visitor, new HashSet<>());
    }
    private void dfs1(Vertex<V, E> vertex, VertexVisitor<V> visitor, Set<Vertex<V, E>> visitedVertices) {
        if (visitor.visit(vertex.value)) return;
        visitedVertices.add(vertex);
        for (Edge<V, E> outEdge : vertex.outEdges) {
            if (visitedVertices.contains(outEdge.to)) continue;
            dfs1(outEdge.to, visitor, visitedVertices);
        }
    }
    /**
     * æ·±åº¦ä¼˜å…ˆéå†ï¼šéé€’å½’
     * @param begin
     */
    public void dfs(V begin, VertexVisitor<V> visitor) {
        if (visitor == null) return;
        Vertex<V, E> vertex = vertices.get(begin);
        if (vertex == null) return;

        Set<Vertex<V, E>> visitedVertices = new HashSet<>();
        Deque<Vertex<V, E>> stack = new LinkedList<>();

        //å…ˆè®¿é—®èµ·ç‚¹
        stack.push(vertex);
        visitedVertices.add(vertex);
        if (visitor.visit(vertex.value)) return;

        while (!stack.isEmpty()) {
            Vertex<V, E> pop = stack.pop();

            for (Edge<V, E> outEdge : pop.outEdges) {
                if (visitedVertices.contains(outEdge.to)) continue;
                stack.push(outEdge.from);
                stack.push(outEdge.to);
                visitedVertices.add(outEdge.to);
                if (visitor.visit(outEdge.to.value)) return;
                break;
            }
        }
    }

    /*æ‹“æ‰‘æ’åºï¼šå¡æ©ç®—æ³•===================================================================================*/
    /**
     * æ‹“æ‰‘æ’åºï¼šå¡æ©ç®—æ³•
     * @return
     */
    @Override
    public List<V> topologicalSort() {
        List<V> list = new ArrayList<>();
        Queue<Vertex<V, E>> queue = new LinkedList<>();
        Map<Vertex<V, E>, Integer> ins = new HashMap<>();

        // åˆå§‹åŒ–ï¼ˆå°†å…¥åº¦ä¸º0çš„èŠ‚ç‚¹éƒ½æ”¾å…¥é˜Ÿåˆ—ï¼‰
        vertices.forEach((V v, Vertex<V, E> vertex) -> {
            int inSize = vertex.inEdges.size();
            if (inSize == 0) queue.offer(vertex);
            else ins.put(vertex, inSize);
        });

        while (!queue.isEmpty()) {
            Vertex<V, E> vertex = queue.poll();
            // æ”¾å…¥è¿”å›ç»“æœä¸­
            list.add(vertex.value);

            for (Edge<V, E> outEdge : vertex.outEdges) {
                int in = ins.get(outEdge.to) - 1;
                if (in == 0) queue.offer(outEdge.to);
                else ins.put(outEdge.to, in);
            }
        }
        return list;
    }

    /*æœ€å°ç”Ÿæˆæ ‘===================================================================================*/
    /**
     * æœ€å°ç”Ÿæˆæ ‘ï¼šé»˜è®¤æ— å‘å›¾
     * @return
     */
    @Override
    public Set<EdgeInfo<V, E>> mst() {
        return Math.random() > 0.5 ? mst_prim() : mst_kruskal();
    }
    /**
     * æœ€å°ç”Ÿæˆæ ‘ï¼šprimç®—æ³•
     * @return
     */
    private Set<EdgeInfo<V, E>> mst_prim() {
        Iterator<Vertex<V, E>> it = vertices.values().iterator();
        if (!it.hasNext()) return null;
        Vertex<V, E> vertex = it.next();
        Set<EdgeInfo<V, E>> edgeInfos = new HashSet<>();
        Set<Vertex<V, E>> addedVertices = new HashSet<>();
        addedVertices.add(vertex);

        MinHeap<Edge<V, E>> heap = new MinHeap<>(vertex.outEdges, edgeComparator);

        while (!heap.isEmpty() && verticsSize() > addedVertices.size()) {
            Edge<V, E> edge = heap.remove();
            if (addedVertices.contains(edge.to)) continue;
            edgeInfos.add(edge.info());
            addedVertices.add(edge.to);
            heap.addAll(edge.to.outEdges);
        }
        return edgeInfos;
    }
    /**
     * æœ€å°ç”Ÿæˆæ ‘ï¼škruskalç®—æ³•
     * @return
     */
    private Set<EdgeInfo<V, E>> mst_kruskal(){
        int edgeSize = verticsSize() - 1;
        if (edgeSize < 2) return null;

        Set<EdgeInfo<V, E>> edgeInfos = new HashSet<>();
        MinHeap<Edge<V,E>> heap = new MinHeap<>(edges, edgeComparator);

        //å¹¶æŸ¥é›†ï¼šç”¨äºç¯çš„åˆ¤æ–­
        GenericUnionFind<Vertex<V, E>> unionFind = new GenericUnionFind<>(vertices.values());

        while (!heap.isEmpty() && edgeInfos.size() < edgeSize) {
            Edge<V, E> edge = heap.remove();
            if (unionFind.isSame(edge.from, edge.to)) continue;
            edgeInfos.add(edge.info());
            unionFind.union(edge.from, edge.to);
        }
        return edgeInfos;
    }

    /**
     * å•æºæœ€çŸ­è·¯å¾„
     * @param begin
     * @return
     */
    @Override
    public Map<V, PathInfo<V, E>> shortestPath(V begin) {
        return dijkstra(begin);
    }
    /*å•æºæœ€çŸ­è·¯å¾„ï¼šDijkstra========================================================================*/
    /**
     * å•æºæœ€çŸ­è·¯å¾„ï¼šDijkstraå®ç°ï¼Œè¿ªæ°æ–¯ç‰¹æ‹‰ç®—æ³•å®ç°
     * @param begin
     * @return
     */
    private Map<V, PathInfo<V, E>> dijkstra(V begin) {
        Vertex<V, E> beginVertex = vertices.get(begin);
        if (beginVertex == null) return null;

        Map<V, PathInfo<V, E>> selectedPaths = new HashMap<>();
        Map<Vertex<V, E>, PathInfo<V, E>> paths = new HashMap<>();
        paths.put(beginVertex, new PathInfo<>(weightManager.zero()));
        //åˆå§‹åŒ–paths
        //for (Edge<V, E> outEdge : beginVertex.outEdges) {
        //    PathInfo<V, E> pathInfo = new PathInfo<>();
        //    pathInfo.setWeight(outEdge.weight);
        //    pathInfo.edgeInfos.add(outEdge.info());
        //    paths.put(outEdge.to, pathInfo);
        //}

        while (!paths.isEmpty()) {
            Map.Entry<Vertex<V, E>, PathInfo<V, E>> minEntry = getShortestPath(paths);
            // minVertexç¦»å¼€æ¡Œé¢
            Vertex<V, E> minVertex = minEntry.getKey();
            PathInfo<V, E> minPath = minEntry.getValue();
            selectedPaths.put(minVertex.value, minPath);
            paths.remove(minVertex);
            // å¯¹å®ƒçš„ minVertex çš„ outEdges è¿›è¡Œæ¾å¼›æ“ä½œ
            for (Edge<V, E> edge : minVertex.outEdges) {
                // å¦‚æœedge.toå·²ç»ç¦»å¼€æ¡Œé¢ï¼Œå°±æ²¡å¿…è¦è¿›è¡Œæ¾å¼›æ“ä½œ
                if (selectedPaths.containsKey(edge.to.value)) continue;
                relaxForDijkstra(edge, minPath, paths);
            }
        }
        selectedPaths.remove(begin);
        return selectedPaths;
    }
    /**
     * ä»pathsä¸­æŒ‘ä¸€ä¸ªæœ€å°çš„è·¯å¾„å‡ºæ¥
     * @param paths
     * @return
     */
    private Map.Entry<Vertex<V, E>, PathInfo<V, E>> getShortestPath(Map<Vertex<V, E>, PathInfo<V, E>> paths){
        Iterator<Map.Entry<Vertex<V, E>, PathInfo<V, E>>> iterator = paths.entrySet().iterator();
        Map.Entry<Vertex<V, E>, PathInfo<V, E>> minEntry = iterator.next();
        while (iterator.hasNext()){
            Map.Entry<Vertex<V, E>, PathInfo<V, E>> entry = iterator.next();
            if (weightManager.compare(entry.getValue().weight, minEntry.getValue().weight) < 0) {
                minEntry = entry;
            }
        }
        return minEntry;
    }
    /**
     * æ¾å¼›æ“ä½œ -- Dijkstra
     * @param edge éœ€è¦è¿›è¡Œæ¾å¼›çš„è¾¹
     * @param fromPath edgeçš„fromçš„æœ€çŸ­è·¯å¾„ä¿¡æ¯
     * @param paths å­˜æ”¾ç€å…¶ä»–ç‚¹ï¼ˆå¯¹äºdijkstraæ¥è¯´ï¼Œè¿˜æ²¡æœ‰ç¦»å¼€æ¡Œé¢çš„ç‚¹ï¼‰çš„æœ€çŸ­è·¯å¾„ä¿¡æ¯
     */
    private void relaxForDijkstra(Edge<V, E> edge, PathInfo<V, E> fromPath, Map<Vertex<V, E>, PathInfo<V, E>> paths){
        // æ–°çš„å¯é€‰æ‹©çš„æœ€çŸ­è·¯å¾„ï¼šbeginVertexåˆ°edge.fromçš„æœ€çŸ­è·¯å¾„ + edge.weight
        E newWeight = weightManager.add(fromPath.weight, edge.weight);
        // ä»¥å‰çš„æœ€çŸ­è·¯å¾„ï¼šbeginVertexåˆ°edge.toçš„æœ€çŸ­è·¯å¾„
        PathInfo<V, E> oldPath = paths.get(edge.to);

        if (oldPath != null && weightManager.compare(newWeight, oldPath.weight) >= 0) return;

        if (oldPath == null) {
            oldPath = new PathInfo<>();
            paths.put(edge.to, oldPath);
        } else {
            oldPath.edgeInfos.clear();
        }
        oldPath.setWeight(newWeight);
        oldPath.edgeInfos.addAll(fromPath.edgeInfos);
        oldPath.edgeInfos.add(edge.info());
    }
    /*å•æºæœ€çŸ­è·¯å¾„ï¼šBellman-Ford=====================================================================*/
    /**
     * å•æºæœ€çŸ­è·¯å¾„ï¼šBellman-Fordå®ç°ï¼Œè´å°”æ›¼-ç¦ç‰¹ç®—æ³•å®ç°
     * @param begin
     * @return
     */
    private Map<V, PathInfo<V, E>> bellmanFord(V begin) {
        Vertex<V, E> beginVertex = vertices.get(begin);
        if (beginVertex == null) return null;

        Map<V, PathInfo<V, E>> selectedPaths = new HashMap<>();
        selectedPaths.put(begin, new PathInfo<>(weightManager.zero()));

        int count = verticsSize() - 1;
        for (int i = 0; i < count; i++) { // V - 1æ¬¡
            for (Edge<V, E> edge : edges) {
                PathInfo<V, E> fromPath = selectedPaths.get(edge.from.value);
                if (fromPath == null) continue;
                relaxForBellmanFord(edge, fromPath, selectedPaths);
            }
        }

        for (Edge<V, E> edge : edges) {
            PathInfo<V, E> fromPath = selectedPaths.get(edge.from.value);
            if (fromPath == null) continue;
            if (relaxForBellmanFord(edge, fromPath, selectedPaths)) {
                throw new RuntimeException("æœ‰è´Ÿæƒç¯ï¼Œæ— æœ€çŸ­è·¯å¾„");
            }
        }
        selectedPaths.remove(begin);
        return selectedPaths;
    }
    /**
     * æ¾å¼›æ“ä½œ -- BellmanFord
     * @param edge éœ€è¦è¿›è¡Œæ¾å¼›çš„è¾¹
     * @param fromPath edgeçš„fromçš„æœ€çŸ­è·¯å¾„ä¿¡æ¯
     * @param paths å­˜æ”¾ç€å…¶ä»–ç‚¹ï¼ˆå¯¹äºdijkstraæ¥è¯´ï¼Œè¿˜æ²¡æœ‰ç¦»å¼€æ¡Œé¢çš„ç‚¹ï¼‰çš„æœ€çŸ­è·¯å¾„ä¿¡æ¯
     */
    private boolean relaxForBellmanFord(Edge<V, E> edge, PathInfo<V, E> fromPath, Map<V, PathInfo<V, E>> paths){
        // æ–°çš„å¯é€‰æ‹©çš„æœ€çŸ­è·¯å¾„ï¼šbeginVertexåˆ°edge.fromçš„æœ€çŸ­è·¯å¾„ + edge.weight
        E newWeight = weightManager.add(fromPath.weight, edge.weight);
        // ä»¥å‰çš„æœ€çŸ­è·¯å¾„ï¼šbeginVertexåˆ°edge.toçš„æœ€çŸ­è·¯å¾„
        PathInfo<V, E> oldPath = paths.get(edge.to.value);

        if (oldPath != null && weightManager.compare(newWeight, oldPath.weight) >= 0) return false;

        if (oldPath == null) {
            oldPath = new PathInfo<>();
            paths.put(edge.to.value, oldPath);
        } else {
            oldPath.edgeInfos.clear();
        }
        oldPath.setWeight(newWeight);
        oldPath.edgeInfos.addAll(fromPath.edgeInfos);
        oldPath.edgeInfos.add(edge.info());
        return true;
    }

    /*å¤šæºæœ€çŸ­è·¯å¾„===================================================================================*/
    /**
     * å¤šæºæœ€çŸ­è·¯å¾„
     * @return
     */
    @Override
    public Map<V, Map<V, PathInfo<V, E>>> shortestPaths() {
        return floyd();
    }
    /**
     * å¤šæºæœ€çŸ­è·¯å¾„ï¼šfloydï¼Œå¼—æ´›ä¼Šå¾·ç®—æ³•å®ç°
     * @return
     */
    private Map<V, Map<V, PathInfo<V, E>>> floyd(){
        Map<V, Map<V, PathInfo<V, E>>> paths = new HashMap<>();
        // åˆå§‹åŒ–
        for (Edge<V, E> edge : edges) {
            Map<V, PathInfo<V, E>> map = paths.get(edge.from.value);
            if (map == null) {
                map = new HashMap<>();
                paths.put(edge.from.value, map);
            }
            PathInfo<V, E> pathInfo = new PathInfo<>(edge.weight);
            pathInfo.edgeInfos.add(edge.info());
            map.put(edge.to.value, pathInfo);
        }

        vertices.forEach((V v2, Vertex<V, E> vertex2) -> {
            vertices.forEach((V v1, Vertex<V, E> vertex1) -> {
                vertices.forEach((V v3, Vertex<V, E> vertex3) -> {
                    if (Objects.equals(v1, v2) || Objects.equals(v2, v3) || Objects.equals(v1, v3)) return;

                    // v1 --> v2
                    PathInfo<V, E> path12 = getPathInfo(v1, v2, paths);
                    if (path12 == null) return;
                    // v2 --> v3
                    PathInfo<V, E> path23 = getPathInfo(v2, v3, paths);
                    if (path23 == null) return;
                    // v1 --> v3
                    PathInfo<V, E> path13 = getPathInfo(v1, v3, paths);

                    E newWeight = weightManager.add(path12.weight, path23.weight);
                    if (path13 != null && weightManager.compare(newWeight, path13.weight) >= 0) return;
                    if (path13 == null) {
                        path13 = new PathInfo<>();
                        paths.get(v1).put(v3, path13);
                    } else {
                        path13.edgeInfos.clear();
                    }
                    path13.setWeight(newWeight);
                    path13.edgeInfos.addAll(path12.edgeInfos);
                    path13.edgeInfos.addAll(path23.edgeInfos);
                });
            });
        });
        return paths;
    }
    private PathInfo<V, E> getPathInfo(V from, V to, Map<V, Map<V, PathInfo<V, E>>> paths){
        Map<V, PathInfo<V, E>> map = paths.get(from);
        return map == null ? null : map.get(to);
    }
}
```

+++

## å››ã€é€’å½’Recursion



























+++

## äº”ã€å›æº¯Back Tracking













































































































