# 动态代理

### 一、掌握的程度

1. 知道什么是动态代理
   - 使用JDK的反射机制，创建对象的能力， 创建的是代理类的对象。 而不用你创建类文件。不用写java文件。
   - 动态：在程序执行时，调用JDK提供的方法才能创建代理类的对象。
   - JDK动态代理，必须有接口，目标类必须实现接口，没有接口时，需要使用 cglib 动态代理
2. 知道动态代理能做什么
   - 可以在不改变原来目标方法功能的前提下，可以在代理中增强自己的功能代码。
3. 后面会讲myBatis、Spring时会用到动态代理

### 二、什么是代理

代购，中介，商家等等....

比如有一家美国的大学，可以对全世界招生。留学中介（代理）

1. 代理特点：
   - 中介和代理他们要做的事情是一致的：招生。 
   - 中介是学校代理， 学校是目标。
   - 家长 --- 中介（学校介绍，办入学手续）---- 美国学校。
   - 中介是代理，不能白干活，需要收取费用。
   - 代理不让你访问到目标。
2. 为什么要去找中介？
   - 中介是专业的，方便
   - 家长现在不能自己去找学校。家长没有能力访问学校。或者美国学校不接收个人来访。

卖东西都是商家卖，商家是某个商品的代理，你个人买东西，肯定不会让你接触到厂家的。

### 三、代理模式

- 代理模式：代理模式是指，为其他对象提供一种代理以控制对这个对象的访问。在某些情况下，一个对象不适合或者不能直接引用另一个对象，而代理对象可以在客户类和目标对象之间起到中介的作用。

- 换句话说，使用代理对象，是为了在不修改目标对象的基础上，增强主业务逻辑。

- **客户类**真正的想要访问的对象是**目标对象**，但客户类真正可以访问的对象是**代理对象**。 客户类对目标对象的访问是通过访问代理对象来实现的。当然,代理类与目标类要实现同一个接口。

- 例如：有 A，B，C 三个类， A 原来可以调用 C 类的方法，现在因为某种原因 C 类不允许 A 类调用其方法，但 B 类可以调用 C 类的方法。A 类通过 B 类调用 C 类的方法。这里 B 是 C 的代理。 A 通过代理 B 访问 C。

- 实际的例子： 登录，注册有验证码， 验证码是手机短信。

  中国移动， 联通能发短信。 

  中国移动， 联通能有子公司，或者关联公司，他们面向社会提供短信的发送功能

  张三项目发送短信 ----> 子公司，或者关联公司 -----> 中国移动， 联通

### 四、代理模式的作用

1. 功能增强：在你原有的功能上，增加了额外的功能。新增加的功能，叫做功能增强。
2. 控制访问：代理类不让你访问目标，例如商家不让用户访问厂家。

### 五、代理模式的分类

1. 静态代理
2. 动态代理

### 六、实现代理的方式

##### 6.1 静态代理：

- 代理类是自己手工实现的，自己创建一个java类，表示代理类。
- 同时你所要代理的目标类是确定的。
- 特点：a. 实现简单  b.容易理解。

模拟一个用户购买u盘的行为。
	    用户：是客户端类
	    商家：代理，代理某个品牌的u盘。
		厂家：目标类。

​		三者的关系： 用户（客户端）---> 商家（代理）---> 厂家（目标）
​		商家和厂家都是卖u盘的，他们完成的功能是一致的，都是卖u盘。

实现步骤：

1. 创建一个接口，定义卖u盘的方法，表示厂家和商家做的事情
2. 创建厂家类，实现1步骤的接口
3. 创建商家，就是代理，也需要实现1步骤中的接口
4. 创建客户端类，调用商家的方法买一个u盘。

```java
//接口
package com.example.proxy.service;
//表示功能的，厂家和商家都要完成的功能
public interface UsbSell {
    //定义方法 参数 amount：表示一次购买的数量，暂时不用
    //返回值表示一个U盘的价格
    float sell(int amount);

    //可以定义多个其他的方法
}
```

```java
//目标类 厂家类
package com.example.proxy.factory;
import com.example.proxy.service.UsbSell;
//目标类：金士顿厂家，不接受用户的单独购买
public class UsbKingFactory implements UsbSell {
    @Override
    public float sell(int amount) {
        System.out.println("目标类中的方法调用,UsbKingFactory中的sell ");
        //一个128G的U盘是85元
        //后期根据amount，可以实现不同的价格，例如10000个单价是80，50000个是75
        return 85.0f;
    }
}
```

```java
//代理类 商家
package com.example.proxy.sahngjia;
import com.example.proxy.factory.UsbKingFactory;
import com.example.proxy.service.UsbSell;
//代理类：TaoBao是一个商家，代理金士顿U盘的销售
public class TaoBao implements UsbSell {
    //声明 商家代理的厂家具体是谁
    private UsbKingFactory factory = new UsbKingFactory();
    @Override
    public float sell(int amount) {
        //实现销售U盘功能
        //向厂家发送订单，告诉厂家，我买了U盘，厂家发货
        float price = factory.sell(amount);//厂家的价格
        //商家 需要加价，也就是代理要增加价格
        price += 25;
        //在目标类的方法调用后，你做的其它功能，都是增强的意思。
        System.out.println("淘宝商家，给你返一个优惠券，或者红包");
        //增加的价格
        return price;
    }
}

package com.example.proxy.sahngjia;
import com.example.proxy.factory.UsbKingFactory;
import com.example.proxy.service.UsbSell;
//代理类：WeiShang是一个商家，也代理金士顿U盘的销售
public class WeiShang implements UsbSell {
    //代理的是金士顿，定义目标厂家类
    private UsbKingFactory factory = new UsbKingFactory();
    @Override
    public float sell(int amount) {
        //实现目标方法
        float price = factory.sell(amount);//厂家的价格
        //只增加1元
        price += 1;
        //增加的价格
        return price;
    }
}
```

```java
//用户客户端类
package com.example.proxy;
import com.example.proxy.sahngjia.TaoBao;
public class ShopMan {
    public static void main(String[] args) {
        //创建代理的商家TaoBao对象
        TaoBao taoBao = new TaoBao();
        //通过代理类，实现购买u盘，增加了优惠券，红包等等
        float price = taoBao.sell(1);
        System.out.println("通过淘宝的商家，购买U盘单价：" + price);
    }
}
/*
目标类中的方法调用,UsbKingFactory中的sell 
淘宝商家，给你返一个优惠券，或者红包
通过淘宝的商家，购买U盘单价：110.0
*/
```

- 代理类完成的功能： 
  1. 目标类中方法的调用
  2. 功能增强
- 静态代理缺点
  - 当你的项目中，目标类和代理类数量很多的时候，有以下的缺点：
  
  - 当目标类增加了，代理类可能也需要成倍的增加。代理类数量过多。
  
  - 当你的接口中功能增加了，或者修改了，会影响众多的实现类，厂家类，代理都需要修改。影响比较多。
  
    

##### 6.2 动态代理

- 在静态代理中目标类很多时候，可以使用动态代理，避免静态代理的缺点。 

- 动态代理中目标类即使很多：
  - 代理类数量可以很少
  - 当你修改了接口中的方法时，不会影响代理类。
  
- 动态代理：
  - 在程序执行过程中，使用JDK的反射机制，创建代理类对象，并动态的指定要代理目标类。换句话说：动态代理是一种创建 java 对象的能力，让你不用创建TaoBao类，就能创建代理类对象。
  - 动态代理是指代理类对象在程序运行时由 JVM 根据反射机制动态生成的。动态代理不需要定义代理类的.java 源文件。
  - 动态代理其实就是 jdk 运行期间，动态创建 class 字节码并加载到 JVM。
  - 特点：不用创建类文件，代理的目标是活动的，可设置的；1.不用创建代理类； 2.可以给不同的目标随时创建代理
  
  
  
- 动态代理的实现

  1. JDK动态代理（理解）
     - 使用java反射包中的类和接口实现动态代理的功能。
     - 反射包 java.lang.reflect， 里面有三个类：InvocationHandler, Method, Proxy
  2. cglib动态代理（了解）
     - cglib是第三方的工具库，创建代理对象。
     - cglib的原理是继承，cglib通过继承目标类，创建它的子类，在子类中重写父类中同名的方法，实现功能的修改。
     - 因为cglib是继承，重写方法，所以要求目标类不能是final的， 方法也不能是final的。cglib的要求目标类比较宽松，只要能继承就可以了。cglib在很多的框架中使用，比如mybatis，spring框架中都有使用。



- JDK 动态代理：

  1. 反射，Method类，表示方法。类中的方法；通过Method可以执行某个方法。

     ```java
     public interface HelloService {
         //根 name 打招呼
         public void sayHello(String name);
     }
     
     public class HelloServiceImpl implements HelloService {
         @Override
         public void sayHello(String name) {
             System.out.println("Hello " + name);
         }
     }
     
     public class HelloServiceImpl2 implements HelloService {
         @Override
         public void sayHello(String name) {
             System.out.println("==========Hello " + name);
         }
     }
     
     public class TestApp {
         public static void main(String[] args) throws NoSuchMethodException, InvocationTargetException, IllegalAccessException {
             HelloService service = new HelloServiceImpl();
             service.sayHello("张三");
     
             //使用反射机制执行sayHello方法，核心 Method 类中的方法
             HelloService tarGet = new HelloServiceImpl();
             HelloService tarGet2 = new HelloServiceImpl2();
             //获取sayHello名称对于的Method类对象
             Method m = HelloService.class.getMethod("sayHello", String.class);
             /*
             * invoke是Method类中的一个方法，表示执行方法的调用
             * 参数：
             *   1.Object  表示对象的，要执行这个对象的方法
             *   2.Object... args, 方法执行时的参数值
             * 返回值：
             *   Object:方法执行后的返回值
             * */
             //表达的意思就是 执行tarGet对象的sayHello()方法，参数是"李四"
             Object ret = m.invoke(tarGet, "李四");
             Object ret1 = m.invoke(tarGet2, "王五");
         }
     }
     /*
     Hello 张三
     Hello 李四
     ==========Hello 王五
     */
     ```

  2. jdk动态代理的实现

     反射包 java.lang.reflect , 里面有三个类 ：InvocationHandler，Method，Proxy

     

     1、InvocationHandler 接口(调用处理器)

     - 就一个方法 invoke()

     - invoke()：表示代理对象要执行的功能代码。你的代理类要完成的功能就写在invoke()方法中。

     - 代理类完成的功能：1.调用目标方法，执行目标方法的功能；2.功能增强，在目标方法调用时，增加功能。

       ```java
       public Object invoke(Object proxy, Method method, Object[] args) throws Throwable;
       /*
       参数：
       	proxy：jdk创建的代理对象，无需赋值。
       	method：目标类中的方法，jdk提供method对象的
           args：目标类中方法的参数，jdk提供的。
       */
       ```

     - 怎么用：

       1.创建类实现接口 InvocationHandler
       2.重写invoke() 方法， 把原来静态代理中代理类要完成的功能，写在这。

      

     2、Method类：

     - 表示方法的，确切的说就是目标类中的方法。

     - 作用：通过Method可以执行某个目标类的方法，Method.invoke()

       ```java
       public Object invoke ( Object obj, Object... args) 
       obj：表示目标对象
       args：表示目标方法参数，就是其上一层 invoke 方法的第三个参数
       
       Object ret = method.invoke(service2, "李四");
       ```

     - 说明：

       method.invoke()：就是用来执行目标方法的，等同于静态代理中的

       ```java
       //向厂家发送订单，告诉厂家，我买了u盘，厂家发货
       float price = factory.sell(amount); //厂家的价格。
       ```

      

     3、Proxy类：

     - 核心的对象，创建代理对象。

     - 之前创建对象都是 new 类的构造方法()

     - 现在我们是使用Proxy类的方法，代替new的使用。

       ```java
       //方法：静态方法 newProxyInstance() 
       //作用是：创建代理对象，等同于静态代理中的TaoBao taoBao = new TaoBao();
       public static Object newProxyInstance(ClassLoader loader,
                                             Class<?>[] interfaces,
                                             InvocationHandler h)
               						    throws IllegalArgumentException
       
       参数：
       1. ClassLoader loader 类加载器，负责向内存中加载对象的。使用反射获取对象的ClassLoader
       	类a, a.getCalss().getClassLoader(), 目标对象的类加载器
       2. Class<?>[] interfaces：接口，目标对象实现的接口，也是反射获取的。
       3. InvocationHandler h：我们自己写的，代理类要完成的功能。 
       
       返回值：就是代理对象
       ```

        

  3. 实现动态代理的步骤：

     - 创建接口，定义目标类要完成的功能
     - 创建目标类实现接口
     - 创建InvocationHandler接口的实现类，在invoke方法中完成代理类的功能
       1. 调用目标方法、
       2. 增强功能
     - 使用Proxy类的静态方法，创建代理对象。并把返回值转为接口类型。

```java
//接口
//表示功能的，厂家和商家都要完成的功能
public interface UsbSell {
    //定义方法 参数 amount：表示一次购买的数量，暂时不用
    //返回值表示一个U盘的价格
    float sell(int amount);

    //可以定义多个其他的方法
}
```

```java
//目标类实现接口
//目标类：金士顿厂家，不接受用户的单独购买
public class UsbKingFactory implements UsbSell {
    @Override
    public float sell(int amount) {
        System.out.println("目标类中的方法调用,UsbKingFactory中的sell ");
        //一个128G的U盘是85元
        //后期根据amount，可以实现不同的价格，例如10000个单价是80，50000个是75
        return 85.0f;
    }
}
```

```java
//必须实现InvocationHandler接口，完成代理类要做的功能(1.调用目标方法；2.增强功能)
public class MySellHandler implements InvocationHandler {
    private Object target = null;

    public MySellHandler(Object target) {
        this.target = target;
    }

    //动态代理：目标对象是活动的，不是固定的，需要传入进来
    //传入是谁，就给谁创建代理
    @Override
    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
        Object res = null;
        //向厂家发送订单，告诉厂家，我买了U盘，厂家发货
        res = method.invoke(target, args);//厂家的价格
        //商家 需要加价，也就是代理要增加价格
        if(res != null){
            Float price = (Float) res;
            price += 25;
            res = price;
        }
        //在目标类的方法调用后，你做的其它功能，都是增强的意思。
        System.out.println("淘宝商家，给你返一个优惠券，或者红包");
        //增加的价格
        return res;
    }
}
```

```java
public class MainShop {
    public static void main(String[] args) {
        //创建代理对象，使用Proxy
        //1.创建目标对象
        UsbSell factory = new UsbKingFactory();
        //2.创建InvocationHandler对象
        InvocationHandler handler = new MySellHandler(factory);
        //3.创建代理对象
        UsbSell proxy = (UsbSell) Proxy.newProxyInstance(factory.getClass().getClassLoader(), factory.getClass().getInterfaces(), handler);
        //4.通过代理执行方法
        float price = proxy.sell(1);
        System.out.println("通过动态代理对象，调用方法：" + price);
    }
}
```
# Maven

### 一、Maven简介

官网：http://maven.apache.org

##### 1.1 软件是一个工程

​	我们在日常生活常能听到工程这个词，像桥梁工程、道路工程、南水北调工程等等。

​	工程说简单点就是各个行业的从业人员通过总结规律或者方法，以最短的时间和人力、物力来做出高效可靠的东西。我们也就能理解桥梁工程，其实就是人们通过经验的总结和各种研究得出来的、用来修建桥梁时所采用的高效的方法，当然这种方法是可复用的。我们将这种作工程的思想应用到软件上，于是就产生了一软件工程。 

​	软件工程：**为了能够实现软件的流水线式生产，在设计和构建软件时能够有一种规范和工程化的方法，人们 便提出了软件工程概念。**

上面的内容做个日常生活的类比，做道菜就是一个工程。今天心情好，想吃红烧肉，自动动手做：

1. 想买什么猪的那个位置的肉，黑猪肉，土猪肉等，使用冰糖还是绵白糖，用什么牌子的酱油等；
2. 到菜市场购买各种原料；
3. 准备材料，洗肉，切块，花椒，大料等； 
4. 开始做了，肉下锅炖煮，不同时间加入花椒，大料，冰糖，酱油；
5. 炖煮一段时间后，看肉是否熟透，尝试口味，是不是咸了等等；
6. 做好了，开始吃了；
7. 需要刷碗，倒垃圾。

​	这些工作从头做到尾步骤非常繁琐，每个步骤都是费时费力的。所以才出现净菜，半成品菜，拿回家直接做可以了，只做6，7步骤就可以 。

​	软件开发需要编译代码—>开发人员自己测试代码—>把代码打包—>部署项目到测试服务器—>测试人员测试 功能—>测试测试出 bug 

​	开发人员需要修改bug—>开发人员自己测试代码—>把代码打包—>部署项目到测试服务器—>测试人员测试功 能—>直到符合功能要求。 

​	上述过程需要重复多次，大型项目中构建项目比较复杂，有很多的配置文件，jar 文件，多个子项目等等。都 用人力完成费时费力，效率比较低。maven 可以让我们从上面的工作中解脱出来。 



​	maven 是自动化构建工具。



完成一个java项目，需要做哪些工作？

1. 分析项目要做什么，知道项目有哪些组成部分。

2. 设计项目，通过哪些步骤，使用哪些技术。需要多少人， 多长的时间。

3. 组建团队，招人， 购置设备，服务器， 软件， 笔记本。

4. 开发人员写代码。 开发人员需要测试自己写代码。 重复多次的工作。

5. 测试人员，测试项目功能是否符合要求。

   测试开发人员提交代码----如果测试有问题----需要开发人员修改----在提交代码给测试
   ----测试人员在测试代码----如果还有问题-----在交给开发人员----开发人员在提交----再测试，直到测试代码通过。

   

##### 1.2 传统项目开发存在的问题

- 一个项目做成一个工程，造成工程比较庞大，需要使用多模块来划分项目
- 项目中需要的数量众多的 jar 包，需要手动下载并引入，并且多个项目需要的 jar 包存在重复的问题；
- 项目中需要的 jar 包有版本兼容的问题，需要手动解决；
- 项目中需要的 jar 包又依赖其它的 jar 包，需要手动解决。



传统开发项目的问题，没有使用maven【meivn】管理的项目

1. 很多模块，模块之间有关系，手工管理关系，比较繁琐。

2. 需要很多第三方功能，需要很多jar文件，需要手工从网络中获取各个jar

3. 需要管理jar的版本，你需要的是mysql.5.1.5.jar 拿你不能给一个mysql.4.0.jar

4. 管理jar文件之间的依赖，你的项目要使用a.jar 需要使用b.jar里面的类。

   必须首先获取到b.jar才可以，然后才能使用a.jar. 

a.jar需要b.jar这个关系叫做依赖，或者你的项目中要使用mysql的驱动，也可以叫做项目依赖mysql驱动。

a.class使用b.class， a依赖b类



##### 1.3 Maven 概述

​	Maven 是 Apache 软件基金会组织维护的一款自动化构建工具，专注服务于 Java 平台的项目构建和依赖管理。Maven 这个单词的本意是：专家，内行。

​	Maven 是目前最流行的自动化构建工具，对于生产环境下多框架、多模块整合开发有重要作用，Maven 是一款在大型项目开发过程中不可或缺的重要工具。

​	Maven 可以整合多个项目之间的引用关系，我们可以根据业务和分层需要任意拆分一个项目；

​	Maven 提供规范的管理各个常用 jar 包及其各个版本，并且可以自动下载和引入项目中； 

​	Maven 可以根据指定版本自动解决 jar 包版本兼容问题； 

​	Maven 可以把 jar 包所依赖的其它 jar 包自动下载并引入项目。 

​	类似自动化构建工具还有：Ant, Maven, Gradle。



需要改进项目的开发和管理，需要maven

1. maven可以管理jar文件
   
2. 自动下载jar和他的文档，源代码
   
3. 管理jar直接的依赖， a.jar需要b.jar ， maven会自动下载b.jar
   
4. 管理你需要的jar版本
   
5. 帮你编译程序，把java编译为class
   
6. 帮你测试你的代码是否正确。
   
7. 帮你打包文件，形成jar文件，或者war文件
   
8. 帮你部署项目



##### 1.4 构建(build)

构建（build），是面向过程的，就是一些步骤，完成项目代码的编译，测试，运行，打包，部署等等。

maven支持的构建包括有：

1. **清理**，把之前项目编译的东西删除掉，为新的编译代码做准备。
   
2. **编译**，把程序源代码编译为执行代码，java-class文件
   批量的，maven可以同时把成千上百的文件编译为class；javac 不一样，javac一次编译一个文件。
   
3. **测试**，maven可以执行测试程序代码，验证你的功能是否正确。批量的，maven同时执行多个测试代码，同时测试很多功能。
   
4. **报告**， 生成测试结果的文件，测试通过没有。
   
5. **打包**， 把你的项目中所有的class文件，配置文件等所有资源放到一个压缩文件中。这个压缩文件就是项目的结果文件， 通常java程序，压缩文件是jar扩展名的。对于web应用，压缩文件扩展名是.war
   
6. **安装**， 把5中生成的文件jar，war安装到本机仓库
   
7. **部署**， 把程序安装好可以执行。



##### 1.5 Maven核心概念

- POM：一个文件名称是pom.xml，pom翻译过来叫做项目对象模型。maven把一个项目当做一个模型使用。控制maven构建项目的过程，管理jar依赖。
- 约定的目录结构：maven项目的目录和文件的位置都是规定的。
- 坐标：是一个唯一的字符串，用来表示资源的。
- 依赖管理：管理你的项目可以使用jar文件
- 仓库管理：你的资源存放的位置
- 生命周期：maven工具构建项目的过程，就是生命周期。
- 插件和目标：执行maven构建的时候用的工具是插件
- 继承
- 聚合



##### 1.6 安装Maven环境

下载地址：http://maven.apache.org/download.cgi

1. 需要从maven的官网下载maven的安装包 apache-maven-3.8.1-bin.zip

2. 解压安装包，解压到一个目录，非中文目录。

   子目录 bin：执行程序，主要是mvn.cmd

   子目录 conf :maven工具本身的配置文件 settings.xml

3. 配置环境变量

   在系统的环境变量中，指定一个MAVEN_HOME的名称， 指定它的值是maven工具安装目录，bin之前的目录

   X:\newJava\Maven\apache-maven-3.8.1-bin\apache-maven-3.8.1

   再把MAVEN_HOME加入到path之中，在所有路径之前加入 %MAVEN_HOME%\bin;

4. 验证，新的命令行中，执行 mvn -v

   注意：需要配置JAVA_HOME ，指定jdk路径

   出现如下内容，maven安装，配置正确。
   	

   Apache Maven 3.8.1 (05c21c65bdfed0f71a2f2ada8b84da59348c4c5d)
   Maven home: X:\newJava\Maven\apache-maven-3.8.1-bin\apache-maven-3.8.1\bin\..
   Java version: 1.8.0_301, vendor: Oracle Corporation, runtime: X:\newJava\JDK8\jre
   Default locale: zh_CN, platform encoding: GBK
   OS name: "windows 10", version: "10.0", arch: "amd64", family: "windows"



### 二、Maven的核心概念

##### 2.1 项目约定的目录结构

maven约定的目录结构，约定是大家都遵循的一个规则。

每一个maven项目在磁盘中都是一个文件夹（项目-Hello）

```xml
Hello/
	---/src
	
	------/main               #放你主程序java代码和配置文件
	----------/java           #你的程序包和包中的java文件
	----------/resources      #你的java程序中要使用的配置文件
	
	------/test               #放测试程序代码和文件的（可以没有）
	----------/java           #测试程序包和包中的java文件
	----------/resources      #测试java程序中要使用的配置文件

	---/pom.xml               #maven的核心文件（maven项目必须有）
```



第一个 maven 工程

按照如下步骤，实现第一个 maven 项目，以 maven 推荐的约定方式创建目录，类文件。 

1. 某个目录中创建文件夹 Hello 

2. 在 Hello 中创建子目录 src 

3. 拷贝 pom.xml 到 Hello 目录和 src 是同级放置的。 

4. 进入 src 目录，创建 main，test目录 

5. 进入 main 目录，创建 java，resources 目录。 进入 java 目录，创建目录 com/bjpowernode/ 

6. 在 com/bjpowernode/目录下创建 HelloMaven.java 文件

   ```java
   package com.bjpowernode;
   public class HelloMaven {
     public int add(int n1,int n2){
       return n1+n2;
     }
   
     public static void main(String args[]){
         HelloMaven hello = new HelloMaven();
         int res = hello.add(10,20);
   	  System.out.println("10+20="+res);
     }
   }
   ```

7. 进入到 Hello 所在目录，执行 mvn compile  

8. 进入到 target/classes 目录执行 java com.bjpowernode.HelloMaven



疑问：mvn compile 编译 src/main 目录下的所有java文件的。

1. 为什么要下载

   maven工具执行的操作需要很多插件（java类--jar文件）完成的

2. 下载什么东西了

   jar文件--叫做插件--插件是完成某些功能

3. 下载的东西存放到哪里了。

   默认仓库（本机仓库）：C:\Users\（登录操作系统的用户名）Administrator\ .m2\repository



执行mvn compile，结果是在项目的根目录下生成target目录（结果目录）
	

maven编译的java程序，最后的class文件都放在target目录中



设置本机存放资源的目录位置(设置本机仓库)：
  	 

1. 修改maven的配置文件，maven安装目录/conf/settings.xml；需先备份 settings.xml

 2. 修改 <localRepository>  指定你的目录（不要使用中文目录）

     X:\newJava\Maven\maven_repository



##### 2.2 仓库

1. 仓库的概念

   现在我们对maven工程有一个大概的认识了，那现在思考一个问题，maven怎么就这么神奇，我们写完的工程交给他之后，他就能够自动帮我们管理，我们依赖的jar包它从哪儿获取呢？有同学说已经安装了，在它的安装包里啊，大家可以看一下maven下载下来才8M，我们需要的jar包有时候都几百兆甚至几个G，它从哪儿弄去呢？其实，maven有仓库的概念。在Maven中，任何一个依赖、插件或者项目构建的输出，都可以称之为构建。Maven核心程序仅仅定义了自动化构建项目的生命周期，但具体的构建工作是由特定的构件完成的。而且为了提高构建 的效率和构件复用，maven把所有的构件统一存储在某一个位置，这个位置就叫做仓库。

2. 仓库存什么

   仓库是存放东西的，Maven 仓库的是：

   - Maven 的插件，插件也是一些 jar，这些 jar 可以完成一定的功能。
   - 我们自己开发项目的模块
   - 第三方框架或工具的 jar 包

3. 仓库的分类

   - 本地仓库：本机当前电脑上的资源存储位置，为本机上所有 Maven工程提供服务
   - 远程仓库：不在本机上， 通过网络才能使用。多电脑共享使用的。
     1. 中央仓库：通过Internet访问，为全世界所有 Maven工程服务。最权威的。
     2. 中央仓库的镜像：就是中央仓库的备份，架设在不同位置，欧洲，美洲，亚洲等每个洲都有若干的服务器，为中央仓库分担流量。减轻中央仓库的访问，下载的压力。所在洲的用户首先访问的是本洲的镜像服务器。
     3. 私服：在局域网环境中部署的服务器，为当前局域网范围内的所有 Maven工程服务。公司中常常使用这种方式。

4. 仓库的使用

   maven仓库的使用不需要人为参与。

   开发人员需要使用mysql驱动 ---> maven首先查本地仓库 ---> 私服 ---> 镜像 ---> 中央仓库

​	 

##### 2.3 POM文件

即 Project Object Model 项目对象模型。Maven 把一个项目的结构和内容抽象成一个模型，在 xml 文件中进行声明，以方便进行构建和描述，pom.xml 是 Maven 的灵魂。所以，maven 环境搭建好之后，所有的学习和操作都是关于 pom.xml 的。

1. 坐标

   groupId：组织名，通常是公司或组织域名倒序+项目名 

   artifactId：模块名，通常是工程名 

   version：版本号

   唯一值， 在互联网中唯一标识一个项目的

   ```xml
   <groupId>公司域名的倒写</groupId>
   <artifactId>自定义项目名称</artifactId>
   <version>自定版本号</version>
   ```

   https://mvnrepository.com/  搜索使用的中央仓库，使用groupId 或者 artifactId作为搜索条件

2.  packaging：打包后压缩文件的扩展名，默认是jar，web应用是war

    packaging 可以不写，默认是jar

3.  依赖

   dependencies 和 dependency，相当于是 java代码中import

   你的项目中要使用的各种资源说明， 比我的项目要使用mysql驱动

   ```xml
   <dependencies>
   	<!--依赖  java代码中 import -->
   	<dependency>
   		<groupId>mysql</groupId>
   		<artifactId>mysql-connector-java</artifactId>
   		<version>5.1.9</version>
   	</dependency>
       
       <dependency>
    		<groupId>junit</groupId>
    		<artifactId>junit</artifactId>
    		<version>4.11</version>
       </dependency>
   </dependencies>
   ```

4. properties：设置属性

   ```xml
   <properties>
       <!--maven构建项目使用的是utf-8 ，避免中文的乱码-->
       <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
       <!--编译java代码使用的jdk版本-->
       <maven.compiler.source>1.8</maven.compiler.source>
       <!--你的java项目应该运行在什么样的jdk版本-->
       <maven.compiler.target>1.8</maven.compiler.target>
   </properties>
   ```

5. build：maven在进行项目的构建时，配置信息，例如指定编译java代码使用的jdk的版本等



##### 2.4 Maven生命周期、命令、插件

1. maven的生命周期：就是maven构建项目的过程；清理，编译，测试，报告，打包，安装，部署
2. maven的命令：maven独立使用，通过命令，完成maven的生命周期的执行。 maven可以使用命令，完成项目的清理，编译，测试等等
3. maven的插件：maven命令执行时，真正完成功能的是插件，插件就是一些jar文件、一些类。



- 单元测试（测试方法）：用的是junit， junit是一个专门测试的框架（工具）。

  junit测试的内容： 测试的是类中的方法， 每一个方法都是独立测试的。方法是测试的基本单位（单元）。

  maven借助单元测试，批量的测试你类中的大量方法是否符合预期的。

- 使用步骤

  1. 加入依赖，在pom.xml加入单元测试依赖

     ```xml
     <!-- 单元测试 -->
     <dependency>
     	<groupId>junit</groupId>
     	<artifactId>junit</artifactId>
     	<version>4.11</version>
     	<scope>test</scope>
     </dependency>
     ```

  2. 在maven项目中的src/test/java目录下，创建测试程序。

     推荐的创建类和方法的提示：

     1.测试类的名称 是Test + 你要测试的类名
     		 

     2.测试的方法名称 是：Test + 方法名称

     例如你要测试HelloMaven，创建测试类 TestHelloMaven

     ```java
     @Test
     public void testAdd(){
     	//测试HelloMaven的add方法是否正确
         int res  = 20 + 10;
         //期望值 实际值
         Assert.assertEquals(30, res);
     }
     
     /*
     其中testAdd叫做测试方法，它的定义规则
     	1.方法是public的，必须的
     	2.方法没有返回值， 必须的
     	3.方法名称是自定义的，推荐是Test + 方法名称
     	4.在方法的上面加入 @Test
     */
     ```

  3. mvn compile 

     编译main/java/目录下的 java 为 class 文件，同时把 class 拷贝到 target/classes 目录下面

     把 main/resources 目录下的所有文件都拷贝到 target/classes 目录下



- Maven的常用命令
  1. mvn clean 清理 (会删除原来编译和测试的目录，即 target 目录，但是已经 install 到仓库里的包不会删除)
  2. mvn compile 编译主程序 (会在当前目录下生成一个 target，里边存放编译主程序之后生成的字节码文件)
  3. mvn test-compile 编译测试程序(会在当前目录下生成一个 target,里边存放编译测试程序之后生成的字节码文件)
  4. mvn test 测试 (会生成一个目录surefire-reports，保存测试结果)
  5. mvn package 打包主程序(会编译、编译测试、测试、并且按照 pom.xml 配置把主程序打包生成 jar 包或者 war 包)
  6. mvn install 安装主程序(会把本工程打包，并且按照本工程的坐标保存到本地仓库中)
  7. mvn deploy 部署主程序(会把本工程打包，按照本工程的坐标保存到本地库中，并且还会保存到私服仓库中。 还会自动把项目部署到 web 容器中)。



- 插件

  官网插件说明：http://maven.apache.org/plugins

  在项目根目录下执：mvn clean install

  1. clean 插件 maven-clean-plugin:2.5

     clean 阶段是独立的一个阶段，功能就是清除工程目前下的 target 目录

  2. resources 插件 maven-resources-plugin:2.6

     resource 插件的功能就是把项目需要的配置文件拷贝到指定的目当，默认是拷贝 src\main\resources 目录下的件到 classes 目录下

  3. compile 插件 maven-compiler-plugin

     compile 插件执行时先调用 resouces 插件，功能就是把 src\mainjava 源码编译成字节码生成 class 文件，并把编译好 的 class 文件输出到 target\classes 目录下

  4. test 测试插件

     单元测试所用的 compile 和 resources 插件和主代码是相同的，但执行的目标不行，目标 testCompile 和 testResources 是把 src\test\java 下的代码编译成字节码输出到 target\test-classes，同时把 src\test\resources 下的配置文件拷贝到 target\test-classes

  5. package 打包插件 maven-jar-plugin

     这个插件是把 class 文件、配置文件打成一个 jar(war 或其它格式)包

  6. deploy 发布插件 maven-install-plugin

     发布插件的功能就是把构建好的 artifact 部署到本地仓库，还有一个 deploy 插件是将构建好的 artifact 部署到远程 仓库

  7. 配置插件

     ```xml
     <build>
         <!--配置插件-->
     	<plugins> 
              <!--配置具体的插件-->
     		<plugin> 
     			<groupId>org.apache.maven.plugins</groupId>
                  <!--插件的名称-->
     			<artifactId>maven-compiler-plugin</artifactId>
                  <!--插件的版本-->
     			<version>3.8.1</version>
                 <!--配置插件的信息-->
     			<configuration> 
                      <!--告诉maven我们写的代码是在jdk1.8上编译的-->
     				<source>1.8</source> 
                      <!--我们的程序应该运行在jdk1.8环境上-->
     				<target>1.8</target> 
     			</configuration> 
     		</plugin> 
     	</plugins> 
     </build>
     ```



### 三、Maven 在 IDEA 中的应用

##### 3.1  IDEA 集成 Maven

在idea中设置maven，让idea和maven结合使用。 

idea中内置了maven，一般不使用内置的， 因为用内置修改maven的设置不方便。

使用自己安装的maven，需要覆盖idea中的默认的设置。让idea指定maven安装位置等信息

配置的入口 ：

1. 配置当前工程的设置：

   file---> settings ---> Build, Excution,Deployment --->Build Tools
    --->Maven 

   ---Maven

   Maven Home directory: maven的安装目录
   							

   User Settings File :  就是maven安装目录conf/setting.xml配置文件
   							

   Local Repository :    本机仓库的目录位置

   ![image-20220122204927025](https://cdn.jsdelivr.net/gh/xukang0509/picgo_bed/img/202201232030665.png)

   --->Build Tools--->Maven--->Runner

   VM Options : archetypeCatalog=internal
   						  

   JRE: 你项目的jdk

   archetypeCatalog=internal , maven项目创建时，会联网下载模版文件，
   						  

   比较大， 使用 archetypeCatalog=internal，不用下载， 创建maven项目速度快。

   ![image-20220122205122876](https://cdn.jsdelivr.net/gh/xukang0509/picgo_bed/img/202201232030684.png)

2. 配置以后新建工程的设置

   file---> other settings---> Settings for New Project



使用模版创建项目

1. maven-archetype-quickstart : 普通的java项目
2. maven-archetype-webapp : web工程



##### 3.2 IDEA创建Maven版Java工程

1. 创建maven版java工程

   File-->New-->Module…：

![image-20220123182153398](https://cdn.jsdelivr.net/gh/xukang0509/picgo_bed/img/202201232030702.png)

2. 填写工程名和存储路径以及 maven 工程的坐标

![image-20220123182246000](https://cdn.jsdelivr.net/gh/xukang0509/picgo_bed/img/202201232030214.png)

3. 确定maven路径，点击finish

![image-20220123182326605](https://cdn.jsdelivr.net/gh/xukang0509/picgo_bed/img/202201232030848.png)

4. pom.xml

   ```xml
   <?xml version="1.0" encoding="UTF-8"?>
   
   <project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
     xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
     <modelVersion>4.0.0</modelVersion>
   
     <!-- 自己项目的坐标（gav)-->
     <groupId>org.example</groupId>
     <artifactId>ch01_maven_java</artifactId>
     <version>1.0-SNAPSHOT</version>
     <packaging>jar</packaging>
   
     <properties>
       <!--maven构建项目使用的是utf-8 ，避免中文的乱码-->
       <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
       <!--编译java代码使用的jdk版本-->
       <maven.compiler.source>1.8</maven.compiler.source>
       <!--你的java项目应该运行在什么样的jdk版本-->
       <maven.compiler.target>1.8</maven.compiler.target>
     </properties>
   
     <!--依赖-->
     <dependencies>
       <dependency>
         <!--单元测试-->
         <groupId>junit</groupId>
         <artifactId>junit</artifactId>
         <version>4.11</version>
         <scope>test</scope>
       </dependency>
     </dependencies>
   
     <build>
       <pluginManagement><!-- lock down plugins versions to avoid using Maven defaults (may be moved to parent pom) -->
         <plugins>
           <!-- clean lifecycle, see https://maven.apache.org/ref/current/maven-core/lifecycles.html#clean_Lifecycle -->
           <plugin>
             <artifactId>maven-clean-plugin</artifactId>
             <version>3.1.0</version>
           </plugin>
           <!-- default lifecycle, jar packaging: see https://maven.apache.org/ref/current/maven-core/default-bindings.html#Plugin_bindings_for_jar_packaging -->
           <plugin>
             <artifactId>maven-resources-plugin</artifactId>
             <version>3.0.2</version>
           </plugin>
           <plugin>
             <artifactId>maven-compiler-plugin</artifactId>
             <version>3.8.0</version>
           </plugin>
           <plugin>
             <artifactId>maven-surefire-plugin</artifactId>
             <version>2.22.1</version>
           </plugin>
           <plugin>
             <artifactId>maven-jar-plugin</artifactId>
             <version>3.0.2</version>
           </plugin>
           <plugin>
             <artifactId>maven-install-plugin</artifactId>
             <version>2.5.2</version>
           </plugin>
           <plugin>
             <artifactId>maven-deploy-plugin</artifactId>
             <version>2.8.2</version>
           </plugin>
           <!-- site lifecycle, see https://maven.apache.org/ref/current/maven-core/lifecycles.html#site_Lifecycle -->
           <plugin>
             <artifactId>maven-site-plugin</artifactId>
             <version>3.7.1</version>
           </plugin>
           <plugin>
             <artifactId>maven-project-info-reports-plugin</artifactId>
             <version>3.0.0</version>
           </plugin>
         </plugins>
       </pluginManagement>
     </build>
   </project>
   ```



##### 3.3 IDEA创建Maven版Web工程

![image-20220123190006170](https://cdn.jsdelivr.net/gh/xukang0509/picgo_bed/img/202201232030392.png)

![image-20220123190009982](https://cdn.jsdelivr.net/gh/xukang0509/picgo_bed/img/202201232030620.png)

![image-20220123190022508](https://cdn.jsdelivr.net/gh/xukang0509/picgo_bed/img/202201232030012.png)

![image-20220123190229821](https://cdn.jsdelivr.net/gh/xukang0509/picgo_bed/img/202201232030409.png)



```xml
<!--加入依赖-->
<dependencies>
    <!--单元测试-->
    <dependency>
      <groupId>junit</groupId>
      <artifactId>junit</artifactId>
      <version>4.11</version>
      <scope>test</scope>
    </dependency>
    <!--加入servlet依赖(servlet的jar)-->
    <dependency>
      <groupId>javax.servlet</groupId>
      <artifactId>javax.servlet-api</artifactId>
      <version>3.1.0</version>
      <scope>provided</scope>
    </dependency>
    <!--jsp依赖(jsp相关的jar加入进来)-->
    <dependency>
      <groupId>javax.servlet.jsp</groupId>
      <artifactId>jsp-api</artifactId>
      <version>2.1</version>
      <scope>provided</scope>
    </dependency>
</dependencies>
```



##### 3.4  IDEA 中导入 Maven 工程(module)

项目结构---> modules ---> + ---> import module

![image-20220123193845364](https://cdn.jsdelivr.net/gh/xukang0509/picgo_bed/img/202201232030446.png)



选择要导入的 Module

![image-20220123193933678](https://cdn.jsdelivr.net/gh/xukang0509/picgo_bed/img/202201232030558.png)



选择导入方式

![image-20220123194028805](https://cdn.jsdelivr.net/gh/xukang0509/picgo_bed/img/202201232030929.png)



设置依赖管理

![image-20220123194326407](https://cdn.jsdelivr.net/gh/xukang0509/picgo_bed/img/202201232030159.png)





##### 3.5 依赖管理

依赖范围，使用scope表示的

scope 的值有 compile、test、provided，默认是compile；

- compile：默认，在构建的编译，测试，打包，部署阶段需要

- test：只在测试阶段需要

- provided：在部署时，有服务器提供，根本就不需要自带

  

scope：表示依赖使用的范围，也就是在maven构建项目的那些阶段中起作用；

maven构建项目  编译，测试，打包，安装，部署 过程（阶段）



|                    | compile | test | provided |
| ------------------ | ------- | ---- | -------- |
| 对主程序是否有效   | 是      | 否   | 是       |
| 对测试程序是否有效 | 是      | 是   | 是       |
| 是否参与打包       | 是      | 否   | 否       |
| 是否参与部署       | 是      | 否   | 否       |



```xml
	junit的依赖范围是 test
	<dependency>
      <groupId>junit</groupId>
      <artifactId>junit</artifactId>
      <version>4.11</version>
      <scope>test</scope>
    </dependency>

	<dependency>
      <groupId>a</groupId>
      <artifactId>b</artifactId>   b.jar
      <version>4.11</version>
    </dependency>

	 <dependency>
      <groupId>javax.servlet</groupId>
      <artifactId>javax.servlet-api</artifactId>
      <version>3.1.0</version>          servlet.jar
      <scope>provided</scope>  提供者
     </dependency>
```



你在写项目的中的用到的所有依赖（jar ），必须在本地仓库中有；没有必须通过maven下载，包括provided的都必须下载。

你在servlet需要继承HttpServlet( provided)，你使用的HttpServlet是maven仓库中的。

当你的写好的程序，放到 tomat 服务器中运行时，此时你的程序中不包含servlet的jar
因为 tomcat 提供了 servlet 的.jar



##### 3.6 maven常用设置

1. maven的属性设置

   <properties> 设置maven的常用属性

   ```xml
   <properties>
       <!--maven构建项目使用的是utf-8 ，避免中文的乱码-->
       <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
       <!--编译java代码使用的jdk版本-->
       <maven.compiler.source>1.8</maven.compiler.source>
       <!--你的java项目应该运行在什么样的jdk版本-->
       <maven.compiler.target>1.8</maven.compiler.target>
   </properties>
   ```

2. maven的全局变量

   自定义的属性：

   1. 在<properties> 通过自定义标签声明变量（标签名就是变量名）

   	2. 在pom.xml文件中的其它位置，使用 ${标签名} 使用变量的值



自定义全局变量一般是定义依赖的版本号，当你的项目中要使用多个相同的版本号，先使用全局变量定义，在使用${变量名}

```xml
<properties>
    <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
    <maven.compiler.source>1.8</maven.compiler.source>
    <maven.compiler.target>1.8</maven.compiler.target>
    <!--自定义变量，表示版本号-->
    <spring.version>5.2.5.RELEASE</spring.version>
</properties>

<dependencies>
    <!--spring依赖-->
    <dependency>
      <groupId>org.springframework</groupId>
      <artifactId>spring-core</artifactId>
      <version>${spring.version}</version>
    </dependency>
    <dependency>
      <groupId>org.springframework</groupId>
      <artifactId>spring-aop</artifactId>
      <version>${spring.version}</version>
    </dependency>
    <dependency>
      <groupId>org.springframework</groupId>
      <artifactId>spring-context</artifactId>
      <version>${spring.version}</version>
    </dependency>
</dependencies>
```



3. 指定资源位置插件

   src/main/java 和 src/test/java 这两个目录中的所有 *.java 文件会分别在 comile 和 test-comiple 阶段被编译，编译结果分别放到了 target/classes 和 targe/test-classes 目录中，但是这两个目录中的其他文件都会被忽略掉，如果需要把 src 目录下的文件包放到 target/classes 目录，作为输出的 jar 一部分。需要指定资源文件位置。以下内容放到标签中。

   ```xml
     <build>
   	<resources>
   		<resource>
                <!--所在的目录-->
   			<directory>src/main/java</directory>
   			<includes>
                     <!--包括目录下的 .properties, .xml文件都会扫描到-->
   				<include>**/*.properties</include>
   				<include>**/*.xml</include>
   			</includes>
   			<!-- fltering 选项 false 不启用过滤器， *.property 已经起到过滤的作用了 -->
   			<filtering>false</filtering>
   		</resource>
   	</resources>
     </build>
   ```

   作用：mybatis课程中会用到这个作用

   默认没有使用resources的时候，maven执行编译代码时，会把src/main/resource目录中的文件拷贝到target/classes目录中。

   我们的程序有需要把一些文件放在 src/main/java 目录中，当我们在执行java程序时，需要用到 src/main/java 目录中的文件；就需要告诉 maven 在 mvn compile src/main/java 目录下的程序时，需要把文件一同拷贝到 target/classes 目录中；此时就需要在 <build> 中加入 <resources>
# MyBatis

### 一、框架概述

##### 1 软件开发常用结构

1. 三层架构

   三层架构包含的三层：

   - 用户界面层（User Interface layer）		   controller包（XXXServlet类）          
   - 业务逻辑层（Business Logic Layer）		service包（XXXService类）
   - 数据访问层（Data access layer）			  dao包（XXXDao类） 

   三层的职责：

   1. 用户界面层（表示层，视图层）：主要功能是接受用户的数据，显示请求的处理结果。使用 web 页面和用户交互，手机 app 也就是表示层的，用户在 app 中操作，业务逻辑在服务器端处理。
   2. 业务逻辑层：接收表示层传递过来的数据，检查数据，计算业务逻辑，调用数据访问层获取数据。
   3. 数据访问层：与数据库打交道。主要实现对数据的增、删、改、查。将存储在数据库中的数据提交给业务层，同时将业务层处理的数据保存到数据库。

   三层的处理请求的交互：

   ​	用户界面层 ---> 业务逻辑层 ---> 数据访问层（持久层） ---> 数据库（MySql）

   三层对应的处理框架

   - 界面层  ---  servlet ---  springmvc（框架）
     
   - 业务逻辑层  ---  service类  ---  spring（框架）
     
   - 数据访问层  ---  dao类  --- mybatis（框架）

   为什么要使用三层？

   1. 结构清晰、耦合度低,、各层分工明确； 
   2. 可维护性高，可扩展性高； 
   3. 有利于标准化； 
   4. 开发人员可以只关注整个结构中的其中某一层的功能实现； 
   5. 有利于各层逻辑的复用。

2. 常用框架

   常见的 J2EE 中开发框架：

   - MyBatis 框架： 

     ​	MyBatis 是一个优秀的基于 java 的持久层框架，内部封装了 jdbc，开发者只需要关注 sql 语句本身，而不需要处理加载驱动、创建连接、创建 statement、关闭连接，资源等繁杂的过程。 

     ​	MyBatis 通过 xml 或注解两种方式将要执行的各种 sql 语句配置起来，并通过 java 对象和 sql 的动态参数进行映射生成最终执行的 sql 语句，最后由 mybatis 框架执行 sql 并将结果映射为 java 对象并返回。

   - Spring 框架： 

     ​	Spring 框架为了解决软件开发的复杂性而创建的。Spring 使用的是基本的 JavaBean 来完成以前非常复杂的企业级开发。Spring 解决了业务对象，功能模块之间的耦合，不仅在 javase、web 中使用， 大部分 Java 应用都可以从 Spring 中受益。 

     ​	Spring 是一个轻量级控制反转(IoC)和面向切面(AOP)的容器。

   - SpringMVC 框架： 

     ​	Spring MVC 属于 SpringFrameWork 3.0 版本加入的一个模块，为 Spring 框架提供了构建 Web 应用程序的能力。现在可以 Spring 框架提供的 SpringMVC 模块实现 web 应用开发，在 web 项目中可以无缝使用 Spring 和 Spring MVC 框架。

     

##### 2 框架是什么

1. 框架定义

   - 框架（Framework）是整个或部分系统的可重用设计，表现为一组抽象构件及构件实例间交互的方法；另一种认为，框架是可被应用开发者定制的应用骨架、模板。 
   - 简单的说，框架其实是半成品软件，就是一组组件，供你使用完成你自己的系统。从另一个角度来说框架是一个舞台，你在舞台上做表演。在框架基础上加入你要完成的功能。 
   - 框架是安全的，可复用的，不断升级的软件。

2. 框架解决的问题

   ​	框架要解决的最重要的一个问题是技术整合，在 J2EE 的 框架中，有着各种各样的技术，不同的应用，系统使用不同的技术解决问题。需要从 J2EE 中选择不同的技术，而技术自身的复杂性，有导致更大的风险。企业在开发软件项目时，主要目的是解决业务问题。 即要求企业负责技术本身，又要求解决业务问题。这是大多数企业不能完成的。框架把相关的技术融合在一起，企业开发可以集中在业务领域方面。 

   ​	另一个方面可以提供开发的效率。

3. 框架特点

   - 框架一般不是全能的， 不能做所有事情

   - 框架是针对某一个领域有效。 特长在某一个方面，比如mybatis做数据库操作强，但是他不能做其它的。

   - 框架是一个软件

     

##### 3 JDBC编程

1. 使用 JDBC 编程的回顾

   ```java
   public class JDBCTest05 {
       public static void main(String[] args) {
           Connection conn = null;
           Statement stmt = null;
           ResultSet resultSet = null;
           try {
               //1、注册驱动
               Class.forName("com.mysql.jdbc.Driver");
               //2、获取连接
               conn = DriverManager.getConnection("jdbc:mysql://localhost:3306/bjpowernode","root","111");
               //3、获取数据库操作对象
               stmt = conn.createStatement();
               //4、执行SQL
               String sql = "select empno as a, ename, sal from emp";
               resultSet = stmt.executeQuery(sql);//专门执行DQL语句的方法
               //5、处理查询结果集
               while(resultSet.next()){
                   int empno = resultSet.getInt("a");
                   String ename = resultSet.getString("ename");
                   double sal = resultSet.getDouble("sal");
                   System.out.println(empno + "," + ename + "," + sal);
               }
           }catch (SQLException e){
               e.printStackTrace();
           } catch (ClassNotFoundException e) {
               e.printStackTrace();
           } finally {
               //6、释放资源
               if(resultSet != null){
                   try {
                       resultSet.close();
                   } catch (SQLException e) {
                       e.printStackTrace();
                   }
               }
               if(stmt != null){
                   try {
                       stmt.close();
                   } catch (SQLException e) {
                       e.printStackTrace();
                   }
               }
               if(conn != null){
                   try {
                       conn.close();
                   } catch (SQLException e) {
                       e.printStackTrace();
                   }
               }
           }
       }
   }
   ```

2. 使用 JDBC 的缺陷

   - 代码比较多，开发效率低 
   - 需要关注 Connection，Statement，ResultSet 对象的创建和销毁 
   - 对 ResultSet 查询的结果，需要自己封装为 List 
   - 重复的代码比较多些 
   - 业务代码和数据库的操作混在一起



##### 4 MyBatis框架概述

MyBatis 框架： 

​	MyBatis 本是 apache 的一个开源项目 iBatis，2010 年这个项目由 apache software foundation 迁移到了 google code，并且改名为 MyBatis 。2013 年 11 月迁移到 Github。 

​	iBATIS 一词来源于 “internet” 和 “abatis” 的组合，是一个基于 Java 的持久层框架。iBATIS 提供的持久层框架包括 SQL Maps 和 Data Access Objects（DAOs） 



MyBatis 解决的主要问题：

​	减轻使用 JDBC 的复杂性，不用编写重复的创建 Connetion，Statement；不用编写关闭资源代码。直接使用 java 对象，表示结果数据。让开发者专注 SQL 的处理。 其他分心的工作由 MyBatis 代劳。

​	Mybatis可以完成：

1. 注册数据库的驱动，例如 Class.forName(“com.mysql.jdbc.Driver”)) 

2. 创建 JDBC 中必须使用的 Connection，Statement，ResultSet 对象 

3. 从 xml 中获取 sql，并执行 sql 语句，把 ResultSet 结果转换 java 对象(List集合)

   ```java
   List<Student> list = new ArrayLsit<>();
   ResultSet rs = state.executeQuery(“select * from student”);
   while(rs.next()){
   	Student student = new Student();
   	student.setName(rs.getString(“name”));
   	student.setAge(rs.getInt(“age”));
   	list.add(student);
   }
   ```

4. 关闭资源

   ResultSet.close()，Statement.close()，Conenection.close()



mybatis 是 MyBatis SQL Mapper Framework for Java （sql映射框架）

sql mapper：sql映射，可以把数据库表中的一行数据映射为 一个java对象。
一行数据可以看做是一个java对象。操作这个对象，就相当于操作表中的数据

Data Access Objects（DAOs） ：数据访问，对数据库执行增删改查。



开发人员只需要做的是：提供 sql 语句

最后是：开发人员提供sql语句 ---> mybatis处理sql ---> 开发人员得到List集合或java对象（表中的数据）



总结：
mybatis是一个sql映射框架，提供的数据库的操作能力。增强的JDBC，使用mybatis让开发人员集中精神写sql就可以了，不必关心Connection，Statement，ResultSet
的创建，销毁，sql的执行。



### 二、MyBatis 快速入门

##### 1 入门案例

```
实现步骤：
1.新建student表
2.加入maven的mybatis坐标，mysql驱动的坐标
3.创建实体类，Student -- 保存表中的一行数据
4.创建持久层的dao接口，定义操作数据库的方法
5.创建一个mybatis使用的配置文件
  就做sql映射文件：写sql语句的，一般一个表一个sql映射文件。这个文件是xml文件
  1.在dao接口所在的目录中
  2.文件名称和接口保持一致
  
6.创建mybatis的主配置文件
  一个项目就一个主配置文件。
  主配置文件提供了数据库的连接信息和sql映射文件的位置信息
7.创建使用mybatis类
  通过mybatis访问数据库
```

###### 1.1 使用 MyBatis 准备

下载MyBatis：https://github.com/mybatis/mybatis-3/releases



###### 1.2 搭建 MyBatis 开发环境

1. 创建 mysql 数据库和表

   数据库名springdb：表名student

   ![image-20220207220957079](https://cdn.jsdelivr.net/gh/xukang0509/picgo_bed/img/202202121845240.png)

   ```mysql
   CREATE TABLE `student` (
    `id` int(11) NOT NULL ,
    `name` varchar(255) DEFAULT NULL,
    `email` varchar(255) DEFAULT NULL,
    `age` int(11) DEFAULT NULL,
    PRIMARY KEY (`id`)
   ) ENGINE=InnoDB DEFAULT CHARSET=utf8;
   ```

2.  创建Maven工程

    创建Maven工程，信息如下：

   ![image-20220207221601827](https://cdn.jsdelivr.net/gh/xukang0509/picgo_bed/img/202202121845585.png)

    工程坐标：

   ![image-20220207230025956](https://cdn.jsdelivr.net/gh/xukang0509/picgo_bed/img/202202121845784.png)

3.  删除默认的App类文件

   ![image-20220207230032031](https://cdn.jsdelivr.net/gh/xukang0509/picgo_bed/img/202202121845365.png)

4.  加入 maven 坐标

   pom.xml 加入 maven 坐标：

   ```xml
   <dependencies>
       <dependency>
         <groupId>junit</groupId>
         <artifactId>junit</artifactId>
         <version>4.11</version>
         <scope>test</scope>
       </dependency>
       <!--mybatis依赖-->
       <dependency>
         <groupId>org.mybatis</groupId>
         <artifactId>mybatis</artifactId>
         <version>3.5.9</version>
       </dependency>
       <!--mysql驱动-->
       <dependency>
         <groupId>mysql</groupId>
         <artifactId>mysql-connector-java</artifactId>
         <version>5.1.9</version>
       </dependency>
     </dependencies>
   ```

5.  加入 maven 插件

   ```xml
   <build>
       <resources>
         <resource>
           <directory>src/main/java</directory><!--所在的目录-->
           <includes><!--包括目录下的.properties,.xml 文件都会扫描到-->
             <include>**/*.properties</include>
             <include>**/*.xml</include>
           </includes>
           <filtering>false</filtering>
         </resource>
       </resources>
   
       <plugins>
         <plugin>
           <artifactId>maven-compiler-plugin</artifactId>
           <version>3.1</version>
           <configuration>
             <source>1.8</source>
             <target>1.8</target>
           </configuration>
         </plugin>
       </plugins>
     </build>
   ```

6.  编写 Student 实体类

   创建包 com.helloMyBatis.entity, 包中创建 Student 类

   ```java
   package com.helloMyBatis.entity;
   //推荐和表名一样，容易记忆
   public class Student {
       private Integer id;
       private String name;
       private String email;
       private Integer age;
   	//get set toString
   }
   ```
   
7.  编写 Dao 接口 StudentDao

   创建 com.helloMyBatis.dao 包，创建 StudentDao 接口

   ```java
   package com.helloMyBatis.dao;
   
   import com.helloMyBatis.entity.Student;
   import java.util.List;
   
   //接口操作student表
   public interface StudentDao {
       //查询student表中所有的数据
       List<Student> selectStudents();
   }
   ```
   
8.  编写 Dao 接口 Mapper 映射文件 StudentDao.xml

   要求： 

   1. 在 dao 包中创建文件 StudentDao.xml  
   2. 要 StudentDao.xml 文件名称和接口 StudentDao.java 一样，区分大小写。

   ```xml
   <?xml version="1.0" encoding="UTF-8" ?>
   <!DOCTYPE mapper
           PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
           "http://mybatis.org/dtd/mybatis-3-mapper.dtd">
   <mapper namespace="com.helloMyBatis.dao.StudentDao">
   <!--
       sql映射文件（sql mapper）：写sql语句的，mybatis会执行这些sql
       1.指定约束文件
           <!DOCTYPE mapper
               PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
               "http://mybatis.org/dtd/mybatis-3-mapper.dtd">
   
           mybatis-3-mapper.dtd是约束文件的名称， 扩展名是dtd的。
       2.约束文件作用：限制，检查在当前文件中出现的标签，属性必须符合mybatis的要求。
   
       3.mapper 是当前文件的根标签，必须的。
       namespace：叫做命名空间，唯一值的，可以是自定义的字符串。
              要求你使用dao接口的全限定名称。
   
       4.在当前文件中，可以使用特定的标签，表示数据库的特定操作。
       <select>:表示执行查询，select语句
       <update>:表示更新数据库的操作， 就是在<update>标签中 写的是update sql语句
       <insert>:表示插入， 放的是insert语句
       <delete>:表示删除， 执行的delete语句
   -->
   
       <!--
          select:表示查询操作。
          id: 你要执行的sql语法的唯一标识，mybatis会使用这个id的值来找到要执行的sql语句
              可以自定义，但是要求你使用接口中的方法名称。
   
          resultType:表示结果类型的， 是sql语句执行后得到ResultSet,遍历这个ResultSet得到java对象的类型。
          值写的类型的全限定名称
       -->
       <select id="selectStudents" resultType="com.helloMyBatis.entity.Student" >
           select id,name,email,age from student order by id
       </select>
   </mapper>
   ```
   
9.  创建 MyBatis 主配置文件

   项目 src/main 下创建 resources 目录，设置 resources 目录为 resources Root 

   创建主配置文件：名称为 mybatis.xml  

   说明：主配置文件名称是自定义的，

   内容如下：

   ```xml
   <?xml version="1.0" encoding="UTF-8" ?>
   <!DOCTYPE configuration
           PUBLIC "-//mybatis.org//DTD Config 3.0//EN"
           "http://mybatis.org/dtd/mybatis-3-config.dtd">
   <configuration>
       <!--settings：控制 mybatis全局行为-->
       <settings>
           <!--设置mybatis输出日志-->
           <setting name="logImpl" value="STDOUT_LOGGING" />
       </settings>
   
       <!--环境配置： 数据库的连接信息
           default:必须和某个environment的id值一样。
           告诉mybatis使用哪个数据库的连接信息。也就是访问哪个数据库
       -->
       <environments default="mydev">
           <!--
               environment : 一个数据库信息的配置， 环境
               id:一个唯一值，自定义，表示环境的名称。
           -->
           <environment id="mydev">
               <!--
                  transactionManager ：mybatis的事务类型
                  type: JDBC(表示使用jdbc中的Connection对象的commit，rollback做事务处理)
               -->
               <transactionManager type="JDBC"/>
               <!--
                  dataSource:表示数据源，连接数据库的
                  type：表示数据源的类型， POOLED表示使用连接池
               -->
               <dataSource type="POOLED">
                   <!--
                      driver, user, username, password 是固定的，不能自定义。
                   -->
                   <!--数据库的驱动类名-->
                   <property name="driver" value="com.mysql.jdbc.Driver"/>
                   <!--连接数据库的url字符串-->
                   <property name="url" value="jdbc:mysql://localhost:3306/springdb"/>
                   <!--访问数据库的用户名-->
                   <property name="username" value="root"/>
                   <!--密码-->
                   <property name="password" value="111"/>
               </dataSource>
           </environment>
   
           <!--表示线上的数据库，是项目真实使用的库-->
           <environment id="online">
               <transactionManager type="JDBC"/>
               <dataSource type="POOLED">
                   <property name="driver" value="com.mysql.jdbc.Driver"/>
                   <property name="url" value="jdbc:mysql://localhost:3306/onlinedb"/>
                   <property name="username" value="root"/>
                   <property name="password" value="fhwertwr"/>
               </dataSource>
           </environment>
       </environments>
   
       <!-- sql mapper(sql映射文件)的位置-->
       <mappers>
           <!--一个mapper标签指定一个文件的位置。
              从类路径开始的路径信息。  target/clasess(类路径)
              可多次
           -->
           <mapper resource="com/helloMyBatis/dao/StudentDao.xml"/>
           <!--<mapper resource="com/helloMyBatis/dao/SchoolDao.xml" />-->
       </mappers>
   </configuration>
   <!--
   mybatis的主配置文件： 主要定义了数据库的配置信息， sql映射文件的位置
   1. 约束文件
       <!DOCTYPE configuration
           PUBLIC "-//mybatis.org//DTD Config 3.0//EN"
           "http://mybatis.org/dtd/mybatis-3-config.dtd">
   
        mybatis-3-config.dtd：约束文件的名称
   
   2. configuration 根标签。
   -->
   ```

10.  创建测试类 MyApp

    ```java
    package com.helloMyBatis;
    
    import com.helloMyBatis.entity.Student;
    import org.apache.ibatis.io.Resources;
    import org.apache.ibatis.session.SqlSession;
    import org.apache.ibatis.session.SqlSessionFactory;
    import org.apache.ibatis.session.SqlSessionFactoryBuilder;
    
    import java.io.IOException;
    import java.io.InputStream;
    import java.util.List;
    
    public class MyApp {
        public static void main(String[] args) throws IOException {
            //访问mybatis读取student数据
            //1.定义mybatis主配置文件的名称, 从类路径的根开始（target/clasess）
            String config="mybatis.xml";
            //2.读取这个config表示的文件
            InputStream in = Resources.getResourceAsStream(config);
            //3.创建了SqlSessionFactoryBuilder对象
            SqlSessionFactoryBuilder builder  = new SqlSessionFactoryBuilder();
            //4.创建SqlSessionFactory对象
            SqlSessionFactory factory = builder.build(in);
            //5.获取SqlSession对象，从SqlSessionFactory中获取SqlSession
            SqlSession sqlSession = factory.openSession();
            //6.【重要】指定要执行的sql语句的标识。sql映射文件中的namespace + "." + 标签的id值(方法名)
            String sqlId = "com.helloMyBatis.dao.StudentDao" + "." + "selectStudents";
            //String sqlId = "com.helloMyBatis.dao.StudentDao.selectStudents";
            //7. 重要】执行sql语句，通过sqlId找到语句
            List<Student> studentList = sqlSession.selectList(sqlId);
            //8.输出结果
            //studentList.forEach( stu -> System.out.println(stu));
            for(Student stu : studentList){
                System.out.println("查询的学生="+stu);
            }
            //9.关闭SqlSession对象
            sqlSession.close();
        }
    }
    /*
    Logging initialized using 'class org.apache.ibatis.logging.stdout.StdOutImpl' adapter.
    PooledDataSource forcefully closed/removed all connections.
    PooledDataSource forcefully closed/removed all connections.
    PooledDataSource forcefully closed/removed all connections.
    PooledDataSource forcefully closed/removed all connections.
    Opening JDBC Connection
    Created connection 1731722639.
    Setting autocommit to false on JDBC Connection [com.mysql.jdbc.JDBC4Connection@6737fd8f]
    ==>  Preparing: select id,name,email,age from student order by id
    ==> Parameters: 
    <==    Columns: id, name, email, age
    <==        Row: 1001, 张三, zs@qq,com, 20
    <==        Row: 1002, 李四, ls@qq.com, 28
    <==      Total: 2
    查询的学生=Student{id=1001, name='张三', email='zs@qq,com', age=20}
    查询的学生=Student{id=1002, name='李四', email='ls@qq.com', age=28}
    Resetting autocommit to true on JDBC Connection [com.mysql.jdbc.JDBC4Connection@6737fd8f]
    Closing JDBC Connection [com.mysql.jdbc.JDBC4Connection@6737fd8f]
    Returned connection 1731722639 to pool.
    
    Process finished with exit code 0
    */
    ```

11. 配置日志功能

    mybatis.xml 文件加入日志配置，可以在控制台输出执行的 sql 语句和参数

    ```xml
    <!--settings：控制 mybatis全局行为-->
    <settings>
        <!--设置mybatis输出日志-->
        <setting name="logImpl" value="STDOUT_LOGGING" />
    </settings>
    ```

    

##### 2 基本的CRUD

###### 2.1 insert

```java
//StudentDao.java 接口中增加方法
//插入方法
//参数： student ,表示要插入到数据库的数据
//返回值： int ， 表示执行insert操作后的 影响数据库的行数
int insertStudent(Student student);
```

```xml
<!--StudentDao.xml 加入sql语句 -->
<!--插入操作-->
<insert id="insertStudent">
    insert into student values(#{id},#{name},#{email},#{age})
</insert>
```

```java
	//insert 测试方法
 	@Test
    public void testInsert() throws IOException {
        //访问mybatis读取student数据
        //1.定义mybatis主配置文件的名称, 从类路径的根开始（target/clasess）
        String config="mybatis.xml";
        //2.读取这个config表示的文件
        InputStream in = Resources.getResourceAsStream(config);
        //3.创建了SqlSessionFactoryBuilder对象
        SqlSessionFactoryBuilder builder  = new SqlSessionFactoryBuilder();
        //4.创建SqlSessionFactory对象
        SqlSessionFactory factory = builder.build(in);
        //5.获取SqlSession对象，从SqlSessionFactory中获取SqlSession
        SqlSession sqlSession = factory.openSession();
        //6.【重要】指定要执行的sql语句的标识。sql映射文件中的namespace + "." + 标签的id值
        String sqlId = "com.helloMyBatis.dao.StudentDao" + "." + "insertStudent";
        //7. 重要】执行sql语句，通过sqlId找到语句
        Student student = new Student();
        student.setId(1004);
        student.setName("刘六");
        student.setEmail("ll@163.com");
        student.setAge(20);
        int nums = sqlSession.insert(sqlId, student);
        //mybatis默认不是自动提交事务的， 所以在insert ，update ，delete后要手工提交事务
        sqlSession.commit();
        //8.输出结果
        System.out.println("执行insert结果：" + nums);
        //9.关闭SqlSession对象
        sqlSession.close();
    }
```

###### 2.2 update

```java
//StudentDao.java 接口中增加方法
//更新方法
//参数： student ,表示要更新到数据库的数据
//返回值： int ， 表示执行update操作后的 影响数据库的行数
int updateStudent(Student student);
```

```xml
<!--StudentDao.xml 加入sql语句 -->
<!--更新操作-->
<update id="updateStudent">
    update student set age=#{age} where id=#{id}
</update>
```

```java
	//update测试方法
	@Test
    public void testUpdate() throws IOException {
        //访问mybatis读取student数据
        //1.定义mybatis主配置文件的名称, 从类路径的根开始（target/clasess）
        String config="mybatis.xml";
        //2.读取配置文件
        InputStream in = Resources.getResourceAsStream(config);
        //3.创建了SqlSessionFactoryBuilder对象
        SqlSessionFactoryBuilder builder  = new SqlSessionFactoryBuilder();
        //4.创建SqlSessionFactory对象
        SqlSessionFactory factory = builder.build(in);
        //5.获取SqlSession对象，从SqlSessionFactory中获取SqlSession
        SqlSession sqlSession = factory.openSession();
        //6.【重要】指定要执行的sql语句的标识。sql映射文件中的namespace + "." + 标签的id值
        String sqlId = "com.helloMyBatis.dao.StudentDao" + "." + "updateStudent";
        //7. 重要】执行sql语句，通过sqlId找到语句
        Student student = new Student();
        student.setId(1004);
        student.setAge(18);
        int nums = sqlSession.update(sqlId, student);
        //手工提交事务
        sqlSession.commit();
        //8.输出结果
        System.out.println("执行update结果：" + nums);
        //9.关闭SqlSession对象
        sqlSession.close();
    }
```

###### 2.3 delete

```java
//StudentDao.java 接口中增加方法
//删除方法
//参数： id ,表示要删除数据的学生id
//返回值： int ， 表示执行delete操作后的 影响数据库的行数
int deleteStudent(int id);
```

```xml
<!--StudentDao.xml 加入sql语句 -->
<!--更新操作-->
<delete id="deleteStudent">
    delete from student where id=#{id};
</delete>
```

```java
	//delete测试方法
	@Test
    public void testDelete() throws IOException {
        //访问mybatis读取student数据
        //1.定义mybatis主配置文件的名称, 从类路径的根开始（target/classes）
        String config="mybatis.xml";
        //2.读取配置文件
        InputStream in = Resources.getResourceAsStream(config);
        //3.创建了SqlSessionFactoryBuilder对象
        SqlSessionFactoryBuilder builder  = new SqlSessionFactoryBuilder();
        //4.创建SqlSessionFactory对象
        SqlSessionFactory factory = builder.build(in);
        //5.获取SqlSession对象，从SqlSessionFactory中获取SqlSession
        SqlSession sqlSession = factory.openSession();
        //6.【重要】指定要执行的sql语句的标识。sql映射文件中的namespace + "." + 标签的id值
        String sqlId = "com.helloMyBatis.dao.StudentDao" + "." + "deleteStudent";
        //7. 重要】执行sql语句，通过sqlId找到语句
        int id = 1002;//要删除的学生id
        int nums = sqlSession.delete(sqlId, id);
        //手工提交事务
        sqlSession.commit();
        //8.输出结果
        System.out.println("执行update结果：" + nums);
        //9.关闭SqlSession对象
        sqlSession.close();
    }
```



##### 3 MyBatis对象分析

###### 3.1 对象使用

1. Resources 类：Resources 类，顾名思义就是资源，用于读取资源文件。其有很多方法通过加载并解析资源文件，返回不同类型的 IO 流对象。

   ```java
   InputStream in = Resources.getResourceAsStream("mybatis.xml");
   ```

2. SqlSessionFactoryBuilder 类：SqlSessionFactory 的创建，需要使用 SqlSessionFactoryBuilder 对象的build() 方法。由于 SqlSessionFactoryBuilder 对象在创建完工厂对象后，就完成了其历史使命，即可被销毁。所以，一般会将该 SqlSessionFactoryBuilder 对象创建为一个方法内的局部对象，方法结束，对象销毁。

   ```java
   SqlSessionFactoryBuilder builder  = new SqlSessionFactoryBuilder();
   //创建SqlSessionFactory对象
   SqlSessionFactory factory = builder.build(in);
   ```

3. SqlSessionFactory 接口：SqlSessionFactory 接口对象是一个重量级对象（系统开销大的对象），是线程安全的，所以一个应用只需要一个该对象即可。创建 SqlSession 需要使用 SqlSessionFactory 接口的 openSession()方法。

   - openSession(true)：创建一个有自动提交功能的 SqlSession
   - openSession(false)：创建一个非自动提交功能的 SqlSession，需手动提交
   - openSession()：同 openSession(false)

   ```java
   SqlSession sqlSession = factory.openSession();
   ```

4. SqlSession 接口

   ​	 SqlSession 接口对象用于执行持久化操作。一个 SqlSession 对应着一次数据库会话，一次会话以 SqlSession 对象的创建开始，以 SqlSession 对象的关闭结束。

   ​	 SqlSession 接口对象是线程不安全的，所以每次数据库会话结束前，需要马上调用其 close()方法，将 其关闭。再次需要会话，再次创建。 SqlSession 在方法内部创建，使用完毕后关闭。

   ​	 定义了操作数据的方法 例如 selectOne()、selectList()、insert()、update()、delete()、commit()、rollback()
   
   

###### 3.2 创建工具类

```java
package com.helloMyBatis.util;

import org.apache.ibatis.io.Resources;
import org.apache.ibatis.session.SqlSession;
import org.apache.ibatis.session.SqlSessionFactory;
import org.apache.ibatis.session.SqlSessionFactoryBuilder;

import java.io.IOException;
import java.io.InputStream;

public class MyBatisUtils {
    private static SqlSessionFactory factory = null;
    //静态代码块，类加载的时候执行
    static {
        String config = "mybatis.xml";
        try {
            InputStream in = Resources.getResourceAsStream(config);
            //创建SqlSessionFactory对象，使用SqlSessionFactoryBuilder
            factory = new SqlSessionFactoryBuilder().build(in);
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    //获取SqlSession的方法
    public static SqlSession getSqlSession(){
        SqlSession sqlSession = null;
        if(factory != null){
            sqlSession = factory.openSession();//非自动提交事务
        }
        return sqlSession;
    }
}
```

```java
//测试工具类
package com.helloMyBatis;

import com.helloMyBatis.entity.Student;
import com.helloMyBatis.util.MyBatisUtils;
import org.apache.ibatis.io.Resources;
import org.apache.ibatis.session.SqlSession;
import org.apache.ibatis.session.SqlSessionFactory;
import org.apache.ibatis.session.SqlSessionFactoryBuilder;

import java.io.IOException;
import java.io.InputStream;
import java.util.List;

public class MyApp2 {
    public static void main(String[] args) throws IOException {
        //获取SqlSession对象，从SqlSessionFactory中获取SqlSession
        SqlSession sqlSession = MyBatisUtils.getSqlSession();
        //指定要执行的sql语句的标识。sql映射文件中的namespace + "." + 标签的id值
        String sqlId = "com.helloMyBatis.dao.StudentDao" + "." + "selectStudents";
        //【重要】执行sql语句，通过sqlId找到语句
        List<Student> studentList = sqlSession.selectList(sqlId);
        //输出结果
        studentList.forEach( stu -> System.out.println(stu));
        //提交事务
        sqlSession.commit();
        //关闭SqlSession对象
        sqlSession.close();
    }
}
```



##### 4 MyBatis 使用传统 Dao 开发方式

###### 4.1 Dao开发

```java
//创建Dao接口
package com.xukang.dao;

import com.xukang.entity.Student;

import java.util.List;

public interface StudentDao {
    List<Student> selectStudents();
}
```

```xml
<!--StudentDao.xml 文件-->
<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE mapper
        PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
        "http://mybatis.org/dtd/mybatis-3-mapper.dtd">
<mapper namespace="com.xukang.dao.StudentDao">
    <select id="selectStudents" resultType="com.xukang.entity.Student">
        select id,name,email,age from student order by id
    </select>
</mapper>
```

```java
//创建 Dao 接口实现类
package com.xukang.dao.impl;

import com.xukang.dao.StudentDao;
import com.xukang.entity.Student;
import com.xukang.util.MyBatisUtil;
import org.apache.ibatis.session.SqlSession;

import java.util.List;

public class StudentDaoImpl implements StudentDao {
    @Override
    public List<Student> selectStudents() {
        //获取SqlSession对象
        SqlSession sqlSession = MyBatisUtil.getSqlSession();
        String sqlId = "com.xukang.dao.StudentDao.selectStudents";
        //执行sql语句，使用SqlSession类的方法
        List<Student> students = sqlSession.selectList(sqlId);
        students.forEach(stu -> System.out.println(stu));
        //提交事务
        sqlSession.commit();
        //关闭资源
        sqlSession.close();
        return students;
    }
}
```

```xml
<!--myBatis.xml 配置文件-->
<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE configuration
        PUBLIC "-//mybatis.org//DTD Config 3.0//EN"
        "http://mybatis.org/dtd/mybatis-3-config.dtd">
<configuration>
    <environments default="mydev">
        <environment id="mydev">
            <!--
               transactionManager ：mybatis的事务类型
               type: JDBC(表示使用jdbc中的Connection对象的commit，rollback做事务处理)
            -->
            <transactionManager type="JDBC"/>
            <!--
               dataSource:表示数据源，连接数据库的
               type：表示数据源的类型， POOLED表示使用连接池
            -->
            <dataSource type="POOLED">
                <!--数据库的驱动类名-->
                <property name="driver" value="com.mysql.jdbc.Driver"/>
                <!--连接数据库的url字符串-->
                <property name="url" value="jdbc:mysql://localhost:3306/springdb"/>
                <!--访问数据库的用户名-->
                <property name="username" value="root"/>
                <!--密码-->
                <property name="password" value="111"/>
            </dataSource>
        </environment>
    </environments>

    <!-- sql mapper(sql映射文件)的位置-->
    <mappers>
        <mapper resource="com/xukang/dao/StudentDao.xml"/>
    </mappers>
</configuration>
```

```java
//测试类
public class TestMyBatis {
    @Test
    public void testSelect(){
        StudentDao dao = new StudentDaoImpl();
        List<Student> students = dao.selectStudents();
        System.out.println("=================================");
        students.forEach(stu -> System.out.println(stu));
    }
}
```

###### 4.2 传统 Dao 开发方式的分析

​	在前面例子中自定义 Dao 接口实现类时发现一个问题：Dao 的实现类其实并没有干什么实质性的工作，它仅仅就是通过 SqlSession 的相关 API 定位到映射文件 mapper 中相应 id 的 SQL 语句，真正对 DB 进行操作的工作其实是由框架通过 mapper 中的 SQL 完成的。 

​	所以，MyBatis 框架就抛开了 Dao 的实现类，直接定位到映射文件 mapper 中的相应 SQL 语句，对 DB 进行操作。这种对 Dao 的实现方式称为 Mapper 的动态代理方式。 

​	Mapper 动态代理方式无需程序员实现 Dao 接口。接口是由 MyBatis 结合映射文件自动生成的动态代理实现的。

```java
分析
List<Student> studentList  = dao.selectStudents(); //调用
/*
1.dao对象，类型是StudentDao，全限定名称是：com.bjpowernode.dao.StudentDao
  全限定名称 和 namespace 是一样的。

2.方法名称， selectStudents， 这个方法就是 mapper文件中的 id值 selectStudents

3.通过dao中方法的返回值也可以确定MyBatis要调用的SqlSession的方法
如果返回值是List ，调用的是SqlSession.selectList()方法。
如果返回值 int ，或是非List的， 看mapper文件中的 标签是<insert>，<update> 就会调用
SqlSession的insert， update等方法

mybatis的动态代理： mybatis根据dao的方法调用，获取执行sql语句的信息。
mybatis根据你的dao接口，创建出一个dao接口的实现类，并创建这个类的对象。
完成SqlSession调用方法，访问数据库。
*/
```



### 三、MyBatis 框架 Dao 代理

##### 1 Dao 代理实现 CRUD

步骤:

1. 去掉 Dao 接口实现类

   ![image-20220210192433632](https://cdn.jsdelivr.net/gh/xukang0509/picgo_bed/img/202202121846564.png)

2.  getMapper 获取代理对象

   只需调用 SqlSession 的 getMapper()方法，即可获取指定接口的实现类对象。该方法的参数为指定 Dao 接口类的 class 值。目的是获取这个Dao接口的对象

   ```java
   /**
   * 使用mybatis的动态代理机制， 使用SqlSession.getMapper(dao接口)
   * getMapper能获取dao接口对于的实现类对象。
   */
   SqlSession sqlSession = MyBatisUtil.getSqlSession();
   StudentDao dao  =  sqlSession.getMapper(StudentDao.class);
   
   System.out.println("dao="+dao.getClass().getName());//com.sun.proxy.$Proxy2 : jdk的动态代理
   //调用dao的方法， 执行数据库的操作
   List<Student> students = dao.selectStudents();
   for(Student stu: students){
      System.out.println("学生="+stu);
   }
   sqlSession.commit();
   sqlSession.close();
   ```



##### 2 深入理解参数

###### 2.1 parameterType

parameterType: 接口中方法参数的类型， 类型的完全限定名或别名。这个属性是可选的，因为 MyBatis 可以推断出具体传入语句的参数，默认值为未设置（unset）。接口中方法的参数从 java 代码传入到 mapper 文件的 sql 语句。

```xml
	<!--
      parameterType ： dao接口中方法参数的数据类型。
        parameterType它的值是java的数据类型全限定名称或者是mybatis定义的别名
        例如： parameterType="java.lang.Integer"
              parameterType="int"

        注意：parameterType不是强制的，mybatis通过反射机制能够发现接口参数的数类型。
        所以可以没有。 一般我们也不写。
    -->
    <select id="selectStudentById" parameterType="int" resultType="com.bjpowernode.domain.Student">
        select id,name, email,age from student where id=${studentId}
    </select>

<!--
	   使用#{}之后， mybatis执行sql是使用的jdbc中的PreparedStatement对象
        由mybatis执行下面的代码：
         1. mybatis创建Connection ， PreparedStatement对象
            String sql="select id,name, email,age from student where id=?";
            PreparedStatement pst = conn.preparedStatement(sql);
            pst.setInt(1,1001);

         2. 执行sql封装为resultType="com.bjpowernode.domain.Student"这个对象
            ResultSet rs = ps.executeQuery();
            Student student = null;
            while(rs.next()){
               //从数据库取表的一行数据， 存到一个java对象属性中
               student = new Student();
               student.setId(rs.getInt("id));
               student.setName(rs.getString("name"));
               student.setEmail(rs.getString("email"));
               student.setAge(rs.getInt("age"));
            }

           return student;  //给了dao方法调用的返回值
-->
```

| 别名       | 数据类型   |
| ---------- | ---------- |
| _byte      | byte       |
| _long      | long       |
| _short     | short      |
| _int       | int        |
| _integer   | int        |
| _double    | double     |
| _float     | float      |
| _boolean   | boolean    |
| string     | String     |
| byte       | Byte       |
| long       | Long       |
| short      | Short      |
| int        | Integer    |
| integer    | Integer    |
| double     | Double     |
| float      | Float      |
| boolean    | Boolean    |
| date       | Date       |
| decimal    | BigDecimal |
| bigdecimal | BigDecimal |
| object     | Object     |
| map        | Map        |
| hashmap    | HashMap    |
| list       | List       |
| arraylist  | ArrayList  |
| collection | Collection |
| iterator   | Iterator   |



###### 2.2 MyBatis 传递参数

1. 一个简单类型参数

   Dao 接口中方法的参数只有一个简单类型（java 基本类型和 String），占位符 #{ 任意字符 }，和方 法的参数名无关。

   ```java
    	/**
        * 一个简单类型的参数：
        *   简单类型： mybatis把java的基本数据类型和String都叫简单类型。
        *  在mapper文件获取简单类型的一个参数的值，使用 #{任意字符}
        */
       public Student selectStudentById(Integer id);
   ```

   ```xml
   <select id="selectStudentById" parameterType="int" resultType="com.xukang.domain.Student">
      select id,name, email,age from student where id = #{studentId}
   </select>
   #{studentId} , studentId 是自定义的变量名称，和方法参数名无关。
   ```

2. 多个参数-使用@Param

   当 Dao 接口方法多个参数，需要通过名称使用参数。在方法形参前面加入@Param(“自定义参数名”)， mapper 文件使用 #{自定义参数名}。

   ```java
   	/**
        * 多个参数：命名参数，在形参定义的前面加入 @Param("自定义参数名称")
        */
       List<Student> selectMultiParam(@Param("myname") String name,
                                      @Param("myage") Integer age);
   ```

   ```xml
   	<!--多个参数，使用@Param命名-->
       <select id="selectMultiParam" resultType="com.xukang.domain.Student">
            select id,name,email,age from student where name=#{myname} and age=#{myage}
       </select>
   ```

3. 多个参数-使用对象

   使用 java 对象传递参数， java 的属性值就是 sql 需要的参数值。 每一个属性就是一个参数。 

   ```java
   package com.bjpowernode.vo;
   public class QueryParam {
       private String paramName;
       private Integer paramAge;
   
       public String getParamName() {
           return paramName;
       }
       public void setParamName(String paramName) {
           this.paramName = paramName;
       }
       public Integer getParamAge() {
           return paramAge;
       }
       public void setParamAge(Integer paramAge) {
           this.paramAge = paramAge;
       }
   }
   ```

   ```java
   	/**
        * 多个参数，使用java对象作为接口中方法的参数
        */
       List<Student> selectMultiObject(QueryParam param);
   ```

   ```xml
   <!--多个参数， 使用java对象的属性值，作为参数实际值
      使用对象语法： #{属性名,javaType=类型名称,jdbcType=数据类型} 很少用。
                   javaType:指java中的属性数据类型。
                   jdbcType:在数据库中的数据类型。
                   例如： #{paramName, javaType=java.lang.String, jdbcType=VARCHAR}
   
      我们使用的简化方式： #{属性名}，javaType, jdbcType的值mybatis反射能获取。不用提供
   -->
   <select id="selectMultiObject" resultType="com.xukang.domain.Student">
        select id,name, email,age from student where
        name=#{paramName, javaType=java.lang.String, jdbcType=VARCHAR}
        or age=#{paramAge, javaType=java.lang.Integer, jdbcType=INTEGER}
   </select>
   OR
   <select id="selectMultiObject" resultType="com.xukang.domain.Student">
        select id,name,email,age from student where
        name=#{paramName}   or age=#{paramAge}
   </select>
   ```

   ```java
   	@Test
       public void testSelectMultiObject(){
           SqlSession sqlSession = MyBatisUtils.getSqlSession();
           StudentDao dao = sqlSession.getMapper(StudentDao.class);
   
           QueryParam param = new QueryParam();
           param.setParamName("张三");
           param.setParamAge(28);
           List<Student> students = dao.selectMultiObject(param);
   
           for(Student stu: students){
               System.out.println("学生="+stu);
           }
           sqlSession.close();
       }
   ```

4. 多个参数-按位置

   参数位置从 0 开始， 引用参数语法 #{ arg 位置 } ， 第一个参数是#{arg0}, 第二个是#{arg1} 注意：mybatis-3.3 版本和之前的版本使用#{0}, #{1}方式， 从 mybatis3.4 开始使用#{arg0}方式。

   ```java
   	/**
        * 多个参数-简单类型的，按位置传值，
        * mybatis.3.4之前，使用 #{0} ，#{1}
        * mybatis。3.4之后 ，使用 #{arg0} ,#{arg1}
        */
       List<Student> selectMultiPosition( String name,Integer age);
   ```

   ```xml
   	<!--多个参数使用位置-->
       <select id="selectMultiPosition" resultType="com.bjpowernode.domain.Student">
             select id,name, email,age from student where
             name = #{arg0} or age=#{arg1}
       </select>
   ```

   ```java
   	@Test
       public void testSelectMultiPosition(){
           SqlSession sqlSession = MyBatisUtils.getSqlSession();
           StudentDao dao = sqlSession.getMapper(StudentDao.class);
   
           List<Student> students = dao.selectMultiPosition("李四",20);
   
           for(Student stu: students){
               System.out.println("学生="+stu);
           }
           sqlSession.close();
       }
   ```

5. 多个参数-使用 Map

   Map 集合可以存储多个值，使用Map向 mapper 文件一次传入多个参数。Map 集合使用 String的 key， Object 类型的值存储参数。 mapper 文件使用 # { key } 引用参数值。

   ```java
   	/**
        * 多个参数，使用Map存放多个值
        */
       List<Student> selectMultiByMap(Map<String,Object> map);
   ```

   ```xml
   	<!--多个参数，使用Map , 使用语法 #{map的key}-->
       <select id="selectMultiByMap" resultType="com.bjpowernode.domain.Student">
             select id,name, email,age from student where
             name = #{myname} or age=#{age1}
       </select>
   ```

   ```java
    	@Test
       public void testSelectMultiByMap(){
           SqlSession sqlSession = MyBatisUtils.getSqlSession();
           StudentDao dao = sqlSession.getMapper(StudentDao.class);
   
           Map<String,Object> data = new HashMap<>();
           data.put("myname","张三");
           data.put("age1",28);
   
           List<Student> students = dao.selectMultiByMap(data);
   
           for(Student stu: students){
               System.out.println("学生="+stu);
           }
           sqlSession.close();
       }
   ```

##### 3 # 和 $ 占位符的比较

\#：占位符，告诉 mybatis 使用实际的参数值代替。并使用 PrepareStatement 对象执行 sql 语句，#{…} 代替 sql 语句的 “?”。这样做更安全，更迅速，通常也是首选做法，

```
mapper 文件：
	<select id="selectById" resultType="com.bjpowernode.domain.Student">
 		select id,name,email,age from student where id=#{studentId}
	</select>
	
转为 MyBatis 的执行是：
	String sql=” select id,name,email,age from student where id=?”;
	PreparedStatement ps = conn.prepareStatement(sql);
	ps.setInt(1,1005);

解释：
	where id=? 就是 where id=#{studentId}
	ps.setInt(1,1005) , 1005 会替换掉 #{studentId}
```

$：字符串替换，告诉 mybatis 使用$包含的“字符串”替换所在位置。使用 Statement 把 sql 语句和${}的 内容连接起来。主要用在替换表名，列名，不同列排序等操作。

```
select id,name, email,age from student where id=#{studentId}
# 的结果： select id,name, email,age from student where id=? 


select id,name, email,age from student where id=${studentId}
$ 的结果：select id,name, email,age from student where id=1001

String sql="select id,name,email,age from student where id=" + "1001";
使用的Statement对象执行sql，效率比PreparedStatement低。
```



```java
List<Student> selectUse$Order(@Param("colName") String colName);
```

```xml
	<!--
       $替换列名
    -->
    <select id="selectUse$Order" resultType="com.bjpowernode.domain.Student">
         select * from student order by ${colName}
    </select>
```

```java
	@Test
    public void testSelectUse$Order(){
        SqlSession sqlSession = MyBatisUtils.getSqlSession();
        StudentDao dao = sqlSession.getMapper(StudentDao.class);

        List<Student> students = dao.selectUse$Order("age");

        for(Student stu: students){
            System.out.println("学生="+stu);
        }
        sqlSession.close();
    }
```



"#" 和 "$" 区别

- #使用 ？在sql语句中做占位的，使用PreparedStatement执行sql，效率高
  
- #能够避免sql注入，更安全。
  
- $不使用占位符，是字符串连接方式，使用Statement对象执行sql，效率低
  
- $有sql注入的风险，缺乏安全性。
  
- $:可以替换表名或者列名



##### 4 封装 MyBatis 的输出结果

###### 4.1 resultType

resultType：

```
指sql语句执行完毕后，数据转为的java对象，java类型是任意的。
resultType结果类型它的值 
	1.类型的全限定名称   
	2.类型的别名，例如 java.lang.Integer 别名是 int
执行 sql 得到 ResultSet 转换的类型，使用类型的完全限定名或别名。注意如果返回的是集合，那应该设置为集合包含的类型，而不是集合本身。resultType 和 resultMap，不能同时使用。

处理方式：
1. mybatis执行sql语句，然后mybatis调用类的无参数构造方法，创建对象。
2. mybatis把ResultSet指定列值付给同名的属性。
```

```
<select id="selectMultiPosition" resultType="com.bjpowernode.domain.Student">
   select id,name, email,age from student
</select>

对等的jdbc
ResultSet rs = executeQuery(" select id,name, email,age from student" )
while(rs.next()){
    Student student = new Student();
    student.setId(rs.getInt("id"));
	student.setName(rs.getString("name"));
}
```



- 简单类型

  ```java
  //接口方法
  int countStudent();
  ```
  
  ```xml
  <!-- mapper文件 -->
  <select id="countStudent" resultType="int">
      select count(*) from student
  </select>
  ```
  
  ```java
  	//测试代码
  	@Test
      public void testCountStudent(){
          SqlSession sqlSession = MyBatisUtil.getSqlSession();
          StudentDao mapper = sqlSession.getMapper(StudentDao.class);
          int counts = mapper.countStudent();
          System.out.println("学生的数量为" + counts + "位。");
      }
  ```
  
  
  
- 对象类型

  ```java
  //接口方法
  Student selectAllStudent();
  ```

  ```xml
  <!-- mapper文件 -->
  <select id="selectAllStudent" resultType="org.example.entity.Student">
     select id,name,email,age from student
  </select>
  ```

  ```java
  	//测试代码
  	@Test
      public void testSelectById(){
          SqlSession sqlSession = MyBatisUtil.getSqlSession();
          StudentDao mapper = sqlSession.getMapper(StudentDao.class);
          Student students = mapper.selectAllStudent();
          students.forEach(s -> System.out.println("student" + s));
          sqlSession.close();
      }
  ```

  框架的处理： 使用构造方法创建对象。调用 setXXX 给属性赋值。 Student student = new Student();

  | sql语句列 | java对象方法                    |
  | --------- | ------------------------------- |
  | id        | setId(rs.getInt(“id”))          |
  | name      | setName(rs.getString(“name”))   |
  | email     | setEmail(rs.getString(“email”)) |
  | age       | setAge(rs.getInt(“age”))        |

  调用列名对应的 set 方法

  注意：Dao 接口方法返回是集合类型，需要指定集合中的类型，不是集合本身。

  

- Map

  ```java
  //接口方法
  //定义方法返回Map
  Map<Object,Object> selectMapById(Integer id);
  ```

  ```xml
  <!-- mapper文件 -->
  <!--返回Map
     1）列名是map的key，列值是map的value
     2)只能最多返回一行记录。多余一行是错误
  -->
  <select id="selectMapById" resultType="java.util.HashMap">
      select id,name,email from student where id=#{stuid}
  </select>
  ```

  ```java
  	//测试代码
  	//返回Map
      @Test
      public void testSelecMap(){
          SqlSession sqlSession = MyBatisUtil.getSqlSession();
          StudentDao dao  =  sqlSession.getMapper(StudentDao.class);
  
          Map<Object,Object> map = dao.selectMapById(1001);
          System.out.println("map=="+map);//map=={name=张三, id=1001, email=zs@qq,com}
          sqlSession.close();
      }
  ```

###### 4.2 resultMap

resultMap 可以自定义 sql 的结果和 java 对象属性的映射关系。更灵活的把列值赋值给指定属性。常用在列名和 java 对象属性名不一样的情况。

使用方式： 

1. 先定义 resultMap，指定列名和属性的对应关系。 
2. 在中把 resultType 替换为 resultMap。

```
resultMap:结果映射， 指定列名和java对象的属性对应关系。
	1.你自定义列值赋值给哪个属性
	2.当你的列名和属性名不一样时，一定使用resultMap

注意：resultMap和resultType不要一起用，二选一
```

```java
	 /*
     *  使用resultMap定义映射关系
     * */
    List<Student> selectAllStudents();
```

```xml
	<!--使用resultMap
        1)先定义resultMap
        2)在select标签，使用resultMap来引用1定义的。
    -->
    <!--定义resultMap
        id:自定义名称，表示你定义的这个resultMap
        type：java类型的全限定名称
    -->
    <resultMap id="studentMap" type="org.example.entity.Student">
        <!--列名和java属性的关系-->
        <!--主键列，使用id标签
            column :列名
            property:java类型的属性名
        -->
        <id column="id" property="id" />
        <!--非主键列，使用result-->
        <result column="name" property="name" />
        <result column="email" property="email" />
        <result column="age" property="age" />
    </resultMap>

    <select id="selectAllStudents" resultMap="studentMap">
        select id,name, email , age from student
    </select>
```

```java
	@Test
    public void testSelectAllStudents(){
        SqlSession sqlSession = MyBatisUtil.getSqlSession();
        StudentDao dao = sqlSession.getMapper(StudentDao.class);
        List<Student> students = dao.selectAllStudents();
        for(Student stu: students){
            System.out.println("学生="+stu);
        }
        sqlSession.close();
    }
```

###### 4.3 实体类属性名和列名不同的处理方式

```java
public class MyStudent {
    private Integer stuid;
    private String stuname;
    private String stuemail;
    private Integer stuage;
    //get set toString
}
```

1. 使用 列别名 和 resultType

   ```java
   //StudentDao
   List<MyStudent> selectDiffColProperty();
   ```

   ```xml
   <!--
      列名和属性名不一样
      resultType的默认原则是 同名的列值赋值给同名的属性， 使用列别名(java对象的属性名)
   -->
   <select id="selectDiffColProperty" resultType="org.example.entity.MyStudent">
      select id as stuid ,name as stuname, email as stuemail, age as stuage from student
   </select>
   ```

   ```java
   @Test
   public void testSelectDiffColProperty(){
       SqlSession sqlSession = MyBatisUtil.getSqlSession();
       StudentDao dao = sqlSession.getMapper(StudentDao.class);
       List<MyStudent> students = dao.selectDiffColProperty();
       for(MyStudent stu: students){
           System.out.println("学生="+stu);
       }
       sqlSession.close();
   }
   ```

   

2. 使用 resultMap

   ```java
   List<MyStudent> selectMyStudent();
   ```

   ```xml
   	<resultMap id="myStudentMap" type="org.example.entity.MyStudent">
           <!--列名和java属性的关系-->
           <id column="id" property="stuid" />
           <!--非主键列，使用result-->
           <result column="name" property="stuname" />
           <result column="email" property="stuemail" />
           <result column="age" property="stuage" />
       </resultMap>
       <select id="selectMyStudent" resultMap="myStudentMap">
           select id,name, email , age from student
       </select>
   ```

   ```java
   	@Test
       public void testSelectAllStudents2(){
           SqlSession sqlSession = MyBatisUtil.getSqlSession();
           StudentDao dao = sqlSession.getMapper(StudentDao.class);
           List<MyStudent> students = dao.selectMyStudent();
           for(MyStudent stu: students){
               System.out.println("学生="+stu);
           }
           sqlSession.close();
       }
   ```

   

###### 4.4 定义别名

```
定义自定义类型的别名
	1.在mybatis主配置文件中定义，使用<typeAlias>定义别名
	2.可以在resultType中使用自定义别名
```

```xml
	<!--mybatis.xml-->
	<!--定义别名-->
    <typeAliases>
        <!--
            第一种方式：
            可以指定一个类型一个自定义别名
            type:自定义类型的全限定名称
            alias:别名（短小，容易记忆的）
        -->
        <typeAlias type="com.bjpowernode.domain.Student" alias="stu" />
        <typeAlias type="com.bjpowernode.vo.ViewStudent" alias="vstu" />

        <!--
          第二种方式
          <package> name是包名，这个包中的所有类，类名就是别名（类名不区分大小写）
        -->
        <package name="com.bjpowernode.domain"/>
        <package name="com.bjpowernode.vo"/>
    </typeAliases>
```



##### 5 模糊 like

模糊查询的实现有两种方式

1. java 代码中给查询数据加上“%”；

```java
//接口方法：
/*第一种模糊查询，在java代码指定 like 的内容*/
List<Student> selectLikeOne(String name);
```

```xml
<!--mapper 文件-->
<!--第一种 like: java代码指定 like的内容-->
<select id="selectLikeOne" resultType="org.example.entity.Student">
    select id,name,email,age from student where name like #{name}
</select>
```

```java
//测试方法
@Test
public void testSelectLikeOne(){
    SqlSession sqlSession = MyBatisUtil.getSqlSession();
    StudentDao dao = sqlSession.getMapper(StudentDao.class);
    //准备好like的内容
    String name = "%李%";
    List<Student> students = dao.selectLikeOne(name);
    for(Student stu: students){
        System.out.println("#######学生="+stu);
    }
    sqlSession.close();
}
```

2. 在 mapper 文件 sql 语句的 条件位置加上“%”

```java
//接口方法：
/*name就是李值，在mapper中拼接  like "%" 李 "%" */
List<Student> selectLikeTwo(String name);
```

```xml
<!--mapper 文件-->
<!--第二种 like: 在mapper文件中拼接 like的内容-->
<select id="selectLikeTwo" resultType="org.example.entity.Student">
    select id,name,email,age from student where name  like "%" #{name} "%"
</select>
```

```java
//测试方法
@Test
public void testSelectLikeOne(){
    SqlSession sqlSession = MyBatisUtil.getSqlSession();
    StudentDao dao = sqlSession.getMapper(StudentDao.class);
    //准备好like的内容
    String name = "李";
    List<Student> students = dao.selectLikeOne(name);
    for(Student stu: students){
        System.out.println("#######学生="+stu);
    }
    sqlSession.close();
}
```



### 四、MyBatis 框架动态 SQL

```
动态 SQL，通过 MyBatis 提供的各种标签对条件作出判断以实现动态拼接 SQL 语句。这里的条件判
断使用的表达式为 OGNL 表达式。常用的动态 SQL 标签有<if>、<where>、<choose>、<foreach>等。
MyBatis 的动态 SQL 语句，与 JSTL 中的语句非常相似。

动态 SQL，主要用于解决查询条件不确定的情况：在程序运行期间，根据用户提交的查询条件进行
查询。提交的查询条件不同，执行的 SQL 语句不同。若将每种可能的情况均逐一列出，对所有条件进行
排列组合，将会出现大量的 SQL 语句。此时，可使用动态 SQL 来解决这样的问题
```

##### 1 环境准备

创建新的 maven 项目，加入 mybatis，mysql 驱动依赖 

创建实体类 Student，StudentDao 接口，StudentDao.xml，mybatis.xml，测试类 

使用之前的表 student



在 mapper 的动态 SQL 中若出现大于号（>）、小于号（<）、大于等于号（>=）、小于等于号（<=）等符号，最好将其转换为实体符号。否则，XML 可能会出现解析出错问题。

特别是对于小于号（<），在 XML 中是绝不能出现的。否则解析 mapper 文件会出错。

```
<		小于			&lt;
>		大于			&gt;
<=		小于等于	   &lt;=	
>=		大于等于	   &gt;=
```



##### 2 动态SQL之 if

```xml
对于该标签的执行，当 test 的值为 true 时，会将其包含的 SQL 片断拼接到其所在的 SQL 语句中。
语法：
<if test=”条件”> 
	sql 语句的部分 
</if>
```

```java
//接口方法
//动态sql，使用Java对象作为参数
List<Student> selectStudentIf(Student student);
```

```xml
	<!--mapper文件-->
	<select id="selectStudentIf" resultType="org.example.entity.Student">
        select id, name, email, age from student
        where id > 0 
        <if test="name != null and name != ''">
            name = #{name}
        </if>
        <if test="age > 0">
            or age > #{age}
        </if>
    </select>
```

```java
	@Test
    public void testSelectStudentIf(){
        SqlSession sqlSession = MyBatisUtil.getSqlSession();
        StudentDao mapper = sqlSession.getMapper(StudentDao.class);
        Student student = new Student();
        student.setName("张三");
        student.setAge(18);
        List<Student> students = mapper.selectStudentIf(student);
        students.forEach(stu -> System.out.println("student : " + stu));
        sqlSession.close();
    }
```

##### 3 动态SQL之 where

​	if 标签中存在一个比较麻烦的地方：需要在 where 后手工添加 1=1 或者 id>0 的子句。因为，若 where 后的所有的 if 条件均为 false，而 where 后若又没有 1=1 子句，则 SQL 中就会只剩下一个空的 where，SQL 出错。所以，在 where 后，需要添加**永为真**子句 1=1，以防止这种情况的发生。但当数据量很大时，会严重影响查询效率。 

​	使用 where 标签，在有查询条件时，可以自动添加上 where 子句；没有查询条件时，不会添加 where 子句。需要注意的是，第一个 if 标签中的 SQL 片断，可以不包含 and。不过，写上 and 也不错， 系统会将多出的 and 去掉。但其它 if 中 SQL 片断的 and，必须要求写上。否则 SQL 语句将拼接出错 。

```
语法：<where> 其他动态sql </where> 
```

```java
//动态sql，where使用
List<Student> selectStudentWhere(Student student);
```

```xml
	<!--
        where:
            <where>
                <if>...</if>
                <if>...</if>
                <if>...</if>
            </where>
    -->
    <select id="selectStudentWhere" resultType="org.example.entity.Student">
        select id,name,email,age from student
        <where>
            <if test="name != null and name != ''">
                name = #{name}
            </if>
            <if test="age > 0">
                and age = #{age}
            </if>
        </where>
    </select>
```

```java
	@Test
    public void testSelectStudentWhere(){
        SqlSession sqlSession = MyBatisUtil.getSqlSession();
        StudentDao mapper = sqlSession.getMapper(StudentDao.class);
        Student student = new Student();
        student.setName("张三");
        student.setAge(20);
        List<Student> students = mapper.selectStudentWhere(student);
        students.forEach(stu -> System.out.println("student : " + stu));
        sqlSession.close();
    }
```

##### 4 动态SQL之 foreach

foreach 标签用于实现对于数组与集合的遍历。对其使用，需要注意：

- collection 表示要遍历的集合类型，list，array 等。
- open、close、separator 为对遍历内容的 SQL 拼接。

```xml
语法：
<foreach collection="集合类型" open="开始的字符" close="结束的字符" 
		item="集合中的成员" separator="集合成员之间的分隔符">
 	#{item 的值}
</foreach>
```

```
主要用在sql的in语句中。
	学生id是 1001,1002,1003的三个学生
	select * from student where id in (1001,1002,1003)
	
public List<Student> selectFor(List<Integer> idlist)

List<Integer> list = new ArrayList<>();
list.add(1001);
list.add(1002);
list.add(1003);
dao.selectFor(list)

<foreach collection="" item="xxx" open="" close="" separator="">
    #{xxx}
</foreach>
```

1. 遍历 List<简单类型>

   ```java
   	//foreach 用法1 遍历 List<简单类型>
   	List<Student> selectForEachOne(List<Integer> idList);
   ```

   ```xml
   	<!-- foreach 使用1，List<Integer> -->
       <select id="selectForEachOne" resultType="org.example.entity.Student">
           select * from student where id in
           <foreach collection="list" item="myId" open="(" close=")" separator=",">
               #{myId}
           </foreach>
           <!--
               collection:表示接口中的方法参数的类型，如果是数组使用array，如果是list集合使用list
   	        item:自定义的，表示数组和集合成员的变量
   	        open:循环开始是的字符
   	        close:循环结束时的字符
               separator:集合成员之间的分隔符
            -->
       </select>
   ```

   ```java
   	@Test
       public void testSelectForEachOne(){
           SqlSession sqlSession = MyBatisUtil.getSqlSession();
           StudentDao mapper = sqlSession.getMapper(StudentDao.class);
           List<Integer> list = new ArrayList<>();
           list.add(1001);
           list.add(1003);
           list.add(1009);
           List<Student> students = mapper.selectForEachOne(list);
           students.forEach(stu -> System.out.println("student : " + stu));
           sqlSession.close();
       }
   /*
   Created connection 1475491159.
   ==>  Preparing: select * from student where id in ( ? , ? , ? )
   ==> Parameters: 1001(Integer), 1003(Integer), 1009(Integer)
   <==    Columns: id, name, email, age
   <==        Row: 1001, 张三, zs@qq,com, 20
   <==        Row: 1003, 王五, ww@163.com, 30
   <==        Row: 1009, 刘备, lb@163.com, 55
   <==      Total: 3
   student : Student{id=1001, name='张三', email='zs@qq,com', age=20}
   student : Student{id=1003, name='王五', email='ww@163.com', age=30}
   student : Student{id=1009, name='刘备', email='lb@163.com', age=55}
   Closing JDBC Connection [com.mysql.jdbc.JDBC4Connection@57f23557]
   */
   ```

   

2. 遍历 List<对象类型>

   ```java
   	//foreach 用法2 遍历 List<对象类型>
       List<Student> selectForEachTwo(List<Student> idList);
   ```

   ```xml
    	<!-- foreach 使用2，List<Object> -->
       <select id="selectForEachTwo" resultType="org.example.entity.Student">
           select * from student where id in
           <foreach collection="list" item="stu" open="(" close=")" separator=",">
               #{stu.id}
           </foreach>
       </select>
   ```

   ```java
   	@Test
       public void testSelectForEachTwo(){
           SqlSession sqlSession = MyBatisUtil.getSqlSession();
           StudentDao mapper = sqlSession.getMapper(StudentDao.class);
           List<Student> studentList = new ArrayList<>();
           Student s1 = new Student();
           Student s2 = new Student();
           s1.setId(1001);
           s2.setId(1003);
           studentList.add(s1);
           studentList.add(s2);
           List<Student> students = mapper.selectForEachTwo(studentList);
           students.forEach(stu -> System.out.println("student : " + stu));
           sqlSession.close();
       }
   /*
   Created connection 1024429571.
   ==>  Preparing: select * from student where id in ( ? , ? )
   ==> Parameters: 1001(Integer), 1003(Integer)
   <==    Columns: id, name, email, age
   <==        Row: 1001, 张三, zs@qq,com, 20
   <==        Row: 1003, 王五, ww@163.com, 30
   <==      Total: 2
   student : Student{id=1001, name='张三', email='zs@qq,com', age=20}
   student : Student{id=1003, name='王五', email='ww@163.com', age=30}
   Closing JDBC Connection [com.mysql.jdbc.JDBC4Connection@3d0f8e03]
   */
   ```



##### 5 动态 SQL 之代码片段

​	sql 标签用于定义 SQL 片断，以便其它 SQL 标签复用。而其它标签使用该 SQL 片断，需要使用 include 子标签。该 sql 标签可以定义 SQL 语句中的任何部分，所以 include 子标签可以放在动态 SQL 的任何位置。

```
步骤:
	1.先定义 <sql id="自定义名称唯一">  sql语句， 表名，字段等 </sql>
	2.再使用， <include refid="id的值" />
```

```xml
	<!-- 定义sql片段 -->
    <sql id="selectStu">
        select id, name, email, age from student
    </sql>
       
    <select id="selectStudents" resultType="org.example.entity.Student">
        <include refid="selectStu"></include>
    </select>

    <select id="selectStudentIf" resultType="org.example.entity.Student">
        <include refid="selectStu" />
        where id > 0
        <if test="name != null and name != ''">
            name = #{name}
        </if>
        <if test="age > 0">
            and age = #{age}
        </if>
    </select>
```



### 五、MyBatis 配置文件

##### 1  主配置文件

项目中使用的 mybatis.xml 是主配置文件。

主配置文件特点：

- xml 文件，需要在头部使用约束文件

  ```xml
  <?xml version="1.0" encoding="UTF-8" ?>
  <!DOCTYPE configuration
   	PUBLIC "-//mybatis.org//DTD Config 3.0//EN"
   	"http://mybatis.org/dtd/mybatis-3-config.dtd">
  ```

- 根元素 configuration

- 主要包含内容：定义别名；数据源；mapper 文件



##### 2 dataSource 标签

```xml
<!--
Mybatis 中访问数据库，可以连接池技术，但它采用的是自己的连接池技术。
在 Mybatis 的 mybatis.xml配置文件中，通过<dataSource type=”pooled”>
来实现 Mybatis 中连接池的配置
-->
<dataSource type="POOLED">
    <property name="driver" value="com.mysql.jdbc.Driver"/>
    <property name="url" value="jdbc:mysql://localhost:3306/springdb"/>
    <property name="username" value="root"/>
    <property name="password" value="111"/>
</dataSource>
```

1. dataSource 类型

    Mybatis 将数据源分为三类：

   - UNPOOLED	不使用连接池的数据源 
   - POOLED         使用连接池的数据源 
   - JNDI                使用 JNDI 实现的数据源

   其中 UNPOOLED，POOLED 数据源实现了 javax.sq.DataSource 接口，JNDI 和前面两个实现方式不同，了解可以。

2. dataSource 配置

   在 MyBatis.xml 主配置文件，配置 dataSource

   ```xml
   <dataSource type="POOLED">
       <property name="driver" value="com.mysql.jdbc.Driver"/>
       <property name="url" value="jdbc:mysql://localhost:3306/springdb"/>
       <property name="username" value="root"/>
       <property name="password" value="111"/>
   </dataSource>
   ```

   MyBatis 在初始化时，根据 dataSource 的 type 属性来创建相应类型的的数据源 DataSource，即：

   - type=”POOLED”：MyBatis 会创建 PooledDataSource 实例
   - type=”UNPOOLED” ： MyBatis 会创建 UnpooledDataSource 实例 
   - type=”JNDI”：MyBatis 会从 JNDI 服务上查找 DataSource 实例，然后返回使用

   

##### 3 事务

1. 默认需要手动提交事务

   Mybatis 框架是对 JDBC 的封装，所以 Mybatis 框架的事务控制方式，本身也是用 JDBC 的 Connection 对象的 commit(), rollback() 

   Connection 对象的 setAutoCommit() 方法来设置事务提交方式的：自动提交和手工提交

   ```java
   <transactionManager type="JDBC"/>
   ```

   该标签用于指定 MyBatis 所使用的事务管理器。MyBatis 支持两种事务管理器类型：JDBC 与 MANAGED。

   1. JDBC：使用 JDBC 的事务管理机制。即通过 Connection 的 commit() 方法提交，通过 rollback() 方法回滚。但默认情况下，MyBatis 将自动提交功能关闭了，改为了手动提交。即程序中需要显式的对事务进行提交或回滚。

   2. MANAGED：由容器来管理事务的整个生命周期（如 Spring 容器）。

      

2. 自动提交事务

   设置自动提交的方式，factory 的 openSession() 分为有参数和无参数的。

   ```java
   SqlSession openSession();
   SqlSession openSession(boolean var1);
   /*
   openSession(true)：创建一个有自动提交功能的 SqlSession
   openSession(false)：创建一个非自动提交功能的 SqlSession，需手动提交
   openSession()：同 openSession(false)
   */
   ```



##### 4 使用数据库属性配置文件

为了方便对数据库连接的管理，DB 连接四要素数据一般都是存放在一个专门的属性文件中的。MyBatis 主配置文件需要从这个属性文件中读取这些数据。步骤如下：

1. 在 classpath 路径下，创建 properties 文件

   在 resources 目录创建 jdbc.properties 文件，文件名称自定义。

   ```properties
   jdbc.driver=com.mysql.jdbc.Driver
   jdbc.url=jdbc:mysql://localhost:3306/springdb
   jdbc.user=root
   jdbc.passwd=111
   ```

2. 使用 properties 标签

   修改主配置文件，文件开始位置加入：

   ```xml
   <?xml version="1.0" encoding="UTF-8" ?>
   <!DOCTYPE configuration
           PUBLIC "-//mybatis.org//DTD Config 3.0//EN"
           "http://mybatis.org/dtd/mybatis-3-config.dtd">
   <configuration>
       <!--指定properties文件的位置，从类路径根开始找文件-->
       <properties resource="jdbc.properties" />
   ```

3. 使用 key 指定值

   ```xml
   <dataSource type="POOLED">
       <!--数据库的驱动类名-->
       <property name="driver" value="${jdbc.driver}"/>
       <!--连接数据库的url字符串-->
       <property name="url" value="${jdbc.url}"/>
       <!--访问数据库的用户名-->
       <property name="username" value="${jdbc.user}"/>
       <!--密码-->
       <property name="password" value="${jdbc.passwd}"/>
   </dataSource>
   ```



##### 5 typeAliases (类型别名)

Mybatis 支持默认别名，我们也可以采用自定义别名方式来开发，主要使用在 mybatis.xml 主配置文件定义别名：

```xml
	<!--mybatis.xml-->
	<!--定义别名-->
    <typeAliases>
        <!--
            第一种方式：
            可以指定一个类型一个自定义别名
            type:自定义类型的全限定名称
            alias:别名（短小，容易记忆的）
        -->
        <typeAlias type="com.xukang.entity.Student" alias="stu" />
        <typeAlias type="com.xukang.vo.ViewStudent" alias="vstu" />

        <!--
          第二种方式
          <package> name是包名，这个包中的所有类，类名就是别名（类名不区分大小写）
        -->
        <package name="com.xukang.entity"/>
        <package name="com.xukang.vo"/>
    </typeAliases>
```

mapper.xml 文件，使用别名表示类型

```xml
<select id="selectStudents" resultType="stu">
	select id, name, email, age from student
</select>
```



##### 6 mappers (映射器)

```xml
<mapper resource=" " />
使用相对于类路径的资源,从 classpath 路径查找文件
例如：<mapper resource="org/example/dao/StudentDao.xml" />
```

```xml
<package name=" "/>
指定包下的所有 Dao 接口
如：<package name="org.example.dao" /> 
注意：此种方法要求 Dao 接口名称和 mapper 映射文件名称相同，且在同一个目录中。
```



##### 7 小结

```properties
#jdbc.properties
jdbc.driver=com.mysql.jdbc.Driver
jdbc.url=jdbc:mysql://localhost:3306/springdb
jdbc.user=root
jdbc.passwd=123456
```

```xml
<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE configuration
        PUBLIC "-//mybatis.org//DTD Config 3.0//EN"
        "http://mybatis.org/dtd/mybatis-3-config.dtd">
<configuration>
    <!--指定properties文件的位置，从类路径根开始找文件-->
    <properties resource="jdbc.properties" />

    <!--settings：控制mybatis全局行为-->
    <settings>
        <!--设置mybatis输出日志-->
        <setting name="logImpl" value="STDOUT_LOGGING"/>
    </settings>

    <!--定义别名-->
    <typeAliases>
        <!--
            第一种方式：
            可以指定一个类型一个自定义别名
            type:自定义类型的全限定名称
            alias:别名（短小，容易记忆的）
        -->
        <typeAlias type="com.bjpowernode.domain.Student" alias="stu" />
        <typeAlias type="com.bjpowernode.vo.ViewStudent" alias="vstu" />

        <!--
          第二种方式
          <package> name是包名， 这个包中的所有类，类名就是别名（类名不区分大小写）
        -->
        <package name="com.bjpowernode.domain"/>
        <package name="com.bjpowernode.vo"/>
    </typeAliases>

    <!--配置插件-->
    <plugins>
        <plugin interceptor="com.github.pagehelper.PageInterceptor" />
    </plugins>

    <environments default="mydev">
        <environment id="mydev">
            <!--
              transactionManager:mybatis提交事务，回顾事务的方式
                 type: 事务的处理的类型
                     1）JDBC : 表示mybatis底层是调用JDBC中的Connection对象的，commit， rollback
                     2）MANAGED : 把mybatis的事务处理委托给其它的容器（一个服务器软件，一个框架（spring））
            -->
            <transactionManager type="JDBC"/>
            <!--
               dataSource:表示数据源，java体系中，规定实现了javax.sql.DataSource接口的都是数据源。
                          数据源表示Connection对象的。

               type:指定数据源的类型
                  1）POOLED: 使用连接池， mybatis会创建PooledDataSource类
                  2）UPOOLED: 不使用连接池， 在每次执行sql语句，先创建连接，执行sql，在关闭连接
                              mybatis会创建一个UnPooledDataSource，管理Connection对象的使用
                  3）JNDI：java命名和目录服务（windows注册表）
            -->
            <dataSource type="POOLED">
                <!--数据库的驱动类名-->
                <property name="driver" value="${jdbc.driver}"/>
                <!--连接数据库的url字符串-->
                <property name="url" value="${jdbc.url}"/>
                <!--访问数据库的用户名-->
                <property name="username" value="${jdbc.user}"/>
                <!--密码-->
                <property name="password" value="${jdbc.passwd}"/>
            </dataSource>
        </environment>
    </environments>

    <!-- sql mapper(sql映射文件)的位置-->
    <mappers>
        <!--第一种方式：指定多个mapper文件-->
        <!--<mapper resource="com/bjpowernode/dao/StudentDao.xml"/>
        <mapper resource="com/bjpowernode/dao/OrderDao.xml" />-->

        <!--第二种方式： 使用包名
            name: xml文件（mapper文件）所在的包名, 这个包中所有xml文件一次都能加载给mybatis
            使用package的要求：
             1. mapper文件名称需要和接口名称一样， 区分大小写的一样
             2. mapper文件和dao接口需要在同一目录
        -->
        <package name="com.bjpowernode.dao"/>
       <!-- <package name="com.bjpowernode.dao2"/>
        <package name="com.bjpowernode.dao3"/>-->
    </mappers>
</configuration>
```



### 六、扩展

##### PageHelper 分页

实现步骤：

1. 在 pom.xml 文件中加入 maven 坐标依赖

   ```xml
   <dependency>
    	<groupId>com.github.pagehelper</groupId>
    	<artifactId>pagehelper</artifactId>
    	<version>5.1.10</version>
   </dependency>
   ```

2. 在 mybatis.xml主配置文件中加入 plugin 配置

   ```xml
   在<environments>之前加入
   <plugins>
    	<plugin interceptor="com.github.pagehelper.PageInterceptor" />
   </plugins>
   ```

3. PageHelper 对象

   查询语句之前调用 PageHelper.startPage 静态方法。 

   除了 PageHelper.startPage 方法外，还提供了类似用法的 PageHelper.offsetPage 方法。 

   在你需要进行分页的 MyBatis 查询方法前调用 PageHelper.startPage 静态方法即可，紧跟在这个方法后的第一个 MyBatis 查询方法会被进行分页。

   ```java
   	List<Student> selectStudents();
   ```

   ```xml
   	<!-- 定义sql片段 -->
       <sql id="selectStu">
           select id, name, email, age from student
       </sql>
          
       <select id="selectStudents" resultType="org.example.entity.Student">
           <include refid="selectStu"></include> order by id
       </select>
   ```

   ```java
   	@Test
       public void testPageHelper(){
           SqlSession sqlSession = MyBatisUtil.getSqlSession();
           StudentDao mapper = sqlSession.getMapper(StudentDao.class);
           // 加入PageHelper的方法，分页
           // pageNum: 第几页，从1开始
           // pageSize: 一页中有多少行数据
           PageHelper.startPage(1,2);
           List<Student> students = mapper.selectStudents();
           students.forEach(stu -> System.out.println("student : " + stu));
           sqlSession.close();
       }
   /*
   Checked out connection 194706439 from pool.
   ==>  Preparing: SELECT count(0) FROM student
   ==> Parameters: 
   <==    Columns: count(0)
   <==        Row: 3
   <==      Total: 1
   ==>  Preparing: select id, name, email, age from student order by id LIMIT ?
   ==> Parameters: 2(Integer)
   <==    Columns: id, name, email, age
   <==        Row: 1001, 张三, zs@qq,com, 20
   <==        Row: 1003, 王五, ww@163.com, 30
   <==      Total: 2
   student : Student{id=1001, name='张三', email='zs@qq,com', age=20}
   student : Student{id=1003, name='王五', email='ww@163.com', age=30}
   Closing JDBC Connection [com.mysql.jdbc.JDBC4Connection@b9afc07]
   Returned connection 194706439 to pool.
   */
   ```

# Spring

------

### 一、Spring 概述

##### 1 Spring 框架是什么

​	Spring 是于 2003 年兴起的一个轻量级的 Java 开发框架，它是为了解决企业应用开发的复杂性而创建的。Spring 的核心是**控制反转**（IOC）和**面向切面编程**（AOP）。Spring 是可以在 Java SE/EE 中使用的轻量级开源框架。

​	Spring 的主要作用就是为代码“解耦”，降低代码间的耦合度。就是让对象和对象（模块和模块）之间关系不是使用代码关联，而是通过配置来说明。即在 Spring 中说明对象（模块）的关系。

​	Spring 根据代码的功能特点，使用 IOC 降低业务对象之间耦合度。IOC 使得主业务在相互调用过程中，不用再自己维护关系了，即不用再自己创建要使用的对象了。而是由 Spring 容器统一管理，自动“注入”，注入即赋值。 而 AOP 使得系统级服务得到了最大复用，且不用再由程序员手工将系统级服务“混杂”到主业务逻辑中了，而是由 Spring 容器统一完成 “注入”。

​	Spring官网：https://spring.io/



##### 2 Spring 优点

Spring 是一个框架，是一个半成品的软件。由 20 个模块组成。它是一个容器管理对象，容器是装东西的，Spring 容器不装文本，数字。装的是对象。Spring 是存储对象的容器。

1. **轻量**

   Spring 框架使用的 jar 都比较小，一般在 1M 以下或者几百 kb。Spring 核心功能的所需的 jar 总共在 3M 左右。 Spring 框架运行占用的资源少，运行效率高。不依赖其他 jar。

2. **针对接口编程，解耦合**

   Spring 提供了 IOC 控制反转，由容器管理对象，对象的依赖关系。原来在程序代码中的对象创建方式，现在由容器完成。对象之间的依赖解耦合。

3. **AOP 编程的支持**

   通过 Spring 提供的 AOP 功能，方便进行面向切面的编程，许多不容易用传统 OOP 实现的功能可以通过 AOP 轻松应付； 

   在 Spring 中，开发人员可以从繁杂的事务管理代码中解脱出来，通过声明式方式灵活地进行事务的管理，提高开发效率和质量。

4. **方便集成各种优秀框架**

   Spring 不排斥各种优秀的开源框架，相反 Spring 可以降低各种框架的使用难度，Spring 提供了对各种优秀框架（如 Struts、Hibernate、MyBatis）等的直接支持。简化框架的使用。Spring 像插线板一样，其他框架是插头，可以容易的组合到一起。需要使用哪个框架，就把这个插头放入插线板。不需要可以轻易的移除。



##### 3 Spring 体系结构

![image-20220213154605188](https://cdn.jsdelivr.net/gh/xukang0509/picgo_bed/img/202203022112165.png)

​	Spring 由 20 多个模块组成，它们可以分为数据访问/集成（Data Access/Integration）、 Web、面向切面编程（AOP, Aspects）、提供JVM的代理（Instrumentation）、消息发送（Messaging）、核心容器（Core Container）和测试（Test）。



##### 4 框架怎么学

框架是一个软件，其它人写好的软件。

- 知道框架能做什么，mybatis --> 访问数据库，对表中的数据执行增删改查;
- 框架的语法，框架要完成一个功能，需要一定的步骤支持的；
- 框架的内部实现，框架内部怎么做；原理是什么；
- 通过学习，可以实现一个框架。



##### 5 注意

什么样的对象放入容器中：

- dao类，service类，controller类，工具类
- spring的对象默认都是单例的，在容器中叫这个名称的对象只有一个

不放入到spring容器中的对象：

- 实体类对象，实体类数据来自数据库
- servlet、listener、filter



### 二、IOC 控制反转

##### 1 IOC 概述

​	控制反转（IOC，Inversion of Control），是一个概念，是一种思想。指将传统上由程序代码直接操控的对象调用权交给容器，通过容器来实现对象的装配和管理。控制反转就是对对象控制权的转移，从程序代码本身反转到了外部容器。通过容器实现对象的创建，属性赋值， 依赖的管理。

​	IOC 是一个概念，是一种思想，其实现方式多种多样。当前比较流行的实现方式是依赖注入。应用广泛。

​	依赖：classA 类中含有 classB 的实例，在 classA 中调用 classB 的方法完成功能，即 classA 对 classB 有依赖。



IOC的技术实现：

​	依赖注入：DI (Dependency Injection)，程序代码不做定位查询，这些工作由容器自行完成。

​	依赖注入 DI 是指程序运行过程中，若需要调用另一个对象协助时，无须在代码中创建被调用者，而是依赖于外部容器，由外部容器创建后传递给程序。

​	Spring 的依赖注入对调用者与被调用者几乎没有任何要求，完全支持对象之间依赖关系的管理。

​	Spring 框架使用依赖注入（DI）实现 IOC。

​	Spring 容器是一个超级大工厂，负责创建、管理所有的 Java 对象，这些 Java 对象被称为 Bean。Spring 容器管理着容器中 Bean 之间的依赖关系，Spring 使用“依赖注入”的方式来管理 Bean 之间的依赖关系。使用 IOC 实现对象之间的解耦和。

​	Spring 底层创建对象，使用的是反射机制。

```java
控制：创建对象，对象的属性赋值，对象之间的关系管理。
反转：把原来的开发人员管理，创建对象的权限转移给代码之外的容器实现。 由容器代替开发人员管理对象。创建对象，
     给属性赋值。
正转：由开发人员在代码中，使用 new 构造方法创建对象， 开发人员主动管理对象。
     public static void main(String args[]){
        Student student = new Student(); // 在代码中， 创建对象。--正转。
	}
容器：是一个服务器软件，一个框架（spring）
为什么要使用 IOC：目的就是减少对代码的改动，也能实现不同的功能；实现解耦合。

java中创建对象有哪些方式：
  1.构造方法, new Student（）
  2.反射
  3.序列化
  4.克隆
  5.IOC：容器创建对象
  6.动态代理
```



##### 2 开发工具准备

开发工具：idea

依赖管理：maven

jdk：1.8 

需要设置 maven 本机仓库：

![image-20220213161153819](https://cdn.jsdelivr.net/gh/xukang0509/picgo_bed/img/202203022112550.png)



##### 3 Spring 的第一个程序

```
实现步骤：
1.创建maven项目
2.加入maven的依赖
  spring的依赖，版本5.3.15版本
  junit依赖
3.创建类（接口和他的实现类）
  和没有使用框架一样，就是普通的类。
4.创建spring需要使用的配置文件
  声明类的信息，这些类由spring创建和管理
5.测试spring创建的。
```

1. 创建 maven 项目

   ![image-20220213162514511](https://cdn.jsdelivr.net/gh/xukang0509/picgo_bed/img/202203022112843.png)

   ![image-20220213162524820](https://cdn.jsdelivr.net/gh/xukang0509/picgo_bed/img/202203022112202.png)

2. 引入 maven 依赖 pom.xml

   ```xml
   <dependencies>
       <!--单元测试-->
       <dependency>
         <groupId>junit</groupId>
         <artifactId>junit</artifactId>
         <version>4.11</version>
         <scope>test</scope>
       </dependency>
       <!--Spring 依赖-->
       <dependency>
         <groupId>org.springframework</groupId>
         <artifactId>spring-context</artifactId>
         <version>5.2.5.RELEASE</version>
       </dependency>
   </dependencies>
   
     <build>
       <plugins>
         <plugin>
           <artifactId>maven-compiler-plugin</artifactId>
           <version>3.1</version>
           <configuration>
             <source>1.8</source>
             <target>1.8</target>
           </configuration>
         </plugin>
       </plugins>
     </build>
   ```

3. 定义接口与实体类

   ```java
   //定义接口
   package com.spring01.service;
   public interface SomeService {
       void doSome();
   }
   ```

   ```java
   //定义接口实现类
   package com.spring01.service.impl;
   import com.spring01.service.SomeService;
   public class SomeServiceImpl implements SomeService {
       @Override
       public void doSome() {
           System.out.println("执行了SomeServiceImpl的doSome()方法");
       }
   }
   ```

   ```java
   //测试方法 正转
   @Test
   public void test01(){
       SomeService service = new SomeServiceImpl();
       service.doSome();
       //执行了SomeServiceImpl的doSome()方法
   }
   ```

4. 创建 Spring 配置文件

   在 src/main/resources/ 目录现创建一个 xml 文件，文件名可以随意，但 Spring 建议的名称 applicationContext.xml。

   spring 配置中需要加入约束文件才能正常使用，约束文件是 xsd 扩展名。

   ```xml
   <?xml version="1.0" encoding="UTF-8"?>
   <beans xmlns="http://www.springframework.org/schema/beans"
          xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
          xsi:schemaLocation="http://www.springframework.org/schema/beans
          http://www.springframework.org/schema/beans/spring-beans.xsd">
       <!--
           spring的配置文件
           1.beans : 是根标签，spring把java对象成为bean。
           2.spring-beans.xsd 是约束文件，和 mybatis 指定 dtd是一样的。
       -->
   
       <!--
           告诉spring创建对象
           声明bean，就是告诉spring要创建某个类的对象
           id:对象的自定义名称，唯一值。spring 通过这个名称找到对象
           class:类的全限定名称（不能是接口，因为spring是反射机制创建对象，必须使用类）
   
           spring就完成 SomeService someService = new SomeServiceImpl();
           spring是把创建好的对象放入到 map中，spring框架有一个 map存放对象的。
              springMap.put(id的值，对象）；
              例如 springMap.put("someService", new SomeServiceImpl());
   
           注意：一个bean标签声明一个对象。
       -->
       <bean id="someService" class="com.spring01.service.impl.SomeServiceImpl" />
       <bean id="someService1" class="com.spring01.service.impl.SomeServiceImpl" scope="prototype"/>
   
       <!--
          spring能创建一个非自定义类的对象吗？创建一个存在的某个类的对象。
       -->
       <bean id="myDate" class="java.util.Date" />
   </beans>
   ```

   bean 标签：用于定义一个实例对象。一个实例对应一个 bean 元素。 

   ​	id：该属性是 Bean 实例的唯一标识，程序通过 id 属性访问 Bean，Bean 与 Bean 间的依赖关系也是通过 id 属性关联的。 

   ​	class：指定该 Bean 所属的类，注意这里只能是类，不能是接口。

5. 编写测试方法

   ```java
   	/**
        * spring默认创建对象的时间：在创建spring的容器时，会创建配置文件中的所有的对象。
        * spring创建对象：默认调用的是无参数构造方法
        */
   	@Test
       public void test02(){
           //使用 Spring 容器创建对象
           //1.指定Spring配置文件的名称
           String cpnfig = "applicationContext.xml";
   
           //2.创建表示Spring容器的对象，ApplicationContext
           //ApplicationContext 就是表示Spring容器，通过这个容器获取对象
           //ClassPathXmlApplicationContext: 表示从类路径中加载Spring的配置文件
           ApplicationContext ac = new ClassPathXmlApplicationContext(cpnfig);
   
           //3.从Spring中获取对象，使用 id
           SomeService someService = (SomeService) ac.getBean("someService");
           //4.使用对象的业务方法
           someService.doSome();
       }
   ```

6. 容器接口和实现类

   ApplicationContext 接口（容器）

   ApplicationContext 用于加载 Spring 的配置文件，在程序中充当“容器”的角色。其实现类有两个。

   ![image-20220213170519274](https://cdn.jsdelivr.net/gh/xukang0509/picgo_bed/img/202203022113341.png)

   - 配置文件在类路径下

     若 Spring 配置文件存放在项目的类路径下，则使用 ClassPathXmlApplicationContext 实现类进行加载。

     ```java
     //指定Spring配置文件的名称
     String cpnfig = "applicationContext.xml";
     ```

   -  ApplicationContext 容器中对象的装配时机

     ApplicationContext 容器，会在容器对象初始化时，将其中的所有对象一次性全部装配好。以后代码中若要使用到这些对象，只需从内存中直接获取即可。执行效率较高。但占用内存。

     ```java
     //创建表示Spring容器的对象，ApplicationContext
     //ApplicationContext 就是表示Spring容器，通过这个容器获取对象
     //ClassPathXmlApplicationContext: 表示从类路径中加载Spring的配置文件
     ApplicationContext ac = new ClassPathXmlApplicationContext(cpnfig);
     //从Spring中获取对象，使用 id
     SomeService someService = (SomeService) ac.getBean("someService");
     ```

7. 获取Spring容器中Java对象的信息

   ```xml
   <bean id="someService" class="com.spring01.service.impl.SomeServiceImpl" />
   <bean id="someService2" class="com.spring01.service.impl.SomeServiceImpl" />
   <bean id="someService1" class="com.spring01.service.impl.SomeServiceImpl" scope="prototype"/>
   <!--非自定义类-->
   <bean id="myDate" class="java.util.Date" />
   ```

   ```java
   public class SomeServiceImpl implements SomeService {
       public SomeServiceImpl(){
           System.out.println("SomeServiceImpl的无参数构造方法");
       }
       @Override
       public void doSome() {
           System.out.println("执行了SomeServiceImpl的doSome()方法");
       }
   }
   ```

   ```java
   	/**
        *  获取Spring容器中 java 对象的信息
        */
       @Test
       public void test03(){
           String cpnfig = "applicationContext.xml";
           ApplicationContext ac = new ClassPathXmlApplicationContext(cpnfig);
           //使用 Spring 提供的方法，获取容器中定义的对象的数量
           int nums = ac.getBeanDefinitionCount();
           System.out.println("容器中定义的对象数量：" + nums);
           //获取容器中定义的每个对象的名字
           String[] names = ac.getBeanDefinitionNames();
           for (String name : names) {
               System.out.println(name);
           }
       }
   /*
   SomeServiceImpl的无参数构造方法
   SomeServiceImpl的无参数构造方法
   容器中定义的对象数量：4
   someService
   someService2
   someService1
   myDate
   */
   ```

8. junit 单元测试

   ```
   junit : 单元测试，一个工具类库，做测试方法使用的。
   单元：指定的是方法，一个类中有很多方法，一个方法称为单元。
   
     使用单元测试
      1.需要加入junit依赖。
   	<dependency>
         <groupId>junit</groupId>
         <artifactId>junit</artifactId>
         <version>4.11</version>
         <scope>test</scope>
       </dependency>
     2.创建测试作用的类：叫做测试类
       src/test/java目录中创建类
     3.创建测试方法
        1）public 方法
   	 2）没有返回值 void 
   	 3）方法名称自定义，建议名称是test + 你要测试方法名称
   	 4）方法没有参数
   	 5）方法的上面加入 @Test ,这样的方法是可以单独执行的。 不用使用main方法。
   ```

   



```
在spring的配置文件中，给java对象的属性赋值。

di：依赖注入，表示创建对象，给属性赋值。

di的实现有两种：
1.在spring的配置文件中，使用标签和属性完成，叫做基于XML的di实现
2.使用spring中的注解，完成属性赋值，叫做基于注解的id实现

di的语法分类：
 1. set注入（设置注入）：spring调用类的set方法，在set方法可以实现属性的赋值。
    80%左右都是使用的set注入
 2. 构造注入，spring调用类的有参数构造方法，创建对象。在构造方法中完成赋值。

实现步骤：
1.创建maven项目
2.加入maven的依赖
  spring的依赖，版本5.2.5版本
  junit依赖
3.创建类（接口和他的实现类）
  和没有使用框架一样， 就是普通的类。
4.创建spring需要使用的配置文件
  声明类的信息，这些类由spring创建和管理
  通过spring的语法，完成属性的赋值
5.测试spring创建的。
```

##### 4 基于 XML(配置文件) 的 DI (依赖注入)

​	bean 实例在调用无参构造器创建对象后，就要对 bean 对象的属性进行初始化。初始化是由容器自动完成的，称为注入。 

​	根据注入方式的不同，常用的有两类：set 注入、构造注入。

###### 4.1 set 注入

set 注入也叫设值注入，是指通过 set 方法传入被调用者的实例。这种注入方式简单、 直观，因而在 Spring 的依赖注入中大量使用。

- 简单类型

  ```java
  //实体类
  package com.spring01.bao1;
  public class Student {
      private String name;
      private int age;
  	// set get toString
      //注意：必须有 set 方法，没有 set 方法是报错的。
      public Student() {
          System.out.println("spring会调用类的无参数构造方法创建对象");
      }
      public void setEmail(String email){
          System.out.println("setEmail="+email);
      }
     public void setName(String name) {
          System.out.println("setName:"+name);
          this.name = name.toUpperCase();
      }
      public void setAge(int age) {
          System.out.println("setAge:"+age);
          this.age = age;
      }
      public String getName() {
          return name;
      }
      public int getAge() {
          return age;
      }
      @Override
      public String toString() {
          return "Student{" +
                  "name='" + name + '\'' +
                  ", age=" + age +
                  '}';
      }
  }
  ```

  ```xml
  <!--src/main/resources/bao1/applicationContext.xml-->
  <?xml version="1.0" encoding="UTF-8"?>
  <beans xmlns="http://www.springframework.org/schema/beans"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd">
  
      <!--
          声明student对象
          注入：就是赋值的意思
          简单类型： spring中规定java的基本数据类型和String都是简单类型。
          di:给属性赋值
  
          set注入（设值注入） ：spring调用类的set方法， 你可以在set方法中完成属性赋值
              简单类型的set注入
              <bean id="xx" class="yyy">
                 <property name="属性名字" value="此属性的值"/>
                 一个property只能给一个属性赋值
                 <property....>
              </bean>
      -->
      <bean id="myStudent" class="com.spring01.bao1.Student">
          <property name="name" value="李四lisi" /><!--setName("李四")-->
          <property name="age" value="22" /><!--setAge(21)-->
  	    <!--set注入只是使用set方法-->
          <property name="email" value="lisi@qq.com" /><!--setEmail("lisi@qq.com")-->
      </bean>
  </beans>
  ```

  ```java
  	//测试方法	
  	@Test
      public void test01(){
          String cpnfig = "bao1/applicationContext.xml";
          ApplicationContext ac = new ClassPathXmlApplicationContext(cpnfig);
          Student student = (Student) ac.getBean("myStudent");
          System.out.println("student对象=" + student);
      }
  /*
  spring会调用类的无参数构造方法创建对象
  setEmail=lisi@qq.com
  student对象=Student{name='李四lisi', age=22}
  
  先调用构造方法，再调用set方法
  */
  ```

- 引用类型

  ```java
  package com.spring01.bao2;
  public class School {
      private String name;
      private String address;
      public void setName(String name) {
          this.name = name;
      }
      public void setAddress(String address) {
          this.address = address;
      }
      @Override
      public String toString() {
          return "School{" +
                  "name='" + name + '\'' +
                  ", address='" + address + '\'' +
                  '}';
      }
  }
  ```

  ```java
  package com.spring01.bao2;
  
  public class Student {
      private String name;
      private int age;
      //声明一个引用类型
      private School school;
  
      public Student(){
          System.out.println("spring会调用类的无参数构造方法创建对象");
      }
      public void setName(String name) {
          System.out.println("setName:" + name);
          this.name = name;
      }
      public void setAge(int age) {
          System.out.println("setAge:" + age);
          this.age = age;
      }
      public void setSchool(School school) {
          System.out.println("setSchool:" + school);
          this.school = school;
      }
      @Override
      public String toString() {
          return "Student{" +
                  "name='" + name + '\'' +
                  ", age=" + age +
                  ", school=" + school +
                  '}';
      }
  }
  ```

  ```xml
  <!--src/main/resources/bao1/applicationContext.xml-->
  <?xml version="1.0" encoding="UTF-8"?>
  <beans xmlns="http://www.springframework.org/schema/beans"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd">
      <!--
         引用类型的set注入：spring调用类的set方法
          <bean id="xxx" class="yyy">
             <property name="属性名称" ref="bean的id(对象的名称)" />
          </bean>
      -->
      <bean id="myStudent" class="com.spring01.bao2.Student" >
          <property name="name" value="李四lisi" /><!--setName("李四")-->
          <property name="age" value="22" /><!--setAge(21)-->
          <!--引用类型-->
          <property name="school" ref="mySchool" />
      </bean>
      <!--声明School对象-->
      <bean id="mySchool" class="com.spring01.bao2.School">
          <property name="name" value="北京大学"/>
          <property name="address" value="北京的海淀区" />
      </bean>
  </beans>
  ```

  ```java
  public class Test02 {
      @Test
      public void test01(){
          String cpnfig = "bao2/applicationContext.xml";
          ApplicationContext ac = new ClassPathXmlApplicationContext(cpnfig);
          Student student = (Student) ac.getBean("myStudent");
          System.out.println("student对象=" + student);
      }
  }
  /*
  spring会调用类的无参数构造方法创建对象
  setName:李四lisi
  setAge:22
  setSchool:School{name='北京大学', address='北京的海淀区'}
  student对象=Student{name='李四lisi', age=22, school=School{name='北京大学', address='北京的海淀区'}}
  */
  ```

###### 4.2 构造注入

构造注入是指，在构造调用者实例的同时，完成被调用者的实例化。即使用构造器设置依赖关系。

```java
package com.spring01.bao3;

public class Student {
    private String name;
    private int age;
    //声明一个引用类型
    private School school;

    public Student(){
        System.out.println("spring会调用类的无参数构造方法创建对象");
    }
    //创建有参构造方法
    public Student(String name, int age, School school) {
        this.name = name;
        this.age = age;
        this.school = school;
        System.out.println("====Student类有参构造方法====");
    }
    public void setName(String name) {
        this.name = name;
    }
    public void setAge(int age) {
        this.age = age;
    }
    public void setSchool(School school) {
        this.school = school;
    }
    @Override
    public String toString() {
        return "Student{" +
                "name='" + name + '\'' +
                ", age=" + age +
                ", school=" + school +
                '}';
    }
}
```

```java
package com.spring01.bao3;
public class School {
    private String name;
    private String address;
    public void setName(String name) {
        this.name = name;
    }
    public void setAddress(String address) {
        this.address = address;
    }
    @Override
    public String toString() {
        return "School{" +
                "name='" + name + '\'' +
                ", address='" + address + '\'' +
                '}';
    }
}
```

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="http://www.springframework.org/schema/beans
       http://www.springframework.org/schema/beans/spring-beans.xsd">
    <!--
          构造注入：spring调用类有参数构造方法，在创建对象的同时，在构造方法中给属性赋值。
          构造注入使用 <constructor-arg> 标签
          <constructor-arg> 标签：一个<constructor-arg>表示构造方法一个参数。
          <constructor-arg> 标签属性：
             name:表示构造方法的形参名
             index:表示构造方法的参数的位置，参数从左往右位置是 0 ， 1 ，2的顺序
             value：构造方法的形参类型是简单类型的，使用value
             ref：构造方法的形参类型是引用类型的，使用ref
    -->
    <!--使用name属性实现构造注入-->
    <bean id="myStudent" class="com.spring01.bao3.Student" >
        <constructor-arg name="name" value="张三" />
        <constructor-arg name="age" value="20" />
        <constructor-arg name="school" ref="mySchool" />
    </bean>

    <!--使用 index 属性实现构造注入-->
    <bean id="myStudent1" class="com.spring01.bao3.Student" >
        <constructor-arg index="1" value="18" />
        <constructor-arg index="0" value="李四" />
        <constructor-arg index="2" ref="mySchool" />
    </bean>

    <!--省略index-->
    <bean id="myStudent2" class="com.spring01.bao3.Student">
        <constructor-arg  value="张强强" />
        <constructor-arg  value="22" />
        <constructor-arg  ref="mySchool" />
    </bean>

    <!--声明School对象-->
    <bean id="mySchool" class="com.spring01.bao3.School">
        <property name="name" value="北京大学"/>
        <property name="address" value="北京的海淀区" />
    </bean>

    <!--创建File,使用构造注入-->
    <bean id="myFile" class="java.io.File">
        <constructor-arg name="parent" value="X:\Markdown笔记\Java生态" />
        <constructor-arg name="child" value="学习路线.md" />
    </bean>
</beans>
```

```java
public class Test03 {
    @Test
    public void test02(){
        String cpnfig = "bao3/applicationContext.xml";
        ApplicationContext ac = new ClassPathXmlApplicationContext(cpnfig);
        Student student = (Student) ac.getBean("myStudent");
        System.out.println("student对象=" + student);

        Student student1 = (Student) ac.getBean("myStudent1");
        System.out.println("student1对象=" + student1);

        Student student2 = (Student) ac.getBean("myStudent2");
        System.out.println("student2对象=" + student2);

        File myFile = (File) ac.getBean("myFile");
        System.out.println("myFile: " + myFile.getName());
    }
}
/*
====Student类有参构造方法====
====Student类有参构造方法====
====Student类有参构造方法====
student对象=Student{name='张三', age=20, school=School{name='北京大学', address='北京的海淀区'}}
student1对象=Student{name='李四', age=18, school=School{name='北京大学', address='北京的海淀区'}}
student2对象=Student{name='张强强', age=22, school=School{name='北京大学', address='北京的海淀区'}}
myFile: 学习路线.md
*/
```



###### 4.3 引用类型属性自动注入 	

​	对于引用类型属性的注入，也可不在配置文件中显示的注入。可以通过为标签设置 autowire 属性值，为引用类型属性进行隐式自动注入（默认是不自动注入引用类型属 性）。根据自动注入判断标准的不同，可以分为两种：

- byName：根据名称自动注入 
- byType： 根据类型自动注入



1. byName 方式自动注入

   当配置文件中被调用者 bean 的 id 值与代码中调用者 bean 类的属性名相同时，可使用 byName 方式，让容器自动将被调用者 bean 注入给调用者 bean。容器是通过调用者的 bean 类的属性名与配置文件的被调用者 bean 的 id 进行比较而实现自动注入的。

   ```java
   public class School {
       private String name;
       private String address;
       public void setName(String name) {
           this.name = name;
       }
       public void setAddress(String address) {
           this.address = address;
       }
       @Override
       public String toString() {
           return "School{" +
                   "name='" + name + '\'' +
                   ", address='" + address + '\'' +
                   '}';
       }
   }
   ```

   ```java
   public class Student {
       private String name;
       private int age;
       //声明一个引用类型
       private School school;
       public Student(){
       }
       public void setName(String name) {
           this.name = name;
       }
       public void setAge(int age) {
           this.age = age;
       }
       public void setSchool(School school) {
           System.out.println("setSchool:" + school);
           this.school = school;
       }
       @Override
       public String toString() {
           return "Student{" +
                   "name='" + name + '\'' +
                   ", age=" + age +
                   ", school=" + school +
                   '}';
       }
   }
   ```

   ```xml
   <?xml version="1.0" encoding="UTF-8"?>
   <beans xmlns="http://www.springframework.org/schema/beans"
          xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
          xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd">
       <!--
           引用类型的自动注入：spring框架根据某些规则可以给引用类型赋值。不用你在给引用类型赋值了
          使用的规则常用的是byName, byType
          byName(按名称注入)：java类中引用类型的属性名和spring容器中（配置文件）<bean>的id名称一样，
                              且数据类型是一致的，这样的容器中的bean，spring能够赋值给引用类型。
            语法：
            <bean id="xx" class="yyy" autowire="byName">
               简单类型属性赋值
            </bean>
       -->
       <!--byName-->
       <bean id="myStudent" class="com.spring01.bao4.Student" autowire="byName" >
           <property name="name" value="李四lisi" />
           <property name="age" value="22" />
       </bean>
       <!--声明School对象-->
       <bean id="school" class="com.spring01.bao4.School">
           <property name="name" value="北京大学"/>
           <property name="address" value="北京的海淀区" />
       </bean>
   </beans>
   ```

   ```java
   public class Test04 {
       @Test
       public void test02(){
           String cpnfig = "bao4/applicationContext.xml";
           ApplicationContext ac = new ClassPathXmlApplicationContext(cpnfig);
           Student student = (Student) ac.getBean("myStudent");
           System.out.println("student对象=" + student);
       }
   }
   ```

   

2. byType 方式自动注入

   使用 byType 方式自动注入，要求：配置文件中被调用者 bean 的 class 属性指定的类，要与代码中调用者 bean 类的某引用类型属性类型同源。即要么相同，要么有 is-a 关系（子类或是实现类）。但这样的同源的被调用 bean 只能有一个。多于一个，容器就不知该匹配哪一个了。

   ```java
   //子类
   public class PrimarySchool extends School {
   }
   ```

   ```xml
   <?xml version="1.0" encoding="UTF-8"?>
   <beans xmlns="http://www.springframework.org/schema/beans"
          xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
          xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd">
       <!--
           引用类型的自动注入：spring框架根据某些规则可以给引用类型赋值。不用你在给引用类型赋值了
          使用的规则常用的是byName, byType
   
          byType(按类型注入)：java类中引用类型的数据类型和spring容器中（配置文件）<bean>的class属性
                              是同源关系的，这样的bean能够赋值给引用类型
            同源就是一类的意思：
             1.java类中引用类型的数据类型和bean的class的值是一样的。
             2.java类中引用类型的数据类型和bean的class的值父子类关系的。
             3.java类中引用类型的数据类型和bean的class的值接口和实现类关系的
            语法：
            <bean id="xx" class="yyy" autowire="byType">
               简单类型属性赋值
            </bean>
   
            注意：在byType中， 在xml配置文件中声明bean只能有一个符合条件的，
                 多余一个是错误的
       -->
       <!--byType-->
       <bean id="myStudent" class="com.spring01.bao5.Student"  autowire="byType">
           <property name="name" value="张飒" />
           <property name="age" value="26" />
           <!--引用类型-->
           <!--<property name="school" ref="mySchool" />-->
       </bean>
   
       <!--声明School对象-->
       <bean id="mySchool" class="com.spring01.bao5.School">
           <property name="name" value="人民大学"/>
           <property name="address" value="北京的海淀区" />
       </bean>
   
       <!--声明School的子类-->
       <!--<bean id="primarySchool" class="com.spring01.bao5.PrimarySchool">
           <property name="name" value="北京小学" />
           <property name="address" value="北京的大兴区" />
       </bean>-->
   </beans>
   ```

   ```java
   public class Test05 {
       @Test
       public void test05(){
           String cpnfig = "bao5/applicationContext.xml";
           ApplicationContext ac = new ClassPathXmlApplicationContext(cpnfig);
           Student student = (Student) ac.getBean("myStudent");
           System.out.println("student对象=" + student);
       }
   }
   /*
   setSchool:School{name='北京小学', address='北京的大兴区'}
   student对象=Student{name='张飒', age=26, school=School{name='北京小学', address='北京的大兴区'}}
   */
   ```



###### 4.4 为应用指定多个 Spring 配置文件

在实际应用里，随着应用规模的增加，系统中 Bean 数量也大量增加，导致配置文件变得非常庞大、臃肿。为了避免这种情况的产生，提高配置文件的可读性与可维护性，可以将 Spring 配置文件分解成多个配置文件。

```
多个配置优势
  1.每个文件的大小比一个文件要小很多。效率高
  2.避免多人竞争带来的冲突。

  如果你的项目有多个模块（相关的功能在一起） ，一个模块一个配置文件。
  学生考勤模块一个配置文件，  张三
  学生成绩一个配置文件，      李四

多文件的分配方式：
  1. 按功能模块，一个模块一个配置文件
  2. 按类的功能，数据库相关的配置一个文件配置文件，做事务的功能一个配置文件，做service功能的一个配置文件等
```

```java
public class School {
    private String name;
    private String address;
    //set toString
}
```

```java
public class Student {
    private String name;
    private int age;
    //声明一个引用类型
    private School school;
    public Student(){
        System.out.println("spring会调用类的无参数构造方法创建对象");
    }
    public void setName(String name) {
        this.name = name;
    }
    public void setAge(int age) {
        this.age = age;
    }
    public void setSchool(School school) {
        System.out.println("setSchool:" + school);
        this.school = school;
    }
    @Override
    public String toString() {
        return "Student{" +
                "name='" + name + '\'' +
                ", age=" + age +
                ", school=" + school +
                '}';
    }
}
```

```xml
<!--spring-student.xml-->
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd">
    <!--student模块所有bean的声明-->
    <!--byType-->
    <bean id="myStudent" class="com.spring01.bao6.Student"  autowire="byType">
        <property name="name" value="张飒" />
        <property name="age" value="30" />
    </bean>
</beans>
```

```xml
<!--spring-school.xml-->
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd">
    <!--School模块所有bean的声明， School模块的配置文件-->
    <!--声明School对象-->
    <bean id="mySchool" class="com.spring01.bao6.School">
        <property name="name" value="航空大学"/>
        <property name="address" value="北京的海淀区" />
    </bean>
</beans>
```

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd">
    <!--
         包含关系的配置文件：
         spring-total表示主配置文件 ： 包含其他的配置文件的，主配置文件一般是不定义对象的。
         语法：<import resource="其他配置文件的路径" />
         关键字："classpath:" 表示类路径（class文件所在的目录），
               在spring的配置文件中要指定其他文件的位置， 需要使用classpath，告诉spring到哪去加载读取文件。
    -->

    <!--加载的是文件列表-->
    <!--
    <import resource="classpath:ba06/spring-school.xml" />
    <import resource="classpath:ba06/spring-student.xml" />
    -->

    <!--
       在包含关系的配置文件中，可以通配符（*：表示任意字符）
       注意： 主的配置文件名称不能包含在通配符的范围内（不能叫做spring-total.xml）
    -->
    <import resource="classpath:bao6/spring-*.xml" />
</beans>
```

```java
public class Test06 {
    @Test
    public void test06(){
        String cpnfig = "bao6/total.xml";
        ApplicationContext ac = new ClassPathXmlApplicationContext(cpnfig);
        Student student = (Student) ac.getBean("myStudent");
        System.out.println("student对象=" + student);
    }
}
```



##### 5 基于注解的 DI (依赖注入)

###### 5.1 注解概述

使用注解的步骤：

1.加入maven的依赖 spring-context，在你加入spring-context 的同时，间接加入spring-aop的依赖。使用注解必须使用spring-aop依赖；	

2.在类中加入spring的注解（多个不同功能的注解）

3.在spring的配置文件中，加入一个组件扫描器的标签，说明注解在你的项目中的位置

4.使用注解创建对象，创建容器ApplicationContext

```java
学习的注解：
	 @Component
	 @Respotory
	 @Service
	 @Controller
	 @Value
	 @Autowired
	 @Resource
```



###### 5.2 定义 Bean 的注解 @Component

```java
package com.spring01.bao1;
import org.springframework.stereotype.Component;
/**
 * @Component: 创建对象的，等同于<bean>的功能
 *     属性：value 就是对象的名称，也就是bean的id值，
 *          value的值是唯一的，创建的对象在整个spring容器中就一个
 *     位置：在类的上面
 *
 *  @Component(value = "myStudent")等同于
 *   <bean id="myStudent" class="com.spring01.bao1.Student" />
 *
 *  spring中和@Component功能一致，创建对象的注解还有：
 *  1.@Repository（用在持久层类的上面） : 放在dao的实现类上面，
 *               表示创建dao对象，dao对象是能访问数据库的。
 *  2.@Service(用在业务层类的上面)：放在service的实现类上面，
 *              创建service对象，service对象是做业务处理，可以有事务等功能的。
 *  3.@Controller(用在控制器的上面)：放在控制器（处理器）类的上面，创建控制器对象的，
 *              控制器对象，能够接受用户提交的参数，显示请求的处理结果。
 *  以上三个注解的使用语法和@Component一样的。 都能创建对象，但是这三个注解还有额外的功能。
 *  @Repository，@Service，@Controller是给项目的对象分层的。
 */

//使用value属性，指定对象名称
//@Component(value = "myStudent")

//省略value
@Component("myStudent")

//不指定对象名称，由spring提供默认名称: 类名的首字母小写: student
//@Component
public class Student {
    String name;
    Integer age;

    public Student(){
        System.out.println("Student的无参构造方法");
    }

    public void setName(String name) {
        this.name = name;
    }

    public void setAge(Integer age) {
        this.age = age;
    }

    @Override
    public String toString() {
        return "Student{" +
                "name='" + name + '\'' +
                ", age=" + age +
                '}';
    }
}
```

```xml
applicatuionContext.xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:context="http://www.springframework.org/schema/context"
       xsi:schemaLocation="http://www.springframework.org/schema/beans
       http://www.springframework.org/schema/beans/spring-beans.xsd
       http://www.springframework.org/schema/context
       https://www.springframework.org/schema/context/spring-context.xsd">

    <!--
        声明组件扫描器(component-scan),组件就是java对象
        base-package：指定注解在你的项目中的包名。
        component-scan工作方式： spring会扫描遍历base-package指定的包，
            把包中和子包中的所有类，找到类中的注解，按照注解的功能创建对象，或给属性赋值。

        加入了component-scan标签，配置文件的变化：
        1.加入一个新的约束文件spring-context.xsd
        2.给这个新的约束文件起个命名空间的名称
    -->
    <context:component-scan base-package="com.spring01.bao1" />

    <!--指定多个包的三种方式-->
    <!--第一种方式：使用多次组件扫描器，指定不同的包-->
    <context:component-scan base-package="com.spring01.bao1"/>
    <context:component-scan base-package="com.spring01.bao2"/>

    <!--第二种方式：使用分隔符（;或,）分隔多个包名-->
    <context:component-scan base-package="com.spring01.bao1;com.spring01.bao2" />

    <!--第三种方式：指定父包-->
    <context:component-scan base-package="com.spring01" />
</beans>
```

```java
public class MyTest01 {
    @Test
    public void test01(){
        String config = "applicatuionContext.xml";
        ApplicationContext context = new ClassPathXmlApplicationContext(config);
        //从容器中获取对象
        Student student = (Student) context.getBean("myStudent");
        System.out.println("student=" + student);
    }
}
/*
Student的无参构造方法
student=Student{name='null', age=null}
*/
```



###### 5.3 简单类型属性注入@Value

​	需要在属性上使用注解@Value，该注解的 value 属性用于指定要注入的值。 

​	使用该注解完成属性注入时，类中无需 setter。当然，若属性有 setter，则也可将其加到 setter 上。

```java
package com.spring01.bao2;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Component;

@Component("myStudent")
public class Student {
    /**
     * @Value: 简单类型的属性赋值
     *   属性： value 是 String 类型的，表示简单类型的属性值
     *   位置： 1.在属性定义的上面，无需set方法，推荐使用。
     *         2.在set方法的上面
     */
    @Value("张三")
    private String name;
    @Value("16")
    private Integer age;
    
    public Student(){
        System.out.println("Student的无参构造方法");
    }
    public void setName(String name) {
        this.name = name;
    }
    public void setAge(Integer age) {
        this.age = age;
    }
    @Override
    public String toString() {
        return "Student{" +
                "name='" + name + '\'' +
                ", age=" + age +
                '}';
    }
}
```

```java
public class MyTest02 {
    @Test
    public void test01(){
        String config = "applicationContext.xml";
        ApplicationContext context = new ClassPathXmlApplicationContext(config);
        //从容器中获取对象
        Student student = (Student) context.getBean("myStudent");
        System.out.println("student=" + student);
    }
}
/*
Student的无参构造方法
student=Student{name='张三', age=16}
*/
```



###### 5.4 byType 自动注入@Autowired

```java
package com.spring01.bao3;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Component;

@Component("myStudent")
public class Student {
    @Value("李四")
    private String name;
    @Value("20")
    private int age;

    /**
     * 引用类型
     * @Autowired: spring框架提供的注解，实现引用类型的赋值。
     * spring中通过注解给引用类型赋值，使用的是自动注入原理 ，支持byName, byType
     *
     * @Autowired:默认使用的是byType自动注入。
     *  位置：1）在属性定义的上面，无需set方法， 推荐使用
     *       2）在set方法的上面
     */
    //声明一个引用类型
    @Autowired
    private School school;

    public Student(){
        System.out.println("spring会调用类的无参数构造方法创建对象");
    }
    public void setName(String name) {
        this.name = name;
    }
    public void setAge(int age) {
        this.age = age;
    }
    public void setSchool(School school) {
        this.school = school;
    }
    @Override
    public String toString() {
        return "Student{" +
                "name='" + name + '\'' +
                ", age=" + age +
                ", school=" + school +
                '}';
    }
}
```

```java
package com.spring01.bao3;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Component;

@Component("mySchool")
public class School {
    @Value("北京大学")
    private String name;
    @Value("北京的海淀区")
    private String address;
    public void setName(String name) {
        this.name = name;
    }
    public void setAddress(String address) {
        this.address = address;
    }
    @Override
    public String toString() {
        return "School{" +
                "name='" + name + '\'' +
                ", address='" + address + '\'' +
                '}';
    }
}
```

```java
public class MyTest03 {
    @Test
    public void test01(){
        String config = "applicationContext.xml";
        ApplicationContext context = new ClassPathXmlApplicationContext(config);
        //从容器中获取对象
        Student student = (Student) context.getBean("myStudent");
        System.out.println("student=" + student);
    }
}
/*
spring会调用类的无参数构造方法创建对象
student=Student{name='李四', age=20, school=School{name='北京大学', address='北京的海淀区'}}
*/
```



###### 5.5 byName 自动注入@Autowired 与@Qualifier

```java
package com.spring01.bao4;

@Component("myStudent")
public class Student {
    @Value("李四")
    private String name;
    @Value("20")
    private int age;

    /**
     * 引用类型
     * @Autowired: spring框架提供的注解，实现引用类型的赋值。
     * spring中通过注解给引用类型赋值，使用的是自动注入原理 ，支持byName, byType
     *
     *		@Autowired属性：required ，是一个boolean类型的，默认true
     *       		required=true：表示引用类型赋值失败，程序报错，并终止执行。(推荐使用)
     *       		required=false：引用类型如果赋值失败，程序正常执行，引用类型是null
     *
     * @Autowired:默认使用的是byType自动注入。
     *  位置：
     *	     1）在属性定义的上面，无需set方法， 推荐使用
     *       2）在set方法的上面
     *
     * 如果要使用byName方式，需要做的是：
     *    1.在属性上面加入@Autowired
     *    2.在属性上面加入@Qualifier(value="bean的id") ：表示使用指定名称的bean完成赋值。
     */
    //byName 自动注入
    @Autowired(required = false)
    @Qualifier(value = "mySchool")
    private School school;

    public Student(){
        System.out.println("spring会调用类的无参数构造方法创建对象");
    }
    //创建有参构造方法
    public Student(String name, int age, School school) {
        this.name = name;
        this.age = age;
        this.school = school;
        System.out.println("====Student类有参构造方法====");
    }
    public void setName(String name) {
        this.name = name;
    }
    public void setAge(int age) {
        this.age = age;
    }
    public void setSchool(School school) {
        this.school = school;
    }
    @Override
    public String toString() {
        return "Student{" +
                "name='" + name + '\'' +
                ", age=" + age +
                ", school=" + school +
                '}';
    }
}
```

```java
package com.spring01.bao4;

@Component("mySchool")
public class School {
    @Value("北京大学")
    private String name;
    @Value("北京的海淀区")
    private String address;
    public void setName(String name) {
        this.name = name;
    }
    public void setAddress(String address) {
        this.address = address;
    }
    @Override
    public String toString() {
        return "School{" +
                "name='" + name + '\'' +
                ", address='" + address + '\'' +
                '}';
    }
}

```



###### 5.6 JDK 注解@Resource 自动注入

```java
package com.spring01.bao6;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Component;

import javax.annotation.Resource;
@Component("myStudent")
public class Student {
    @Value("李四")
    private String name;
    @Value("20")
    private int age;

    /**
     * 引用类型
     * @Resource: 来自jdk中的注解，spring框架提供了对这个注解的功能支持，可以使用它给引用类型赋值
     *             使用的也是自动注入原理，支持byName,byType; 默认是byName
     *      位置： 1.在属性定义的上面，无需set方法，推荐使用。
     *            2.在set方法的上面
     */
    //默认是byName：先使用byName自动注入，如果byName赋值失败，再使用byType
    @Resource
    private School school;

    public Student(){System.out.println("spring会调用类的无参数构造方法创建对象");}
    //创建有参构造方法
    public void setName(String name) {this.name = name;}
    public void setAge(int age) {this.age = age;}
    public void setSchool(School school) {this.school = school;}
    @Override
    public String toString() {
        return "Student{" +"name='" + name + '\'' +", age=" + age +", school=" + school +'}';
    }
}
```

```java
package com.spring01.bao6;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Component;
@Component("mySchool")
public class School {
    @Value("北京大学")
    private String name;
    @Value("北京的海淀区")
    private String address;
    
    public void setName(String name) {this.name = name;}
    public void setAddress(String address) {this.address = address;}
    @Override
    public String toString() {
        return "School{" +"name='" + name + '\'' + ", address='" + address + '\'' + '}';
    }
}
```

```java
public class MyTest06 {
    @Test
    public void test01(){
        String config = "applicationContext.xml";
        ApplicationContext context = new ClassPathXmlApplicationContext(config);
        //从容器中获取对象
        Student student = (Student) context.getBean("myStudent");
        System.out.println("student=" + student);
    }
}
/*
spring会调用类的无参数构造方法创建对象
student=Student{name='李四', age=20, school=School{name='北京大学', address='北京的海淀区'}}
*/
```



```java
//只用byName
package com.spring01.bao7;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Component;
import javax.annotation.Resource;

@Component("myStudent")
public class Student {
    @Value("李四")
    private String name;
    @Value("20")
    private int age;

    /**
     * 引用类型
     * @Resource: 来自jdk中的注解，spring框架提供了对这个注解的功能支持，可以使用它给引用类型赋值
     *            使用的也是自动注入原理，支持byName， byType .默认是byName
     *  位置： 1.在属性定义的上面，无需set方法，推荐使用。
     *        2.在set方法的上面
     *
     * @Resource 只使用byName方式，需要增加一个属性 name
     * name的值是bean的id（名称）
     */
    //只使用byName
    @Resource(name = "mySchool")
    private School school;

    public Student(){System.out.println("spring会调用类的无参数构造方法创建对象");}
    //创建有参构造方法
    public void setName(String name) {this.name = name;}
    public void setAge(int age) {this.age = age;}
    public void setSchool(School school) {this.school = school;}
    @Override
    public String toString() {
        return "Student{" +"name='" + name + '\'' +", age=" + age +", school=" + school +'}';
    }
}
```



##### 6 注解与 XML 的对比

注解的优点：

- 方便
- 直观
- 高效（代码少，没有配置文件的书写那么复杂）
- 其弊端也显而易见：以硬编码的方式写入到 Java 代码中，修改是需要重新编译代码的。

XML方式的优点：

- 配置和代码是分离的
- 在 xml 中做修改，无需编译代码，只需重启服务器即可将新的配置加载
- xml 的缺点是：编写麻烦，效率低，大型项目过于复杂



### 三、AOP 面向切面编程

##### 1 不使用 AOP 的开发方式

```java
package com.spring01.service;
public interface SomeService {
    void doSome();
    void doOther();
}
```

```java
package com.spring01.service.impl;
import com.spring01.service.SomeService;
import java.util.Date;
public class SomeServiceImpl implements SomeService {
    @Override
    public void doSome() {
        System.out.println("方法执行时间：" + new Date());
        System.out.println("执行业务方法doSome");
        System.out.println("方法执行结束，提交事务");
    }

    @Override
    public void doOther() {
        System.out.println("方法执行时间：" + new Date());
        System.out.println("执行业务方法doOther");
        System.out.println("方法执行结束，提交事务");
    }
}
```

```java
package com.spring01;
import com.spring01.service.SomeService;
import com.spring01.service.impl.SomeServiceImpl;
public class MyApp {
    public static void main(String[] args) {
        //调用doSome, doOther
        SomeService service = new SomeServiceImpl();
        service.doSome();
        System.out.println("===============================");
        service.doOther();
    }
}
/*
方法执行时间：Sat Feb 19 15:01:44 CST 2022
执行业务方法doSome
方法执行结束，提交事务
===============================
方法执行时间：Sat Feb 19 15:01:44 CST 2022
执行业务方法doOther
方法执行结束，提交事务
*/
```



```
动态代理：可以在程序的执行过程中，创建代理对象。
通过代理对象执行方法，给目标类的方法增加额外的功能（功能增强）

jdk动态代理实现步骤：
1.创建目标类，SomeServiceImpl目标类，给它的doSome, doOther增加 输出时间，事务。
2.创建InvocationHandler接口的实现类，在这个类实现给目标方法增加功能。
3.使用jdk中类Proxy，创建代理对象。实现创建对象的能力。
```

```java
//工具类
public class ServiceTools {
    public static void doLog(){ System.out.println("方法执行时间：" + new Date()); }
    public static void doTrans(){ System.out.println("方法执行结束，提交事务"); }
}
```

```java
package com.spring01.service.impl;
import com.spring01.service.SomeService;
public class SomeServiceImpl implements SomeService {
    @Override
    public void doSome() { System.out.println("执行业务方法doSome"); }
    @Override
    public void doOther() { System.out.println("执行业务方法doOther"); }
}
```

```java
package com.spring01.handler;
import com.spring01.util.ServiceTools;
import java.lang.reflect.InvocationHandler;
import java.lang.reflect.Method;

public class MyIncationHandler implements InvocationHandler {
    //目标对象
    private Object target; //SomeServiceImpl类
    public MyIncationHandler(Object target) {
        this.target = target;
    }
    @Override
    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
        //通过代理对象执行方法时，会调用执行这个invoke（）
        System.out.println("执行MyIncationHandler中的invoke()");
        System.out.println("method名称："+method.getName());
        String methodName = method.getName();
        Object res = null;

        if("doSome".equals(methodName)){ //JoinPoint Pointcut
            ServiceTools.doLog(); //在目标方法之前，输出时间
            //执行目标类的方法，通过Method类实现
            res  = method.invoke(target, args); //SomeServiceImpl.doSome()
            ServiceTools.doTrans(); //在目标方法执行之后，提交事务
        } else {
            res  = method.invoke(target, args); //SomeServiceImpl.doOther()
        }

        //目标方法的执行结果
        return res;
    }
}
```

```java
public class MyApp {
    public static void main(String[] args) {
        //使用jdk的Proxy创建代理对象
        //创建目标对象
        SomeService target = new SomeServiceImpl();
        //创建InvocationHandler对象
        InvocationHandler handler = new MyIncationHandler(target);
        //使用Proxy创建代理
        SomeService proxy = (SomeService) Proxy.newProxyInstance(
                target.getClass().getClassLoader(),
                target.getClass().getInterfaces(), handler);
        System.out.println("proxy======"+proxy.getClass().getName());//com.sun.proxy.$Proxy0
        //通过代理执行方法，会调用handler中的invoke（）
        proxy.doSome();
        System.out.println("==================================================");
        proxy.doOther();
    }
}
```



##### 2 AOP 概述

- AOP（Aspect Orient Programming），面向切面编程。面向切面编程是从动态角度考虑程序运行过程。
- AOP 底层，就是采用动态代理模式实现的。采用了两种代理：JDK 的动态代理与 CGLIB 的动态代理。
- AOP 为 Aspect Oriented Programming 的缩写，意为：面向切面编程，可通过运行期动态代理实现程序功能的统一维护的一种技术。AOP 是 Spring 框架中的一个重要内容。利用 AOP 可以对业务逻辑的各个部分进行隔离，从而使得业务逻辑各部分之间的耦合度降低，提高程序的可重用性，同时提高了开发的效率。
- 面向切面编程，就是将交叉业务逻辑封装成切面，利用 AOP 容器的功能将切面织入到主业务逻辑中。所谓交叉业务逻辑是指，通用的、与主业务逻辑无关的代码，如安全检查、 事务、日志、缓存等。
- 若不使用 AOP，则会出现代码纠缠，即交叉业务逻辑与主业务逻辑混合在一起。这样， 会使主业务逻辑变的混杂不清。
- 例如，转账，在真正转账业务逻辑前后，需要权限控制、日志记录、加载事务、结束事务等交叉业务逻辑，而这些业务逻辑与主业务逻辑间并无直接关系。但，它们的代码量所占比重能达到总代码量的一半甚至还多。它们的存在，不仅产生了大量的“冗余”代码，还大大干扰了主业务逻辑 --- 转账。

```
1.动态代理
  实现方式：jdk动态代理，使用jdk中的Proxy，Method，InvocaitonHanderl创建代理对象。
           jdk动态代理要求目标类必须实现接口
  cglib动态代理：第三方的工具库，创建代理对象，原理是继承。 通过继承目标类，创建子类。
             子类就是代理对象。 要求目标类不能是final的， 方法也不能是final的

2.动态代理的作用：
	1）在目标类源代码不改变的情况下，增加功能。
	2）减少代码的重复
	3）专注业务逻辑代码
	4）解耦合，让你的业务功能和日志，事务非业务功能分离。

3.Aop:面向切面编程，基于动态代理的，可以使用jdk，cglib两种代理方式。
  Aop就是动态代理的规范化，把动态代理的实现步骤，方式都定义好了， 
  让开发人员用一种统一的方式，使用动态代理。
  
4.AOP（Aspect Orient Programming）面向切面编程
  Aspect: 切面，给你的目标类增加的功能，就是切面。像上面用的日志，事务都是切面。
          切面的特点：一般都是非业务方法，独立使用的。
  Orient：面向，对着。
  Programming：编程

  oop: 面向对象编程

怎么理解面向切面编程 ？ 
	1）需要在分析项目功能时，找出切面。
	2）合理的安排切面的执行时间（在目标方法前， 还是目标方法后）
	3）合理的安全切面执行的位置，在哪个类，哪个方法增加增强功能

面向切面编程对有什么好处？
	1.减少重复
	2.专注业务
	注意：面向切面编程只是面向对象编程的一种补充。
	
什么时候考虑使用aop技术？
	1.当你要给一个系统中存在的类修改功能，但是原有类的功能不完善，但是你还有源代码，使用aop增加功能
	2.你要给项目中的多个类，增加一个相同的功能，使用aop
	3.给业务方法增加事务，日志输出
```



##### 3 AOP 编程术语

1. 切面（Aspect）：切面泛指交叉业务逻辑。上例中的事务处理、日志处理就可以理解为切面。常用的切面是通知（Advice）、日志、事务、参数检查、权限验证、统计信息。实际就是对主业务逻辑的一种增强。
2. 连接点（JoinPoint）：连接点指可以被切面织入的具体方法。通常业务接口中的方法均为连接点。
3. 切入点（PointCut）：切入点指声明的一个或多个连接点的集合。通过切入点指定一组方法。被标记为 final 的方法是不能作为连接点与切入点的。因为最终的是不能被修改的，不能被增强的。
4. 目标对象（Target）：目标对象指将要被增强的对象。即包含主业务逻辑的类的对象。上例中的 StudentServiceImpl 的对象若被增强，则该类称为目标类，该类对象称为目标对象。当然，不被增强，也就无所谓目标不目标了。
5. 通知（Advice）：通知表示切面的执行时间，Advice 也叫增强。上例中的 MyInvocationHandler 就可以理解为是一种通知。换个角度来说，通知定义了增强代码切入到目标代码的时间点，是目标方法执行之前执行，还是之后执行等。通知类型不同，切入时间不同。 切入点定义切入的位置，通知定义切入的时间。



说一个切面有三个关键的要素：

1. 切面的功能代码，切面干什么
2. 切面的执行位置，使用 Pointcut 表示切面执行的位置
3. 切面的执行时间，使用 Advice 表示时间，在目标方法之前，还是目标方法之后。



##### 4 AspectJ 对 AOP 的实现

```
aop的实现
aop是一个规范，是动态的一个规范化，一个标准
aop的技术实现框架：
1.spring：spring在内部实现了aop规范，能做aop的工作。
	     spring主要在事务处理时使用aop。
		 我们项目开发中很少使用spring的aop实现。 因为spring的aop比较笨重。

2.aspectJ: 一个开源的专门做aop的框架。spring框架中集成了aspectj框架，通过spring就能使用aspectj的功能。
aspectJ框架实现aop有两种方式：
	1.使用xml的配置文件 ： 配置全局事务
	2.使用注解，我们在项目中要做aop功能，一般都使用注解， aspectj有5个注解。
```

###### 4.1 AspectJ 简介

AspectJ 是一个优秀面向切面的框架，它扩展了 Java 语言，提供了强大的切面实现

官网地址：http://www.eclipse.org/aspectj/ 

AspetJ 是 Eclipse 的开源项目，官网介绍如下：

- a seamless aspect-oriented extension to the Javatm programming language（一种基于 Java 平台的面向切面编程的语言） 
- Java platform compatible（兼容 Java 平台，可以无缝扩展） 
- easy to learn and use（易学易用）



###### 4.2 AspectJ 的通知类型

AspectJ 中常用的通知(切面的执行时间)有五种类型：在aspectj框架中使用注解表示的。也可以使用xml配置文件中的标签

1. 前置通知	@Before    
2. 后置通知    @AfterReturning
3. 环绕通知    @Around 
4. 异常通知    @AfterThrowing
5. 最终通知    @After



###### 4.3 AspectJ 的切入点表达式

表示切面执行的位置，使用的是切入点表达式。

AspectJ 定义了专门的表达式用于指定切入点。表达式的原型是：

```
execution(modifiers-pattern? ret-type-pattern 
          declaring-type-pattern?name-pattern(param-pattern)
           throws-pattern?)
```

解释： 

modifiers-pattern		 						访问权限类型 

ret-type-pattern								    返回值类型 

declaring-type-pattern						 包名类名 

name-pattern(param-pattern)			  方法名(参数类型和参数个数) 

throws-pattern									 抛出异常类型 

？														表示可选的部分  

以上表达式共 4 个部分：execution(访问权限 **方法返回值 方法声明(参数)** 异常类型)



切入点表达式要匹配的对象就是目标方法的方法名。所以，execution 表达式中明显就是方法的签名。注意，表达式中不加粗文字表示可省略部分，各部分间用空格分开。在其中可以使用以下符号：

| 符号 | 意义                                                         |
| ---- | ------------------------------------------------------------ |
| *    | 0至多个任意字符                                              |
| ..   | 用在方法参数中，表示任意多个参数<br />用在包名后，表示当前包及其子包路径 |
| +    | 用在类名后，表示当前类及其子类<br />用在接口后，表示当前接口及其实现类 |

```
举例：
execution(public * *(..)) 
指定切入点为：任意公共方法。

execution(* set*(..)) 
指定切入点为：任何一个以“set”开始的方法。

execution(* com.xyz.service.*.*(..)) 
指定切入点为：定义在 service 包里的任意类的任意方法。

execution(* com.xyz.service..*.*(..))
指定切入点为：定义在 service 包或者子包里的任意类的任意方法。“..”出现在类名中时，后
面必须跟“*”，表示包、子包下的所有类。

execution(* *..service.*.*(..))
指定所有包下的 serivce 子包下所有类（接口）中所有方法为切入点

execution(* *.service.*.*(..))
指定只有一级包下的 serivce 子包下所有类（接口）中所有方法为切入点

execution(* *.ISomeService.*(..))
指定只有一级包下的 ISomeSerivce 接口中所有方法为切入点

execution(* *..ISomeService.*(..))
指定所有包下的 ISomeSerivce 接口中所有方法为切入点

execution(* com.xyz.service.IAccountService.*(..)) 
指定切入点为：IAccountService 接口中的任意方法。

execution(* com.xyz.service.IAccountService+.*(..)) 
指定切入点为：IAccountService 若为接口，则为接口中的任意方法及其所有实现类中的任意
方法；若为类，则为该类及其子类中的任意方法。

execution(* joke(String,int)))
指定切入点为：所有的 joke(String,int)方法，且 joke()方法的第一个参数是 String，第二个参
数是 int。如果方法中的参数类型是 java.lang 包下的类，可以直接使用类名，否则必须使用
全限定类名，如 joke( java.util.List, int)。

execution(* joke(String,*))) 
指定切入点为：所有的 joke()方法，该方法第一个参数为 String，第二个参数可以是任意类
型，如joke(String s1,String s2)和joke(String s1,double d2)都是，但joke(String s1,double d2,String 
s3)不是。

execution(* joke(String,..))) 
指定切入点为：所有的 joke()方法，该方法第一个参数为 String，后面可以有任意个参数且
参数类型不限，如 joke(String s1)、joke(String s1,String s2)和 joke(String s1,double d2,String s3)
都是。

execution(* joke(Object))
指定切入点为：所有的 joke()方法，方法拥有一个参数，且参数是 Object 类型。joke(Object ob)
是，但，joke(String s)与 joke(User u)均不是。

execution(* joke(Object+))) 
指定切入点为：所有的 joke()方法，方法拥有一个参数，且参数是 Object 类型或该类的子类。
不仅 joke(Object ob)是，joke(String s)和 joke(User u)也是。
```



###### 4.4 AspectJ 框架实现 AOP

```
使用aspectj框架实现aop。
使用aop：目的是给已经存在的一些类和方法，增加额外的功能。 前提是不改变原来的类的代码。

使用aspectj实现aop的基本步骤：
1.新建maven项目
2.加入依赖
  1）spring依赖
  2）aspectj依赖
  3）junit单元测试
3.创建目标类：接口和他的实现类。
  要做的是给类中的方法增加功能
4.创建切面类：普通类
  1）在类的上面加入 @Aspect
  2）在类中定义方法，方法就是切面要执行的功能代码
    在方法的上面加入aspectj中的通知注解，例如@Before
    有需要指定切入点表达式execution()
5.创建spring的配置文件：声明对象，把对象交给容器统一管理
  声明对象你可以使用注解或者xml配置文件<bean>
  1) 声明目标对象
  2）声明切面类对象
  3）声明aspectj框架中的自动代理生成器标签。
     自动代理生成器：用来完成代理对象的自动创建功能的。
6.创建测试类，从spring容器中获取目标对象（实际就是代理对象）。
  通过代理执行方法，实现aop的功能增强。
```

1. 新建Maven

   骨架：maven-archetype-quickstart

2. 加入依赖

   ```xml
   <!--pom.xml-->
   <dependencies>
       <dependency>
         <groupId>junit</groupId>
         <artifactId>junit</artifactId>
         <version>4.11</version>
         <scope>test</scope>
       </dependency>
       <!--Spring 依赖-->
       <dependency>
         <groupId>org.springframework</groupId>
         <artifactId>spring-context</artifactId>
         <version>5.2.5.RELEASE</version>
       </dependency>
       <!--aspectj 依赖-->
       <dependency>
         <groupId>org.springframework</groupId>
         <artifactId>spring-aspects</artifactId>
         <version>5.2.5.RELEASE</version>
       </dependency>
     </dependencies>
   
     <build>
       <plugins>
         <plugin>
           <artifactId>maven-compiler-plugin</artifactId>
           <version>3.1</version>
           <configuration>
             <source>1.8</source>
             <target>1.8</target>
           </configuration>
         </plugin>
       </plugins>
     </build>
   ```

3. 创建目标类：接口和他的实现类。

   ```java
   //接口
   package org.example.bao1;
   public interface SomeService {
       void doSome(String name, Integer age);
   }
   ```

   ```java
   //接口实现类
   package org.example.bao1;
   public class SomeServiceImpl implements SomeService {
       @Override
       public void doSome(String name, Integer age) {
           //给目标方法增加一个功能，给doSome()执行之前，输出方法的执行时间
           System.out.println("====目标方法doSome====");
       }
   }
   ```

4. 创建切面类：普通类

   ```java
   package org.example.bao1;
   
   import org.aspectj.lang.annotation.Aspect;
   import org.aspectj.lang.annotation.Before;
   
   import java.util.Date;
   /**
    *  @Aspect : 是aspectj框架中的注解。
    *     作用：表示当前类是切面类。
    *     切面类：是用来给业务方法增加功能的类，在这个类中有切面的功能代码
    *     位置：在类定义的上面
    */
   @Aspect
   public class MyAspectj {
       /*
       * 定义方法，方法是实现切面功能的。
       * 方法的定义要求：
       *       1.公共方法 public
       *       2.方法没有返回值
       *       3.方法名称自定义
       *       4.方法可以有参数，也可以没有参数。
       *         如果有参数，参数不是自定义的，有几个参数类型可以使用。
       */
   
       /*
        * @Before: 前置通知注解
        *   属性：value，是切入点表达式，表示切面的功能执行的位置。
        *   位置：在方法的上面
        * 特点：
        *  1.在目标方法之前先执行的
        *  2.不会改变目标方法的执行结果
        *  3.不会影响目标方法的执行。
        */
       @Before(value = "execution(public void org.example.bao1.SomeServiceImpl.doSome(String,Integer))")
       public void myBefore(){
           //就是你切面要执行的功能代码
           System.out.println("前置通知，切面功能：在目标方法之前输出执行时间："+ new Date());
       }
       
       /*
       切入点表达式的多种写法：
       @Before(value = "execution(void org.example.bao1.SomeServiceImpl.doSome(String,Integer))")
       @Before(value = "execution(void *..SomeServiceImpl.doSome(String,Integer))")
       @Before(value = "execution(void *..SomeServiceImpl.do*(String,Integer))")
       @Before(value = "execution(* *..SomeServiceImpl.*(..))")
       @Before(value = "execution(* do*(..))")
       @Before(value = "execution(* org.example.bao1.*ServiceImpl.*(..))")
       */
   }
   ```

5. 创建spring的配置文件：声明对象，把对象交给容器统一管理

   ```xml
   <?xml version="1.0" encoding="UTF-8"?>
   <beans xmlns="http://www.springframework.org/schema/beans"
          xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
          xmlns:aop="http://www.springframework.org/schema/aop"
          xsi:schemaLocation="http://www.springframework.org/schema/beans
          http://www.springframework.org/schema/beans/spring-beans.xsd
          http://www.springframework.org/schema/aop
          https://www.springframework.org/schema/aop/spring-aop.xsd">
       <!--把对象交给spring容器，由spring容器统一创建，管理对象-->
       <!--声明目标对象-->
       <bean id="someService" class="org.example.bao1.SomeServiceImpl" />
       <!--声明切面类对象-->
       <bean id="myAspect" class="org.example.bao1.MyAspectj" />
   
       <!--声明自动代理生成器：使用aspectj框架内部的功能，创建目标对象的代理对象。
           创建代理对象是在内存中实现的，修改目标对象的内存中的结构。创建为代理对象
           所以目标对象就是被修改后的代理对象.
           aspectj-autoproxy:会把spring容器中的所有的目标对象，一次性都生成代理对象。
       -->
       <!--<aop:aspectj-autoproxy />-->
       <aop:aspectj-autoproxy />
   </beans>
   ```

6. 创建测试类，从spring容器中获取目标对象（实际就是代理对象）。

   ```java
   public class MyTest {
       @Test
       public void test01(){
           String config = "applicationContext.xml";
           ApplicationContext ctx = new ClassPathXmlApplicationContext(config);
           //从容器中获取目标对象
           SomeService proxy = (SomeService) ctx.getBean("someService");
           //proxy: com.sun.proxy.$Proxy8: JDK动态代理
           System.out.println("proxy: " + proxy.getClass().getName());
           //通过代理的对象执行方法，实现目标方法执行时，增强了功能
           proxy.doSome("lisi", 20);
       }
   }
   /*
   proxy: com.sun.proxy.$Proxy8
   前置通知，切面功能：在目标方法之前输出执行时间：Sat Feb 19 16:57:08 CST 2022
   ====目标方法doSome====
   */
   ```



##### 5 其他 AOP 通知注解的实现

###### 5.1 指定通知方法中的参数：JoinPoint

```java
package org.example.bao1;
import org.aspectj.lang.JoinPoint;
import org.aspectj.lang.annotation.Aspect;
import org.aspectj.lang.annotation.Before;
import java.util.Date;
@Aspect
public class MyAspectj {
    /*
     * 指定通知方法中的参数 ： JoinPoint
     * JoinPoint:业务方法，要加入切面功能的业务方法
     *    作用是：可以在通知方法中获取方法执行时的信息，例如方法名称，方法的实参。
     *    如果你的切面功能中需要用到方法的信息，就加入JoinPoint.
     *    这个JoinPoint参数的值是由框架赋予，必须是第一个位置的参数
     */
    @Before(value = "execution(void *..SomeServiceImpl.doSome(String,Integer))")
    public void myBefore(JoinPoint jp){
        //获取方法的完整定义
        System.out.println("方法的签名（定义）=" + jp.getSignature());
        System.out.println("方法的名称=" + jp.getSignature().getName());
        //获取方法的实参
        Object args [] = jp.getArgs();
        for (Object arg:args){
            System.out.println("参数="+arg);
        }
        //就是你切面要执行的功能代码
        System.out.println("2=====前置通知，切面功能：在目标方法之前输出执行时间："+ new Date());
    }
}
/*
proxy: com.sun.proxy.$Proxy8
方法的签名（定义）=void org.example.bao1.SomeService.doSome(String,Integer)
方法的名称=doSome
参数=lisi
参数=20
2=====前置通知，切面功能：在目标方法之前输出执行时间：Sat Feb 19 19:21:54 CST 2022
====目标方法doSome====
*/
```

###### 5.2 @AfterReturning 后置通知 - 注解有 returning 属性

```java
//接口
package org.example.bao2;
public interface SomeService {
    String doOther(String name, Integer age);
    Student doAdd(String name, Integer age);
}
```

```java
//接口实现类
package org.example.bao2;
public class SomeServiceImpl implements SomeService {
    @Override
    public String doOther(String name, Integer age) {
        System.out.println("====目标方法doOther====");
        return "spring-aop";
    }
    
    @Override
    public Student doAdd(String name, Integer age) {
        Student student = new Student();
        student.setName(name);
        student.setAge(age);
        System.out.println("student = " + student);
        return student;
    }
}
```

```java
//切面类
package org.example.bao2;
import org.aspectj.lang.JoinPoint;
import org.aspectj.lang.annotation.AfterReturning;
import org.aspectj.lang.annotation.Aspect;
/**
 *  @Aspect : 是aspectj框架中的注解。
 *     作用：表示当前类是切面类。
 *     切面类：是用来给业务方法增加功能的类，在这个类中有切面的功能代码
 *     位置：在类定义的上面
 */
@Aspect
public class MyAspectj {
    /*
     * 后置通知定义方法，方法是实现切面功能的。
     * 方法的定义要求：
     *      1.公共方法 public
     *      2.方法没有返回值
     *      3.方法名称自定义
     *      4.方法有参数的，推荐是Object，参数名自定义
     */

    /*
     * @AfterReturning:后置通知
     *    属性：1.value 切入点表达式
     *         2.returning 自定义的变量，表示目标方法的返回值的。
     *          自定义变量名必须和通知方法的形参名一样。
     *    位置：在方法定义的上面
     * 
     * 特点：
     *  1。在目标方法之后执行的。
     *  2. 能够获取到目标方法的返回值，可以根据这个返回值做不同的处理功能
     *     相当于 Object res = doOther();
     *  3. 可以修改这个返回值
     *
     *  后置通知的执行
     *    Object res = doOther();
     *    参数传递： 传值， 传引用
     *    myAfterReturing(res);
     *    System.out.println("res="+res)
     */
    @AfterReturning(value = "execution(* *..SomeServiceImpl.doOther(..))", returning = "res")
    public void myAfterReturing(JoinPoint jp , Object res){
        // Object res:是目标方法执行后的返回值，根据返回值做你的切面的功能处理
        System.out.println("后置通知：方法的定义"+ jp.getSignature());
        System.out.println("后置通知：在目标方法之后执行的，获取的返回值是：" + res);
        if(res.equals("spring-aop")){
            //做一些功能
        } else{
            //做其它功能
        }
        //修改目标方法的返回值，看一下是否会影响 最后的方法调用结果
        if( res != null){
            res = "Hello Aspectj";
        }
    }
    
    @AfterReturning(value = "execution(* *..SomeServiceImpl.doAdd(..))", returning = "res")
    public void myAfterReturing2(JoinPoint jp , Object res){
        // Object res:是目标方法执行后的返回值，根据返回值做你的切面的功能处理
        System.out.println("后置通知：方法的定义"+ jp.getSignature());
        System.out.println("后置通知：在目标方法之后执行的，获取的返回值是：" + res);

        //修改目标方法的返回值，看一下是否会影响 最后的方法调用结果
        if(res != null && res instanceof Student){
            Student res1 = (Student) res;
            res1.setAge(33);
            res1.setName("张三丰");
        }
    }
}
```

```xml
<!--applicationContext.xml-->
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:aop="http://www.springframework.org/schema/aop"
       xsi:schemaLocation="http://www.springframework.org/schema/beans
       http://www.springframework.org/schema/beans/spring-beans.xsd
       http://www.springframework.org/schema/aop
       https://www.springframework.org/schema/aop/spring-aop.xsd">
    <!--把对象交给spring容器，由spring容器统一创建，管理对象-->
    <!--声明目标对象-->
    <bean id="someService" class="org.example.bao2.SomeServiceImpl" />
    <!--声明切面类对象-->
    <bean id="myAspect" class="org.example.bao2.MyAspectj" />

    <!--声明自动代理生成器：使用aspectj框架内部的功能，创建目标对象的代理对象。
        创建代理对象是在内存中实现的， 修改目标对象的内存中的结构。 创建为代理对象
        所以目标对象就是被修改后的代理对象.
        aspectj-autoproxy:会把spring容器中的所有的目标对象，一次性都生成代理对象。
    -->
    <!--<aop:aspectj-autoproxy />-->
    <aop:aspectj-autoproxy />
</beans>
```

```java
package org.example;

import org.example.bao2.SomeService;
import org.junit.Test;
import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;

public class MyTest {
    @Test
    public void test01(){
        String config = "applicationContext.xml";
        ApplicationContext ctx = new ClassPathXmlApplicationContext(config);
        //从容器中获取目标对象
        SomeService proxy = (SomeService) ctx.getBean("someService");
        //通过代理的对象执行方法，实现目标方法执行时，增强了功能
        String str = proxy.doOther("张三", 28);
        System.out.println("str = " + str);
        System.out.println("========================================");
        Student s = proxy.doAdd("张三", 28);
        System.out.println("student = " + s);
    }
}
/*
====目标方法doOther====
后置通知：方法的定义String org.example.bao2.SomeService.doOther(String,Integer)
后置通知：在目标方法之后执行的，获取的返回值是：spring-aop
str = spring-aop
========================================
student = Student{name='张三', age=28}
后置通知：方法的定义Student org.example.bao2.SomeService.doAdd(String,Integer)
后置通知：在目标方法之后执行的，获取的返回值是：Student{name='张三', age=28}
student = Student{name='张三丰', age=33}
*/
```

###### 5.3 @Around 环绕通知-增强方法有 ProceedingJoinPoint 参数

​	在目标方法执行之前之后执行。被注解为环绕增强的方法要有返回值，Object 类型。并且方法可以包含一个 ProceedingJoinPoint 类型的参数。接口 ProceedingJoinPoint 其有一个 proceed() 方法，用于执行目标方法。若目标方法有返回值，则该方法的返回值就是目标方法的返回值。最后，环绕增强方法将其返回值返回。该增强方法实际是拦截了目标方法的执行。

```java
package org.example.bao3;
public interface SomeService {
    String doFirst(String name, Integer age);
}
```

```java
package org.example.bao3;
import org.example.bao1.Student;
public class SomeServiceImpl implements SomeService {
    @Override
    public String doFirst(String name, Integer age) {
        System.out.println("====业务方法doFirst()====");
        return "doFirst";
    }
}
```

```java
package org.example.bao3;
import org.aspectj.lang.JoinPoint;
import org.aspectj.lang.ProceedingJoinPoint;
import org.aspectj.lang.annotation.AfterReturning;
import org.aspectj.lang.annotation.Around;
import org.aspectj.lang.annotation.Aspect;
import org.example.bao1.Student;
import java.util.Date;
@Aspect
public class MyAspectj {
    /**
    * 环绕通知方法的定义格式
    *       1.public
    *       2.必须有一个返回值，推荐使用Object
    *       3.方法名称自定义
    *       4.方法有参数，固定的参数 ProceedingJoinPoint
    */

    /*
     * @Around: 环绕通知
     *      属性：value 切入点表达式
     *      位置：在方法的定义上面
     * 特点：
     *   1.它是功能最强的通知
     *   2.在目标方法的前和后都能增强功能。
     *   3.控制目标方法是否被调用执行
     *   4.修改原来的目标方法的执行结果。影响最后的调用结果
     *
     *  环绕通知，等同于jdk动态代理的，InvocationHandler接口
     *
     *  参数：ProceedingJoinPoint 就等同于 Method
     *       作用：执行目标方法的
     *  返回值：就是目标方法的执行结果，可以被修改。
     *
     *  环绕通知：经常做事务，在目标方法之前开启事务，执行目标方法，在目标方法之后提交事务
     */
    @Around(value = "execution(* *..SomeServiceImpl.doFirst(..))")
    public Object myAround(ProceedingJoinPoint pjp) throws Throwable {
        String name = "";
        //获取第一个参数值
        Object args [] = pjp.getArgs();
        if( args!= null && args.length > 1){
            Object arg = args[0];
            name = (String) arg;
        }

        //实现环绕通知
        Object result = null;
        System.out.println("环绕通知：在目标方法之前，输出时间："+ new Date());
        //1.目标方法调用
        if( "张三".equals(name)){
            //符合条件，调用目标方法
            result = pjp.proceed(); //method.invoke(); Object result = doFirst();
        }
        //2.在目标方法后加入功能
        System.out.println("环绕通知：在目标方法之后，提交事务");
        //修改目标方法的执行结果， 影响方法最后的调用结果
        if( result != null){
            result = "Hello AspectJ AOP";
        }
        //返回目标方法的执行结果
        return result;
    }
}
```

```java
public class MyTest03 {
    @Test
    public void test01(){
        String config = "applicationContext.xml";
        ApplicationContext ctx = new ClassPathXmlApplicationContext(config);
        //从容器中获取目标对象
        SomeService proxy = (SomeService) ctx.getBean("someService");
        //通过代理的对象执行方法，实现目标方法执行时，增强了功能
        String str = proxy.doFirst("张三", 30);
        System.out.println("str = " + str);
    }
}
/*
环绕通知：在目标方法之前，输出时间：Sat Feb 19 20:15:43 CST 2022
====业务方法doFirst()====
环绕通知：在目标方法之后，提交事务
str = Hello AspectJ AOP
*/
```

###### 5.4 @AfterThrowing 异常通知-注解中有 throwing 属性

​	在目标方法抛出异常后执行。该注解的 throwing 属性用于指定所发生的异常类对象。当然，被注解为异常通知的方法可以包含一个参数 Throwable，参数名称为 throwing 指定的名称，表示发生的异常对象。

```java
package org.example.bao4;
public interface SomeService {
    void doSecond();
}
```

```java
package org.example.bao4;
public class SomeServiceImpl implements SomeService {
    @Override
    public void doSecond() {
        System.out.println("====业务方法doSecond()====" + (10/0));
    }
}
```

```java
package org.example.bao4;
import org.aspectj.lang.ProceedingJoinPoint;
import org.aspectj.lang.annotation.AfterThrowing;
import org.aspectj.lang.annotation.Around;
import org.aspectj.lang.annotation.Aspect;
import java.util.Date;
@Aspect
public class MyAspectj {
    /**
    * 异常通知方法的定义格式
    *    1.public
    *    2.没有返回值
    *    3.方法名称自定义
    *    4.方法有一个参数 Exception，如果还有是 JoinPoint,
    */

    /*
     * @AfterThrowing: 异常通知
     *     属性：1. value 切入点表达式
     *          2. throwinng 自定义的变量，表示目标方法抛出的异常对象。
     *             变量名必须和方法的参数名一样
     * 特点：
     *   1. 在目标方法抛出异常时执行的
     *   2. 可以做异常的监控程序， 监控目标方法执行时是不是有异常。
     *      如果有异常，可以发送邮件，短信进行通知
     *
     *  执行就是：
     *   try{
     *       SomeServiceImpl.doSecond(..)
     *   }catch(Exception e){
     *       myAfterThrowing(e);
     *   }
     */
    @AfterThrowing(value = "execution(* *..SomeServiceImpl.doSecond(..))", throwing = "ex")
    public void myAfterThrowing(Exception ex) {
        System.out.println("异常通知：方法发生异常时，执行：" + ex.getMessage());
        //发送邮件，短信，通知开发人员
    }
}
```

```java
public class MyTest04 {
    @Test
    public void test01(){
        String config = "applicationContext.xml";
        ApplicationContext ctx = new ClassPathXmlApplicationContext(config);
        //从容器中获取目标对象
        SomeService proxy = (SomeService) ctx.getBean("someService");
        proxy.doSecond();
    }
}
/*
异常通知：方法发生异常时，执行：/ by zero

java.lang.ArithmeticException: / by zero
	at org.example.bao4.SomeServiceImpl.doSecond(SomeServiceImpl.java:6)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	......
*/
```

###### 5.5 @After 最终通知

无论目标方法是否抛出异常，该增强均会被执行。

```java
public interface SomeService {
    void doThird();
}
```

```java
public class SomeServiceImpl implements SomeService {
    @Override
    public void doThird() {
        System.out.println("====业务方法doThird()====" + (10/0));
    }
}
```

```java
@Aspect
public class MyAspectj {
    /**
     * 最终通知方法的定义格式
     *      1.public
     *      2.没有返回值
     *      3.方法名称自定义
     *      4.方法没有参数，如果还有是JoinPoint,
     */

    /*
     * @After :最终通知
     *      属性：value 切入点表达式
     *      位置：在方法的上面
     * 特点：
     *  1.总是会执行
     *  2.在目标方法之后执行的
     *
     *  try{
     *      SomeServiceImpl.doThird(..)
     *  }catch(Exception e){
     *
     *  }finally{
     *      myAfter()
     *  }
     */
    @After(value = "execution(* *..SomeServiceImpl.doThird(..))")
    public void myAfter(){
        System.out.println("执行最终通知，总是会被执行的代码");
        //一般做资源清除工作的。
    }
}
```

```java
public class MyTest05 {
    @Test
    public void test01(){
        String config = "applicationContext.xml";
        ApplicationContext ctx = new ClassPathXmlApplicationContext(config);
        //从容器中获取目标对象
        SomeService proxy = (SomeService) ctx.getBean("someService");
        //通过代理的对象执行方法，实现目标方法执行时，增强了功能
        proxy.doThird();
    }
}
/*
执行最终通知，总是会被执行的代码

java.lang.ArithmeticException: / by zero
	at org.example.bao5.SomeServiceImpl.doThird(SomeServiceImpl.java:6)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:498)
	......
*/
```

###### 5.6 @Pointcut 定义切入点

​	当较多的通知增强方法使用相同的 execution 切入点表达式时，编写、维护均较为麻烦。AspectJ 提供了@Pointcut 注解，用于定义 execution 切入点表达式。 

​	其用法是，将 @Pointcut 注解在一个方法之上，以后所有的 execution 的 value 属性值均可使用该方法名作为切入点。代表的就是 @Pointcut 定义的切入点。这个使用 @Pointcut 注解的方法一般使用 private 的标识方法，即没有实际作用的方法

```java
@Aspect
public class MyAspectj {
    @After(value = "mypt()")
    public void myAfter(){
        System.out.println("执行最终通知，总是会被执行的代码");
        //一般做资源清除工作的。
    }

    @Before(value = "mypt()")
    public void myBefore(){
        System.out.println("前置通知，在目标方法之前先执行的");
    }

    /*
     * @Pointcut: 定义和管理切入点，如果你的项目中有多个切入点表达式是重复的，可以复用的。可以使用@Pointcut
     *    属性：value 切入点表达式
     *    位置：在自定义的方法上面
     * 特点：
     *   当使用 @Pointcut 定义在一个方法的上面，此时这个方法的名称就是切入点表达式的别名。
     *   其它的通知中，value属性就可以使用这个方法名称，代替切入点表达式了
     */
    @Pointcut(value = "execution(* *..SomeServiceImpl.doThird(..))" )
    private void mypt(){ /*无需代码*/ }
}
```

###### 5.7 cglib 代理

```java
public class SomeServiceImpl {
    public void doThird() {
        System.out.println("====业务方法doThird()====");
    }
}
```

```java
@Aspect
public class MyAspectj {
    @After(value = "mypt()")
    public void myAfter(){
        System.out.println("执行最终通知，总是会被执行的代码");
        //一般做资源清除工作的。
    }

    @Before(value = "mypt()")
    public void myBefore(){
        System.out.println("前置通知，在目标方法之前先执行的");
    }

    /*
     * @Pointcut: 定义和管理切入点，如果你的项目中有多个切入点表达式是重复的，可以复用的。可以使用@Pointcut
     *    属性：value 切入点表达式
     *    位置：在自定义的方法上面
     * 特点：
     *   当使用 @Pointcut 定义在一个方法的上面，此时这个方法的名称就是切入点表达式的别名。
     *   其它的通知中，value属性就可以使用这个方法名称，代替切入点表达式了
     */
    @Pointcut(value = "execution(* *..SomeServiceImpl.doThird(..))" )
    private void mypt(){ /*无需代码*/ }
}
```

```xml
    <!--声明目标对象-->
    <bean id="someService" class="org.example.bao7.SomeServiceImpl" />
    <!--声明切面类对象-->
    <bean id="myAspect" class="org.example.bao7.MyAspectj" />

    <!--声明自动代理生成器：使用aspectj框架内部的功能，创建目标对象的代理对象。
        创建代理对象是在内存中实现的， 修改目标对象的内存中的结构。 创建为代理对象
        所以目标对象就是被修改后的代理对象.
        aspectj-autoproxy:会把spring容器中的所有的目标对象，一次性都生成代理对象。
    -->
    <!--<aop:aspectj-autoproxy />-->
    <aop:aspectj-autoproxy />
```

```java
public class MyTest07 {
    @Test
    public void test01(){
        String config = "applicationContext.xml";
        ApplicationContext ctx = new ClassPathXmlApplicationContext(config);
        //从容器中获取目标对象
        SomeServiceImpl proxy = (SomeServiceImpl) ctx.getBean("someService");
        /*
        * 目标类没有接口，使用cglib动态接口，spring框架会自动使用cglib
        * proxy: org.example.bao7.SomeServiceImpl$$EnhancerBySpringCGLIB$$2b7b679f
        * */
        System.out.println("proxy: " + proxy.getClass().getName());
        //通过代理的对象执行方法，实现目标方法执行时，增强了功能
        proxy.doThird();
    }
}
/*
proxy: org.example.bao7.SomeServiceImpl$$EnhancerBySpringCGLIB$$2b7b679f
前置通知，在目标方法之前先执行的
====业务方法doThird()====
执行最终通知，总是会被执行的代码
*/
```



有接口也可以使用cglib代理

```xml
    <!--声明自动代理生成器：使用aspectj框架内部的功能，创建目标对象的代理对象。
        创建代理对象是在内存中实现的， 修改目标对象的内存中的结构。 创建为代理对象
        所以目标对象就是被修改后的代理对象.

        aspectj-autoproxy:会把spring容器中的所有的目标对象，一次性都生成代理对象。
    -->
    <!--<aop:aspectj-autoproxy />-->


    <!--
       如果你期望目标类有接口，使用cglib代理
       proxy-target-class="true":告诉框架，要使用cglib动态代理
    -->
    <aop:aspectj-autoproxy proxy-target-class="true"/>
```



### 四、Spring 集成 MyBatis

​	将 MyBatis 与 Spring 进行整合，主要解决的问题就是将 SqlSessionFactory 对象交由 Spring 来管理。所以，该整合只需要将 SqlSessionFactory 的对象生成器 SqlSessionFactoryBean 注册在 Spring 容器中，再将其注入给 Dao 的实现类即可完成整合。

​	实现 Spring 与 MyBatis 的整合常用的方式：扫描的 Mapper 动态代理；

​	Spring 像插线板一样，mybatis 框架是插头，可以容易的组合到一起。插线板 spring 插上 mybatis，两个框架就是一个整体。

```
把 mybatis框架和 spring 集成在一起，像一个框架一样使用。

用的技术是：ioc 
为什么是ioc：能把mybatis和spring集成在一起，像一个框架，是因为ioc能创建对象。
 	可以把mybatis框架中的对象交给spring统一创建，开发人员从spring中获取对象。
 	开发人员就不用同时面对两个或多个框架了，就面对一个spring

mybatis使用步骤，对象
	1.定义dao接口 ，StudentDao
	2.定义mapper文件 StudentDao.xml
	3.定义mybatis的主配置文件 mybatis.xml
	4.创建dao的代理对象， StudentDao dao = SqlSession.getMapper(StudentDao.class);
   		List<Student> students  = dao.selectStudents();

要使用dao对象，需要使用getMapper()方法，
怎么能使用getMapper()方法，需要哪些条件
	1.获取SqlSession对象， 需要使用SqlSessionFactory的openSession()方法。
	2.创建SqlSessionFactory对象。通过读取mybatis的主配置文件，能创建SqlSessionFactory对象

需要SqlSessionFactory对象，使用Factory能获取SqlSession，有了SqlSession就能有dao，目的就是获取dao对象
Factory创建需要读取主配置文件

我们会使用独立的连接池类替换mybatis默认自己带的，把连接池类也交给spring创建。

主配置文件：
 1.数据库信息
 		<environment id="mydev">
            <transactionManager type="JDBC"/>
            <dataSource type="POOLED">
                <property name="driver" value="com.mysql.jdbc.Driver"/>
                <property name="url" value="jdbc:mysql://localhost:3306/springdb"/>
                <property name="username" value="root"/>
                <property name="password" value="123456"/>
            </dataSource>
         </environment>
2. mapper文件的位置
   <mappers>
        <mapper resource="com/bjpowernode/dao/StudentDao.xml"/>
        <!--<mapper resource="com/bjpowernode/dao/SchoolDao.xml" />-->
   </mappers>
   
==============================================================
通过以上的说明，我们需要让spring创建以下对象
1.独立的连接池类的对象，使用阿里的druid连接池
2.SqlSessionFactory对象
3.创建出dao对象   

需要学习就是上面三个对象的创建语法，使用xml的bean标签。

连接池：多个连接Connection对象的集合，List<Connection> connlist : connList就是连接池

通常使用Connection访问数据库
Connection conn = DriverManger.getConnection(url,username,password);
Statemenet stmt = conn.createStatement(sql);
stmt.executeQuery();
conn.close();

使用连接池
在程序启动的时候，先创建一些Connection
Connection c1 = ...
Connection c2 = ...
Connection c3 = ...
List<Connection>  connlist = new ArrayLits();
connList.add(c1);
connList.add(c2);
connList.add(c3);

Connection conn = connList.get(0);
Statemenet stmt = conn.createStatement(sql);
stmt.executeQuery();
把使用过的connection放回到连接池
connList.add(conn);

Connection conn1 = connList.get(1);
Statemenet stmt = conn1.createStatement(sql);
stmt.executeQuery();
把使用过的connection放回到连接池
connList.add(conn1);
```

```
spring和mybatis的集成
步骤：
1.新建maven项目
2.加入maven的依赖
  1）spring依赖
  2）mybatis依赖
  3）mysql驱动
  4）spring的事务的依赖
  5）mybatis和spring集成的依赖：mybatis官方体用的，用来在spring项目中创建mybatis
    的SqlSesissonFactory，dao对象的
3.创建实体类
4.创建dao接口和mapper文件
5.创建mybatis主配置文件
6.创建Service接口和实现类，属性是dao。
7.创建spring的配置文件：声明mybatis的对象交给spring创建
 1）数据源DataSource
 2）SqlSessionFactory
 3) Dao对象
 4）声明自定义的service
8.创建测试类，获取Service对象，通过service调用dao完成数据库的访问
```



##### 1 MySQL 创建数据库 springdb，新建表 Student

![image-20220221183712808](https://cdn.jsdelivr.net/gh/xukang0509/picgo_bed/img/202203022113156.png)



```mysql
CREATE TABLE `student` (
 `id` int(11) NOT NULL ,
 `name` varchar(255) DEFAULT NULL,
 `email` varchar(255) DEFAULT NULL,
 `age` int(11) DEFAULT NULL,
 PRIMARY KEY (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;
```

##### 2 maven 依赖 pom.xml

```xml
<!--pom.xml-->
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0" 
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
  <modelVersion>4.0.0</modelVersion>

  <groupId>org.example</groupId>
  <artifactId>ch07-spring-mybatis</artifactId>
  <version>1.0-SNAPSHOT</version>

  <properties>
    <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
    <maven.compiler.source>1.8</maven.compiler.source>
    <maven.compiler.target>1.8</maven.compiler.target>
  </properties>

  <dependencies>
    <!--单元测试-->
    <dependency>
      <groupId>junit</groupId>
      <artifactId>junit</artifactId>
      <version>4.11</version>
      <scope>test</scope>
    </dependency>
    <!--Spring核心IOC-->
    <dependency>
      <groupId>org.springframework</groupId>
      <artifactId>spring-context</artifactId>
      <version>5.2.5.RELEASE</version>
    </dependency>
    <!--做Spring事务用到的-->
    <dependency>
      <groupId>org.springframework</groupId>
      <artifactId>spring-tx</artifactId>
      <version>5.2.5.RELEASE</version>
    </dependency>
    <dependency>
      <groupId>org.springframework</groupId>
      <artifactId>spring-jdbc</artifactId>
      <version>5.2.5.RELEASE</version>
    </dependency>
    <!--mybatis依赖-->
    <dependency>
      <groupId>org.mybatis</groupId>
      <artifactId>mybatis</artifactId>
      <version>3.5.1</version>
    </dependency>
    <!--mybatis和spring集成的依赖-->
    <dependency>
      <groupId>org.mybatis</groupId>
      <artifactId>mybatis-spring</artifactId>
      <version>1.3.1</version>
    </dependency>
    <!--mysql驱动-->
    <dependency>
      <groupId>mysql</groupId>
      <artifactId>mysql-connector-java</artifactId>
      <version>5.1.9</version>
    </dependency>
    <!--阿里公司的数据库连接池-->
    <dependency>
      <groupId>com.alibaba</groupId>
      <artifactId>druid</artifactId>
      <version>1.1.12</version>
    </dependency>
  </dependencies>

  <build>
    <resources>
      <!--目的是把src/main/java目录中的xml文件包含到输出结果中，输出到classes目录中-->
      <resource>
        <directory>src/main/java</directory><!--所在的目录-->
        <includes><!--包括目录下的.properties,.xml 文件都会扫描到-->
          <include>**/*.properties</include>
          <include>**/*.xml</include>
        </includes>
        <filtering>false</filtering>
      </resource>
    </resources>
    <plugins>
      <!--指定JDK的版本-->
      <plugin>
        <artifactId>maven-compiler-plugin</artifactId>
        <version>3.1</version>
        <configuration>
          <source>1.8</source>
          <target>1.8</target>
        </configuration>
      </plugin>
    </plugins>
  </build>
</project>
```

##### 3 定义实体类 Student

```java
package org.example.domain;

public class Student {
    //属性名和列名一样
    private Integer id;
    private String name;
    private String email;
    private Integer age;

    public Student() {}
    public Student(Integer id, String name, String email, Integer age) {
        this.id = id;
        this.name = name;
        this.email = email;
        this.age = age;
    }

    public Integer getId() {return id; }
    public void setId(Integer id) { this.id = id; }
    public String getName() { return name; }
    public void setName(String name) { this.name = name; }
    public String getEmail() { return email; }
    public void setEmail(String email) { this.email = email; }
    public Integer getAge() { return age; }
    public void setAge(Integer age) { this.age = age; }
    
    @Override
    public String toString() {
        return "Student{" +  "id=" + id + ", name='" + name + '\'' + ", email='" + email + '\'' + ", age=" + age + '}';
    }
}
```

##### 4 定义 StudentDao 接口

```java
package org.example.dao;
import org.example.domain.Student;
import java.util.List;
public interface StudentDao {
    int insertStudent(Student student);
    List<Student> selectStudents();
}
```

##### 5 定义映射文件 mapper

```xml
<!--package org.example.dao.StudentDao.xml-->
<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE mapper
        PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
        "http://mybatis.org/dtd/mybatis-3-mapper.dtd">
<mapper namespace="org.example.dao.StudentDao">
    <select id="selectStudents" resultType="org.example.domain.Student">
        select id, name, email, age from student order by id desc
    </select>

    <insert id="insertStudent">
        insert into student values(#{id}, #{name}, #{email}, #{age})
    </insert>
</mapper>
```

##### 6 定义 MyBatis 主配置文件

```xml
<!--src/main/resources/mybatis_config.xml-->

<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE configuration
        PUBLIC "-//mybatis.org//DTD Config 3.0//EN"
        "http://mybatis.org/dtd/mybatis-3-config.dtd">
<configuration>
   <settings>
       <!--设置mybatis输出日志-->
       <setting name="logImpl" value="STDOUT_LOGGING"/>
   </settings>

    <!--设置别名-->
    <typeAliases>
        <!--name：实体类所在的包名-->
        <package name="org.example.domain"/>
    </typeAliases>

    <!-- sql mapper（sql映射文件）的位置-->
    <mappers>
        <!-- name：是包名，这个包中的所有 mapper.xml 一次都能加载 -->
        <package name="org.example.dao"/>
    </mappers>
</configuration>
```

##### 7 定义 Service 接口和实现类

```java
package org.example.service;
import org.example.domain.Student;
import java.util.List;
public interface StudentService {
    int addStudent(Student student);
    List<Student> queryStudents();
}
```

```java
package org.example.service.impl;

import org.example.dao.StudentDao;
import org.example.domain.Student;
import org.example.service.StudentService;

import java.util.List;

public class StudentServiceImpl implements StudentService {
    //引用类型
    private StudentDao studentDao;
    //使用set注入，赋值
    public void setStudentDao(StudentDao studentDao) {
        this.studentDao = studentDao;
    }

    @Override
    public int addStudent(Student student) {
        int nums = studentDao.insertStudent(student);
        return nums;
    }

    @Override
    public List<Student> queryStudents() {
        List<Student> students = studentDao.selectStudents();
        return students;
    }
}
```

##### 8 修改 Spring 配置文件

###### 8.1 数据源的配置(掌握)

Druid 数据源 DruidDataSource：

Druid 是阿里的开源数据库连接池。是 Java 语言中最好的数据库连接池。Druid 能够提供强大的监控和扩展功能。

官网：https://github.com/alibaba/druid 

使用地址：https://github.com/alibaba/druid/wiki/FAQ

```xml
	<!--声明数据源DataSource,作用是连接数据库-->
    <bean id="myDataSource" class="com.alibaba.druid.pool.DruidDataSource"
          init-method="init" destroy-method="close">
        <!--set注入给DuridDataSource提供连接数据库的信息-->
        <property name="url" value="jdbc:mysql://localhost:3306/springdb" />
        <property name="username" value="root" />
        <property name="password" value="111" />
        <property name="maxActive" value="20" /> <!--最大连接数-->
     </bean>
```

###### 8.2 从属性文件读取数据库连接信息

```properties
#src/main/resources/jdbc.properties
jdbc.url=jdbc:mysql://localhost:3306/springdb
jdbc.username=root
jdbc.password=111
jdbc.maxActive=20
```

```xml
	<!--
       把数据库的配置信息，写在一个独立的文件，编译修改数据库的配置内容
       spring知道jdbc.properties文件的位置
    -->
    <context:property-placeholder location="classpath:jdbc.properties" />

    <!--声明数据源DataSource,作用是连接数据库-->
    <bean id="myDataSource" class="com.alibaba.druid.pool.DruidDataSource"
          init-method="init" destroy-method="close">
        <!--set注入给DuridDataSource提供连接数据库的信息-->
        <property name="url" value="${jdbc.url}" />
        <property name="username" value="${jdbc.username}" />
        <property name="password" value="${jdbc.password}" />
        <property name="maxActive" value="${jdbc.maxActive}" /> <!--最大连接数-->
     </bean>
```

###### 8.3 注册 SqlSessionFactoryBean

```xml
	<!--声明的是mybatis中提供的SqlSessionFactoryBean类，这个类内部创建SqlSessionFactory的
         SqlSessionFactory sqlSessionFactory = new ..
     -->
    <bean id="sqlSessionFactory" class="org.mybatis.spring.SqlSessionFactoryBean">
        <!--set注入，把数据库连接池付给了dataSource属性-->
        <property name="dataSource" ref="myDataSource" />
        <!--
           mybatis主配置文件的位置
           configLocation属性是Resource类型，读取配置文件
           它的赋值，使用value，指定文件的路径，使用 classpath:表示文件的位置
        -->
        <property name="configLocation" value="classpath:mybatis_config.xml" />
    </bean>
```

###### 8.4 定义 Mapper 扫描配置器 MapperScannerConfigurer

```xml
	<!--创建dao对象，使用SqlSession的getMapper(StudentDao.class)
        MapperScannerConfigurer:在内部调用getMapper()生成每个dao接口的代理对象
    -->
    <bean class="org.mybatis.spring.mapper.MapperScannerConfigurer" >
        <!--指定SqlSessionFactory对象的id-->
        <property name="sqlSessionFactoryBeanName" value="sqlSessionFactory" />
        <!--指定包名，包名是dao接口所在的包名。
            MapperScannerConfigurer会扫描这个包中的所有接口，把每个接口都执行
            一次getMapper()方法，得到每个接口的dao对象。
            创建好的dao对象放入到spring的容器中的。 dao对象的默认名称是 接口名首字母小写
        -->
        <property name="basePackage" value="org.example.dao"/>
    </bean>
```

###### 8.5 向 Service 注入接口名

​	向 Service 注入 Mapper 代理对象时需要注意，由于通过 Mapper 扫描配置器 MapperScannerConfigurer 生成的 Mapper 代理对象没有名称，所以在向 Service 注入 Mapper 代理时，无法通过名称注入。但可通过接口的简单类名注入，因为生成的是这个 Dao 接口的对象。

```xml
	<!--声明service-->
    <bean id="studentService" class="org.example.service.impl.StudentServiceImpl">
        <property name="studentDao" ref="studentDao" />
    </bean>
```

##### 9 Spring 配置文件全部配置

```xml
<!--src/main/resources/applicationcontext.xml-->
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:context="http://www.springframework.org/schema/context"
       xsi:schemaLocation="http://www.springframework.org/schema/beans
       http://www.springframework.org/schema/beans/spring-beans.xsd 
       http://www.springframework.org/schema/context 
       https://www.springframework.org/schema/context/spring-context.xsd">

    <!--
       把数据库的配置信息，写在一个独立的文件，编译修改数据库的配置内容
       spring知道jdbc.properties文件的位置
    -->
    <context:property-placeholder location="classpath:jdbc.properties" />

    <!--声明数据源DataSource,作用是连接数据库-->
    <bean id="myDataSource" class="com.alibaba.druid.pool.DruidDataSource"
          init-method="init" destroy-method="close">
        <!--set注入给DuridDataSource提供连接数据库的信息-->
        <property name="url" value="${jdbc.url}" />
        <property name="username" value="${jdbc.username}" />
        <property name="password" value="${jdbc.password}" />
        <property name="maxActive" value="${jdbc.maxActive}" /> <!--最大连接数-->
     </bean>

     <!--声明的是mybatis中提供的SqlSessionFactoryBean类，这个类内部创建SqlSessionFactory的
         SqlSessionFactory  sqlSessionFactory = new ..
     -->
    <bean id="sqlSessionFactory" class="org.mybatis.spring.SqlSessionFactoryBean">
        <!--set注入，把数据库连接池付给了dataSource属性-->
        <property name="dataSource" ref="myDataSource" />
        <!--
           mybatis主配置文件的位置
           configLocation属性是Resource类型，读取配置文件
           它的赋值，使用value，指定文件的路径，使用 classpath:表示文件的位置
        -->
        <property name="configLocation" value="classpath:mybatis_config.xml" />
    </bean>

    <!--创建dao对象，使用SqlSession的getMapper(StudentDao.class)
        MapperScannerConfigurer:在内部调用getMapper()生成每个dao接口的代理对象
    -->
    <bean class="org.mybatis.spring.mapper.MapperScannerConfigurer" >
        <!--指定SqlSessionFactory对象的id-->
        <property name="sqlSessionFactoryBeanName" value="sqlSessionFactory" />
        <!--指定包名，包名是dao接口所在的包名。
            MapperScannerConfigurer会扫描这个包中的所有接口，把每个接口都执行
            一次getMapper()方法，得到每个接口的dao对象。
            创建好的dao对象放入到spring的容器中的。 dao对象的默认名称是 接口名首字母小写
        -->
        <property name="basePackage" value="org.example.dao"/>
    </bean>

    <!--声明service-->
    <bean id="studentService" class="org.example.service.impl.StudentServiceImpl">
        <property name="studentDao" ref="studentDao" />
    </bean>
</beans>
```

##### 10 测试

```java
package org.example;

import org.example.dao.StudentDao;
import org.example.domain.Student;
import org.example.service.StudentService;
import org.junit.Test;
import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;

import java.util.List;

public class MyTest01 {
    @Test
    public void testInsert(){
        String config = "applicationcontext.xml";
        ApplicationContext ctx = new ClassPathXmlApplicationContext(config);
        StudentService service = (StudentService) ctx.getBean("studentService");
        Student student = new Student(1004, "王五", "ww@gmail.com", 25);
        int nums = service.addStudent(student);
        System.out.println("nums = " + nums);
    }

    @Test
    public void testSelect(){
        String config = "applicationcontext.xml";
        ApplicationContext ctx = new ClassPathXmlApplicationContext(config);
        StudentService service = (StudentService) ctx.getBean("studentService");
        List<Student> students = service.queryStudents();
        students.forEach(s -> System.out.println("student = " + s));
    }
}

```



### 五、Spring 事务

```
spring的事务处理
回答问题
1.什么是事务
  讲mysql的时候，提出了事务。事务是指一组sql语句的集合，集合中有多条sql语句
  可能是insert，update，select，delete，我们希望这些多个sql语句都能成功，
  或者都失败，这些sql语句的执行是一致的，作为一个整体执行。

2.在什么时候想到使用事务
  当我的操作，涉及得到多个表，或者是多个sql语句的insert，update，delete。需要保证
  这些语句都是成功才能完成我的功能，或者都失败，保证操作是符合要求的。

  在java代码中写程序，控制事务，此时事务应该放在那里呢？ 
     service类的业务方法上，因为业务方法会调用多个dao方法，执行多个sql语句

3.通常使用JDBC访问数据库， 还是mybatis访问数据库怎么处理事务
    jdbc访问数据库，处理事务  Connection conn ; conn.commit(); conn.rollback();
	mybatis访问数据库，处理事务， SqlSession.commit();  SqlSession.rollback();
	hibernate访问数据库，处理事务， Session.commit(); Session.rollback();

4. 3问题中事务的处理方式，有什么不足
  1) 不同的数据库访问技术，处理事务的对象，方法不同，
     需要了解不同数据库访问技术使用事务的原理
  2) 掌握多种数据库中事务的处理逻辑。什么时候提交事务，什么时候回滚事务
  3) 处理事务的多种方法。
  总结：就是多种数据库的访问技术，有不同的事务处理的机制，对象，方法。

5.怎么解决不足
  spring提供一种处理事务的统一模型， 能使用统一步骤，方式完成多种不同数据库访问技术的事务处理。
  使用spring的事务处理机制，可以完成mybatis访问数据库的事务处理
  使用spring的事务处理机制，可以完成hibernate访问数据库的事务处理。

6.处理事务，需要怎么做，做什么
  spring处理事务的模型，使用的步骤都是固定的。把事务使用的信息提供给spring就可以了
  1）事务内部提交，回滚事务，使用的事务管理器对象，代替你完成commit，rollback
     事务管理器是一个接口和他的众多实现类。
	  接口：PlatformTransactionManager，定义了事务重要方法 commit，rollback
	  实现类：spring把每一种数据库访问技术对应的事务处理类都创建好了。
	         mybatis访问数据库---spring创建好的是 DataSourceTransactionManager
			hibernate访问数据库----spring创建的是 HibernateTransactionManager

      怎么使用：你需要告诉spring 你用是那种数据库的访问技术，怎么告诉spring呢？
	  声明数据库访问技术对于的事务管理器实现类，在spring的配置文件中使用<bean>声明就可以了
	  例如，你要使用mybatis访问数据库，你应该在xml配置文件中
	  <bean id=“xxx" class="...DataSourceTransactionManager"> 

  2）你的业务方法需要什么样的事务，说明需要事务的类型。
     说明方法需要的事务：
	    1. 事务的隔离级别：有4个值。
		DEFAULT：采用 DB 默认的事务隔离级别。MySql 的默认为 REPEATABLE_READ； Oracle默认为 READ_COMMITTED。
		➢ READ_UNCOMMITTED：读未提交。未解决任何并发问题。
		➢ READ_COMMITTED：读已提交。解决脏读，存在不可重复读与幻读。
		➢ REPEATABLE_READ：可重复读。解决脏读、不可重复读，存在幻读
		➢ SERIALIZABLE：串行化。不存在并发问题。

        2. 事务的超时时间： 表示一个方法最长的执行时间，如果方法执行时超过了时间，事务就回滚。
		  单位是秒，整数值，默认是-1. 

	    3. 事务的传播行为 ： 控制业务方法是不是有事务的， 是什么样的事务的。
		    7个传播行为，表示你的业务方法调用时，事务在方法之间是如果使用的。

			PROPAGATION_REQUIRED
			PROPAGATION_REQUIRES_NEW
			PROPAGATION_SUPPORTS
			以上三个需要掌握的

			PROPAGATION_MANDATORY
			PROPAGATION_NESTED
			PROPAGATION_NEVER
			PROPAGATION_NOT_SUPPORTED

  3）事务提交事务，回滚事务的时机
        1.当你的业务方法，执行成功，没有异常抛出，当方法执行完毕，spring在方法执行后提交事务。事务管理器commit
        2.当你的业务方法抛出运行时异常或ERROR，spring执行回滚，调用事务管理器的rollback
	   运行时异常的定义：RuntimeException和他的子类都是运行时异常，例如NullPointException, NumberFormatException
        3.当你的业务方法抛出非运行时异常，主要是受查异常时，提交事务
		受查异常：在你写代码中，必须处理的异常。例如IOException, SQLException

总结spring的事务
  1.管理事务的是 事务管理和他的实现类
  2.spring的事务是一个统一模型
     1）指定要使用的事务管理器实现类，使用<bean>
	 2）指定哪些类，哪些方法需要加入事务的功能
	 3）指定方法需要的隔离级别，传播行为，超时

	 你需要告诉spring，你的项目中类信息，方法的名称，方法的事务传播行为。
```

##### 1 Spring 的事务管理

事务原本是数据库中的概念，在 Dao 层。但一般情况下，需要将事务提升到业务层， 即 Service 层。这样做是为了能够使用事务的特性来管理具体的业务。 

在 Spring 中通常可以通过以下两种方式来实现对事务的管理： 

1. 使用 Spring 的事务注解管理事务 
2. 使用 AspectJ 的 AOP 配置管理事务



##### 2 Spring 事务管理 API

###### 2.1 事务管理器接口

事务管理器是 PlatformTransactionManager 接口对象。其主要用于完成事务的提交、回滚，及获取事务的状态信息。

![image-20220224203935387](https://cdn.jsdelivr.net/gh/xukang0509/picgo_bed/img/202203022113877.png)

1. 常用的两个实现类

   PlatformTransactionManager 接口有两个常用的实现类：

   - DataSourceTransactionManager：使用 JDBC 或 MyBatis 进行数据库操作时使用。
   - HibernateTransactionManager：使用 Hibernate 进行持久化数据时使用。

2.  Spring 的回滚方式

   Spring 事务的默认回滚方式是：**发生运行时异常和 error 时回滚**，**发生检查时(编译)异常时提交**。不过，对于受查异常，程序员也可以手工设置其回滚方式。

3. 回顾错误与异常

   - Throwable 类是 Java 语言中所有错误或异常的超类。只有当对象是此类(或其子类之一)的实例时，才能通过 Java 虚拟机或者 Java 的 throw 语句抛出。
   - Error 是程序在运行过程中出现的无法处理的错误，比如 OutOfMemoryError、ThreadDeath、NoSuchMethodError 等。当这些错误发生时，程序是无法处理（捕获或抛出）的，JVM 一般会终止线程。
   - 程序在编译和运行时出现的另一类错误称之为异常，它是 JVM 通知程序员的一种方式。通过这种方式，让程序员知道已经或可能出现错误，要求程序员对其进行处理。
   - 运行时异常，是 RuntimeException 类或其子类，即只有在运行时才出现的异常。如，NullPointerException、ArrayIndexOutOfBoundsException、IllegalArgumentException 等均属于运行时异常。这些异常由 JVM 抛出，在编译时不要求必须处理（捕获或抛出）。但，只要代码编写足够仔细，程序足够健壮，运行时异常是可以避免的。
   - 受查异常，也叫编译时异常，即在代码编写时要求必须捕获或抛出的异常，若不处理，则无法通过编译。如 SQLException，ClassNotFoundException，IOException 等都属于受查异常。
   - RuntimeException 及其子类以外的异常，均属于受查异常。当然，用户自定义的 Exception 的子类，即用户自定义的异常也属受查异常。程序员在定义异常时，只要未明确声明定义的为 RuntimeException 的子类，那么定义的就是受查异常。



###### 2.2 事务定义接口

事务定义接口 TransactionDefinition 中定义了事务描述相关的三类常量：事务隔离级别、事务传播行为、事务默认超时时限，及对它们的操作。

![image-20220224204652831](https://cdn.jsdelivr.net/gh/xukang0509/picgo_bed/img/202203022113137.png)

1. 定义了四个事务隔离级别常量

   这些常量均是以 ISOLATION_开头。即形如 ISOLATION_XXX。

   - DEFAULT：采用 DB 默认的事务隔离级别。MySql 的默认为 REPEATABLE_READ； Oracle 默认为 READ_COMMITTED。
   - READ_UNCOMMITTED：读未提交。未解决任何并发问题。 
   - READ_COMMITTED：读已提交。解决脏读，存在不可重复读与幻读。  
   - REPEATABLE_READ：可重复读。解决脏读、不可重复读，存在幻读 
   - SERIALIZABLE：串行化。不存在并发问题。

2. 定义了七个事务传播行为常量

   所谓事务传播行为是指，处于不同事务中的方法在相互调用时，执行期间事务的维护情况。如，A 事务中的方法 doSome()调用 B 事务中的方法 doOther()，在调用执行期间事务的维护情况，就称为事务传播行为。

   事务传播行为是加在方法上的。 事务传播行为常量都是以 PROPAGATION_ 开头，形如 PROPAGATION_XXX。

   **PROPAGATION_REQUIRED** 

   **PROPAGATION_REQUIRES_NEW** 

   **PROPAGATION_SUPPORTS** 

   

   PROPAGATION_MANDATORY  

   PROPAGATION_NESTED 

   PROPAGATION_NEVER 

   PROPAGATION_NOT_SUPPORTED

    

   -  PROPAGATION_REQUIRED：

     指定的方法必须在事务内执行。若当前存在事务，就加入到当前事务中；若当前没有事务，则创建一个新事务。这种传播行为是最常见的选择，也是 Spring 默认的事务传播行为。

     如该传播行为加在 doOther()方法上。若 doSome()方法在调用 doOther() 方法时就是在事务内运行的，则 doOther()方法的执行也加入到该事务内执行。若 doSome()方法在调用 doOther() 方法时没有在事务内执行，则 doOther() 方法会创建一个事务，并在其中执行。

   - PROPAGATION_SUPPORTS：

     指定的方法支持当前事务，但若当前没有事务，也可以以非事务方式执行。

   - PROPAGATION_REQUIRES_NEW：

     总是新建一个事务，若当前存在事务，就将当前事务挂起，直到新事务执行完毕。

3. 定义了默认事务超时时限

   常量 TIMEOUT_DEFAULT 定义了事务底层默认的超时时限，sql 语句的执行时长。

   注意，事务的超时时限起作用的条件比较多，且超时的时间计算点较复杂。所以，该值一般就使用默认值即可。



##### 3 程序举例环境搭建

```
ch08-spring-trans: 做事务的环境项目
实现步骤：
1.新建maven项目
2.加入maven的依赖
  1）spring依赖
  2）mybatis依赖
  3）mysql驱动
  4）spring的事务的依赖
  5）mybatis和spring集成的依赖： mybatis官方体用的，用来在spring项目中创建mybatis
     的SqlSesissonFactory，dao对象的
3.创建实体类
  Sale, Goods
4.创建dao接口和mapper文件
  SaleDao接口 ，GoodsDao接口
  SaleDao.xml , GoodsDao.xml
5.创建mybatis主配置文件
6.创建Service接口和实现类，属性是saleDao, goodsDao。
7.创建spring的配置文件：声明mybatis的对象交给spring创建
 1）数据源DataSource
 2）SqlSessionFactory
 3) Dao对象
 4）声明自定义的service

8.创建测试类，获取Service对象，通过service调用dao完成数据库的访问
```

###### 3.1 创建数据库表

创建两个数据库表 sale，goods 

sale 销售表

![image-20220226144734017](https://cdn.jsdelivr.net/gh/xukang0509/picgo_bed/img/202203022113974.png)



goods 商品表

![image-20220226144811722](https://cdn.jsdelivr.net/gh/xukang0509/picgo_bed/img/202203022113576.png)

goods 表数据

![image-20220226144838522](https://cdn.jsdelivr.net/gh/xukang0509/picgo_bed/img/202203022113475.png)



###### 3.2 maven 依赖 pom.xml

```xml
<?xml version="1.0" encoding="UTF-8"?>

<project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://maven.apache.org/POM/4.0.0
  http://maven.apache.org/xsd/maven-4.0.0.xsd">
  <modelVersion>4.0.0</modelVersion>

  <groupId>com.xukang</groupId>
  <artifactId>ch08-spring-trans</artifactId>
  <version>1.0-SNAPSHOT</version>

  <properties>
    <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
    <maven.compiler.source>1.8</maven.compiler.source>
    <maven.compiler.target>1.8</maven.compiler.target>
  </properties>

  <dependencies>
    <!--单元测试-->
    <dependency>
      <groupId>junit</groupId>
      <artifactId>junit</artifactId>
      <version>4.11</version>
      <scope>test</scope>
    </dependency>
    <!--Spring核心IOC-->
    <dependency>
      <groupId>org.springframework</groupId>
      <artifactId>spring-context</artifactId>
      <version>5.2.5.RELEASE</version>
    </dependency>
    <!--做Spring事务用到的-->
    <dependency>
      <groupId>org.springframework</groupId>
      <artifactId>spring-tx</artifactId>
      <version>5.2.5.RELEASE</version>
    </dependency>
    <dependency>
      <groupId>org.springframework</groupId>
      <artifactId>spring-jdbc</artifactId>
      <version>5.2.5.RELEASE</version>
    </dependency>
    <!--mybatis依赖-->
    <dependency>
      <groupId>org.mybatis</groupId>
      <artifactId>mybatis</artifactId>
      <version>3.5.1</version>
    </dependency>
    <!--mybatis和spring集成的依赖-->
    <dependency>
      <groupId>org.mybatis</groupId>
      <artifactId>mybatis-spring</artifactId>
      <version>1.3.1</version>
    </dependency>
    <!--mysql驱动-->
    <dependency>
      <groupId>mysql</groupId>
      <artifactId>mysql-connector-java</artifactId>
      <version>5.1.9</version>
    </dependency>
    <!--阿里公司的数据库连接池-->
    <dependency>
      <groupId>com.alibaba</groupId>
      <artifactId>druid</artifactId>
      <version>1.1.12</version>
    </dependency>
  </dependencies>

  <build>
    <resources>
      <!--目的是把src/main/java目录中的xml文件包含到输出结果中，输出到classes目录中-->
      <resource>
        <directory>src/main/java</directory><!--所在的目录-->
        <includes><!--包括目录下的.properties,.xml 文件都会扫描到-->
          <include>**/*.properties</include>
          <include>**/*.xml</include>
        </includes>
        <filtering>false</filtering>
      </resource>
    </resources>
    <plugins>
      <!--指定JDK的版本-->
      <plugin>
        <artifactId>maven-compiler-plugin</artifactId>
        <version>3.1</version>
        <configuration>
          <source>1.8</source>
          <target>1.8</target>
        </configuration>
      </plugin>
    </plugins>
  </build>
</project>
```



###### 3.3 创建实体类

```java
package com.xukang.entity;
public class Sale {
    private Integer id;
    private Integer gid;
    private Integer nums;
    //无参构造 有参构造
    //get set toString
}
```

```java
package com.xukang.entity;
public class Goods {
    private Integer id;
    private String name;
    private Integer amount;
    private Float price;
    //无参构造 有参构造
    //get set toString
}
```



###### 3.4 定义dao接口

```java
package com.xukang.dao;
import com.xukang.entity.Sale;
public interface SaleDao {
    //增加销售记录
    int insertSale(Sale sale);
}
```

```java
package com.xukang.dao;
import com.xukang.entity.Goods;
public interface GoodsDao {
    //更新库存
    //goods表示本次用户购买的商品信息，id，购买的数量
    int updateGoods(Goods goods);
    
    //查询商品的信息
    Goods selectGoods(Integer gid);
}
```



###### 3.5 定义 dao 接口对应的 sql 映射文件

```xml
<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE mapper
        PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
        "http://mybatis.org/dtd/mybatis-3-mapper.dtd">
<mapper namespace="com.xukang.dao.SaleDao">
    <insert id="insertSale">
        insert into sale(gid, nums) values(#{gid}, #{nums})
    </insert>
</mapper>
```

```xml
<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE mapper
        PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
        "http://mybatis.org/dtd/mybatis-3-mapper.dtd">
<mapper namespace="com.xukang.dao.GoodsDao">
    <select id="selectGoods" resultType="com.xukang.entity.Goods">
        select id, name, amount, price from goods where id = #{gid}
    </select>

    <update id="updateGoods">
        update set amount = amount - #{amount} where id = #{id}
    </update>
</mapper>
```



###### 3.6 定义异常类

```java
package com.xukang.excep;
//自定义的运行时异常
public class NotEnoughException extends RuntimeException{
    public NotEnoughException() {
    }

    public NotEnoughException(String message) {
        super(message);
    }
}
```



###### 3.7 定义 Service 接口

```java
package com.xukang.service;
public interface BuyGoodsService {
    /**
     * 购买商品的方法
     * @param goodsId 购买商品的编号
     * @param nums 购买的数量
     */
    void buy(Integer goodsId, Integer nums);
}
```



###### 3.8 定义 service 的实现类

```java
package com.xukang.service.impl;

import com.xukang.dao.GoodsDao;
import com.xukang.dao.SaleDao;
import com.xukang.entity.Goods;
import com.xukang.entity.Sale;
import com.xukang.excep.NotEnoughException;
import com.xukang.service.BuyGoodsService;

public class BuyGoodsServiceImpl implements BuyGoodsService {
    private SaleDao saleDao;
    private GoodsDao goodsDao;
    public void setSaleDao(SaleDao saleDao) {
        this.saleDao = saleDao;
    }
    public void setGoodsDao(GoodsDao goodsDao) {
        this.goodsDao = goodsDao;
    }

    @Override
    public void buy(Integer goodsId, Integer nums) {
        System.out.println("buy方法的开始");
        //记录销售信息，向sale表添加记录
        Sale sale = new Sale(null, goodsId, nums);
        int count = saleDao.insertSale(sale);
        System.out.println("sale表添加记录条数：" + count);

        //更新库存
        Goods goods = goodsDao.selectGoods(goodsId);
        if(goods == null){
            throw new NullPointerException("编号" + goodsId + "的商品不存在。");
        }else if(goods.getAmount() < nums){
            //商品库存不足
            throw new NotEnoughException("编号" + goodsId + "的商品库存不足。");
        }
        //修改库存了
        Goods buyGoods = new Goods(goodsId, null, nums, null);
        count = goodsDao.updateGoods(buyGoods);
        System.out.println("goods表更新数目条数：" + count);
        System.out.println("buy方法的完成");
    }
}
```



###### 3.9 修改 Spring 配置文件内容

```properties
#jdbc.properties
jdbc.url=jdbc:mysql://localhost:3306/springdb
jdbc.username=root
jdbc.password=111
jdbc.maxActive=20
```

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:context="http://www.springframework.org/schema/context"
       xsi:schemaLocation="http://www.springframework.org/schema/beans
       http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd">
    <!--
       把数据库的配置信息，写在一个独立的文件，编译修改数据库的配置内容
       spring知道jdbc.properties文件的位置
    -->
    <context:property-placeholder location="classpath:jdbc.properties" />

    <!--声明数据源DataSource,作用是连接数据库-->
    <bean id="myDataSource" class="com.alibaba.druid.pool.DruidDataSource"
          init-method="init" destroy-method="close">
        <!--set注入给DuridDataSource提供连接数据库的信息-->
        <property name="url" value="${jdbc.url}" />
        <property name="username" value="${jdbc.username}" />
        <property name="password" value="${jdbc.password}" />
        <property name="maxActive" value="${jdbc.maxActive}" /> <!--最大连接数-->
     </bean>

     <!--声明的是mybatis中提供的SqlSessionFactoryBean类，这个类内部创建SqlSessionFactory的
         SqlSessionFactory  sqlSessionFactory = new ..
     -->
    <bean id="sqlSessionFactory" class="org.mybatis.spring.SqlSessionFactoryBean">
        <!--set注入，把数据库连接池付给了dataSource属性-->
        <property name="dataSource" ref="myDataSource" />
        <!--
           mybatis主配置文件的位置
           configLocation属性是Resource类型，读取配置文件
           它的赋值，使用value，指定文件的路径，使用 classpath:表示文件的位置
        -->
        <property name="configLocation" value="classpath:mybatis_config.xml" />
    </bean>

    <!--创建dao对象，使用SqlSession的getMapper(StudentDao.class)
        MapperScannerConfigurer:在内部调用getMapper()生成每个dao接口的代理对象
    -->
    <bean class="org.mybatis.spring.mapper.MapperScannerConfigurer" >
        <!--指定SqlSessionFactory对象的id-->
        <property name="sqlSessionFactoryBeanName" value="sqlSessionFactory" />
        <!--指定包名，包名是dao接口所在的包名。
            MapperScannerConfigurer会扫描这个包中的所有接口，把每个接口都执行
            一次getMapper()方法，得到每个接口的dao对象。
            创建好的dao对象放入到spring的容器中的。 dao对象的默认名称是 接口名首字母小写
        -->
        <property name="basePackage" value="com.xukang.dao"/>
    </bean>

    <!--声明service-->
    <bean id="buyService" class="com.xukang.service.impl.BuyGoodsServiceImpl">
        <property name="goodsDao" ref="goodsDao" />
        <property name="saleDao" ref="saleDao" />
    </bean>
</beans>
```



###### 3.10 定义测试类

```java
public class MyTest {
    @Test
    public void test01(){
        String config = "applicationcontext.xml";
        ApplicationContext ctx = new ClassPathXmlApplicationContext(config);
        //从容器中获取service
        BuyGoodsService service = (BuyGoodsService) ctx.getBean("buyService");
        //调用方法
        service.buy(1001, 200);
    }
}
```



##### 4 使用 Spring 的事务注解管理事务

通过 @Transactional 注解方式，可将事务织入到相应 public 方法中，实现事务管理。

@Transactional 的所有可选属性如下所示：

- propagation：用于设置事务传播属性。该属性类型为 Propagation 枚举，默认值为 Propagation.REQUIRED
- isolation：用于设置事务的隔离级别。该属性类型为 Isolation 枚举，默认值为 Isolation.DEFAULT。
- readOnly：用于设置该方法对数据库的操作是否是只读的。该属性为 boolean，默认值为 false。
- timeout：用于设置本操作与数据库连接的超时时限。单位为秒，类型为 int，默认值为 -1，即没有时限。
- rollbackFor：指定需要回滚的异常类。类型为 Class[]，默认值为空数组。当然，若只有一个异常类时，可以不使用数组。
- rollbackForClassName：指定需要回滚的异常类类名。类型为 String[]，默认值为空数组。当然，若只有一个异常类时，可以不使用数组。
- noRollbackFor：指定不需要回滚的异常类。类型为 Class[]，默认值为空数组。当然，若只有一个异常类时，可以不使用数组。

需要注意的是，@Transactional 若用在方法上，只能用于 public 方法上。对于其他非 public 方法，如果加上了注解@Transactional，虽然 Spring 不会报错，但不会将指定事务织入到该方法中。因为 Spring 会忽略掉所有非 public 方法上的@Transaction 注解。 

若@Transaction 注解在类上，则表示该类上所有的方法均将在执行时织入事务。



实现注解的事务步骤：

1. 声明事务管理器对象

   ```xml
   	<!--使用Spring的事务管理-->
       <!--1.声明事务管理器-->
       <bean id="transactionManager" 	
             class="org.springframework.jdbc.datasource.DataSourceTransactionManager" >
           <!--连接的数据库，指定数据源-->
           <property name="dataSource" ref="myDataSource" />
       </bean>
   ```

2. 开启事务注解驱动

   ```
   告诉spring框架，我要使用注解的方式管理事务。
   spring使用aop机制，创建@Transactional所在的类代理对象，给方法加入事务的功能。
   spring给业务方法加入事务：
   在你的业务方法执行之前，先开启事务，在业务方法之后提交或回滚事务，使用aop的环绕通知
   @Around("你要增加的事务功能的业务方法名称")
   Object myAround(){
       开启事务，spring给你开启
   	try{
   		buy(1001,10);
   		spring的事务管理器.commit();
   	}catch(Exception e){
            spring的事务管理器.rollback();
   	}
   }
   ```

   ```xml
   <!--2.开启事务注解驱动，告诉Spring使用注解管理事务，创建代理对象
           transactionManager: 事务管理器对象的id
   -->
   <tx:annotation-driven transaction-manager="transactionManager" />
   ```

3. 业务层 public 方法加入事务属性

   ```java
   public class BuyGoodsServiceImpl implements BuyGoodsService {
       private SaleDao saleDao;
       private GoodsDao goodsDao;
       public void setSaleDao(SaleDao saleDao) {
           this.saleDao = saleDao;
       }
       public void setGoodsDao(GoodsDao goodsDao) {
           this.goodsDao = goodsDao;
       }
   
       /*
        * rollbackFor:表示发生指定的异常一定回滚
        *   处理逻辑是：
        *     1) spring框架会首先检查方法抛出的异常是不是在rollbackFor的属性值中
        *         如果异常在rollbackFor列表中，不管是什么类型的异常，一定回滚。
        *     2) 如果你的抛出的异常不在rollbackFor列表中，spring会判断异常是不是RuntimeException,
        *         如果是一定回滚。
        */
       /*@Transactional(
               propagation = Propagation.REQUIRED,
               isolation = Isolation.DEFAULT,
               readOnly = false,
               rollbackFor = {
                       NullPointerException.class,
                       NotEnoughException.class
               }
       )*/
       
       //使用的是事务控制的默认值， 默认的传播行为是REQUIRED，默认的隔离级别DEFAULT
       //默认抛出运行时异常，回滚事务。
       @Transactional
       @Override
       public void buy(Integer goodsId, Integer nums) {
           System.out.println("buy方法的开始");
           //记录销售信息，向sale表添加记录
           Sale sale = new Sale(null, goodsId, nums);
           int count = saleDao.insertSale(sale);
           System.out.println("sale表添加记录条数：" + count);
   
           //更新库存
           Goods goods = goodsDao.selectGoods(goodsId);
           if(goods == null){
               throw new NullPointerException("编号" + goodsId + "的商品不存在。");
           }else if(goods.getAmount() < nums){
               //商品库存不足
               throw new NotEnoughException("编号" + goodsId + "的商品库存不足。");
           }
           //修改库存了
           Goods buyGoods = new Goods(goodsId, null, nums, null);
           count = goodsDao.updateGoods(buyGoods);
           System.out.println("goods表更新数目条数：" + count);
           System.out.println("buy方法的完成");
       }
   }
   ```

   

##### 5 使用 AspectJ 的 AOP 配置管理事务

```
适合大型项目，有很多的类，方法，需要大量的配置事务，使用aspectj框架功能，在spring配置文件中
声明类，方法需要的事务。这种方式业务方法和事务配置完全分离。
```

​	使用 XML 配置事务代理的方式的不足是，每个目标类都需要配置事务代理。当目标类较多，配置文件会变得非常臃肿。 

​	使用 XML 配置顾问方式可以自动为每个符合切入点表达式的类生成事务代理。其用法很简单，只需将前面代码中关于事务代理的配置删除，再替换为如下内容即可。

1. maven 依赖 pom.xml

   新加入 aspectj 的依赖坐标

   ```xml
   <dependency>
   	<groupId>org.springframework</groupId>
   	<artifactId>spring-aspects</artifactId>
   	<version>5.2.5.RELEASE</version>
   </dependency>
   ```

2. 在容器中添加事务管理器

   ```xml
   	<!--声明事务管理器-->
       <bean id="transactionManager" 	
             class="org.springframework.jdbc.datasource.DataSourceTransactionManager" >
           <!--连接的数据库，指定数据源-->
           <property name="dataSource" ref="myDataSource" />
       </bean>
   ```

3. 配置事务通知

   为事务通知设置相关属性。用于指定要将事务以什么方式织入给哪些方法。 

   例如，应用到 buy 方法上的事务要求是必须的，且当 buy 方法发生异常后要回滚业务。

   ```xml
   <!--声明业务方法它的事务属性（隔离级别, 传播行为, 超时时间）
           id: 自定义名称，表示 <tx:advice> 和 </tx:advice> 之间的配置内容的
           transaction-manager:事务管理器对象的id
       -->
       <tx:advice id="myAdvice" transaction-manager="transactionManager" >
           <!--tx:attributes:表示配置事务的属性-->
           <tx:attributes>
               <!--tx:method:给具体的方法配置事务属性，method可以有多个，分别给不同的方法设置事务属性
                   name: 方法名称，1）完整的方法名称，不带有包和类
                                 2）方法可以使用通配符，*表示任意字符
                   propagation: 传播行为，枚举型
                   isolation: 隔离级别
                   rollback-for: 你指定的异常类名，全限定名称，发生异常一定回滚
               -->
               <tx:method name="buy" propagation="REQUIRED" isolation="DEFAULT"
                          rollback-for="java.lang.NullPointerException,com.xukang.excep.NotEnoughException"/>
   
               <!--使用通配符，指定很多的方法-->
               <tx:method name="add*" propagation="REQUIRES_NEW" />
               <!--指定修改方法-->
               <tx:method name="modify*" />
               <!--删除方法-->
               <tx:method name="remove*" />
               <!--查询方法，query，search，find-->
               <tx:method name="*" propagation="SUPPORTS" read-only="true" />
           </tx:attributes>
       </tx:advice>
   ```

4. 配置增强器

   指定将配置好的事务通知，织入给谁。

   ```xml
   	<!--配置aop-->
       <aop:config>
           <!--
               配置切入点表达式：指定哪些包中类，要使用事务
               id: 切入点表达式的名称，唯一值
               expression: 切入点表达式，指定哪些类要使用事务，aspectj会创建代理对象
           -->
           <aop:pointcut id="servicePt" expression="execution(* *..service..*.*(..))"/>
   
           <!--配置增强器：关联 advice 和 pointcut
               advice-ref:通知，上面tx:advice 哪里的配置
               pointcut-ref:切入点表达式的id
           -->
           <aop:advisor advice-ref="myAdvice" pointcut-ref="servicePt" />
       </aop:config>
   ```

5. 修改测试类

   ```java
   public class MyTest {
       @Test
       public void test01(){
           String config = "applicationcontext.xml";
           ApplicationContext ctx = new ClassPathXmlApplicationContext(config);
           //从容器中获取service
           BuyGoodsService service = (BuyGoodsService) ctx.getBean("buyService");
           System.out.println("service是代理：" + service.getClass().getName());
           //调用方法
           service.buy(1001, 10);
       }
   }
   ```



### 六、Spring 与 Web

```
web项目中怎么使用容器对象。
1.做的是javase项目有main方法的，执行代码是执行main方法的，
  在main里面创建的容器对象 
  ApplicationContext ctx = new ClassPathXmlApplicationContext("applicationContext.xml");
2.web项目是在tomcat服务器上运行的。tomcat一起动，项目一直运行的。
```

在 Web 项目中使用 Spring 框架，首先要解决在 web 层（这里指 Servlet）中获取到 Spring 容器的问题。只要在 web 层获取到了 Spring 容器，便可从容器中获取到 Service 对象。

##### 1 Web 项目使用 Spring

```
在web项目中使用spring，完成学生注册功能
实现步骤：
1.创建maven，web项目
2.加入依赖
  拷贝ch7-spring-mybatis中依赖
  jsp，servlet依赖
3.拷贝ch7-spring-mybatis的代码和配置文件
4.创建一个jsp发起请求，有参数id,name,email,age
5.创建Servlet，接收请求参数，调用 Service，调用dao完成注册
6.创建一个jsp作为显示结果页面
```

1. 新建一个 Maven Project

   类型 maven-archetype-webapp

2. 复制代码，配置文件，jar

   将 spring-mybatis 项目中以下内容复制到当前项目中：

   - Service 层、Dao 层全部代码 
   - 配置文件 applicationContext.xml 及 jdbc.properties，mybatis.xml 
   - pom.xml 
   - 加入 servlet，jsp 依赖

   ```xml
   	<!-- servlet依赖 -->
       <dependency>
         <groupId>javax.servlet</groupId>
         <artifactId>javax.servlet-api</artifactId>
         <version>3.1.0</version>
         <scope>provided</scope>
       </dependency>
       <!-- jsp依赖 -->
       <dependency>
         <groupId>javax.servlet.jsp</groupId>
         <artifactId>jsp-api</artifactId>
         <version>2.2.1-b03</version>
         <scope>provided</scope>
       </dependency>
   ```

3. 定义 index 页面

   ```jsp
   <%@ page contentType="text/html;charset=UTF-8" language="java" %>
   <html>
   <head>
       <title>Title</title>
   </head>
   <body>
       <p>注册学生</p>
       <form action="reg" method="post" >
           <table>
               <tr>
                   <td>id:</td>
                   <td><input type="text" name="id"></td>
               </tr>
               <tr>
                   <td>姓名:</td>
                   <td><input type="text" name="name"></td>
               </tr>
               <tr>
                   <td>email:</td>
                   <td><input type="text" name="email"></td>
               </tr>
               <tr>
                   <td>年龄:</td>
                   <td><input type="text" name="age"></td>
               </tr>
               <tr>
                   <td></td>
                   <td><input type="submit" value="注册学生"></td>
               </tr>
           </table>
       </form>
   </body>
   </html>
   ```

4. 定义 RegisterServlet（重点代码）

   ```java
   package org.example.controller;
   
   import org.example.domain.Student;
   import org.example.service.StudentService;
   import org.springframework.context.ApplicationContext;
   import org.springframework.context.support.ClassPathXmlApplicationContext;
   
   import javax.servlet.*;
   import javax.servlet.http.*;
   import java.io.IOException;
   
   public class RegisterServlet extends HttpServlet {
       @Override
       protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
           request.setCharacterEncoding("utf-8");
           String strId = request.getParameter("id");
           String strName = request.getParameter("name");
           String strEmail = request.getParameter("email");
           String strAge = request.getParameter("age");
           //创建spring的容器对象
           String config = "applicationcontext.xml";
           ApplicationContext ctx = new ClassPathXmlApplicationContext(config);
           System.out.println("容器信息===" + ctx);
           //获取service
           StudentService studentService = (StudentService) ctx.getBean("studentService");
           Student student = new Student();
           student.setAge(Integer.valueOf(strId));
           student.setName(strName);
           student.setEmail(strEmail);
           student.setAge(Integer.valueOf(strAge));
           int count = studentService.addStudent(student);
   
           //给一个结果页面
           if(count == 1){
               request.getRequestDispatcher("/success.jsp").forward(request, response);
           }else{
               request.getRequestDispatcher("/fail.jsp").forward(request, response);
           }
       }
   }
   ```

5. 定义 success / fail 页面

   ```jsp
   <%@ page contentType="text/html;charset=UTF-8" language="java" %>
   <html>
   <head>
       <title>Title</title>
   </head>
   <body>
   result.jsp 注册成功
   </body>
   </html>
   ```

   ```jsp
   <%@ page contentType="text/html;charset=UTF-8" language="java" %>
   <html>
   <head>
       <title>Title</title>
   </head>
   <body>
   fail.jsp 注册失败
   </body>
   </html>
   ```

6. web.xml 注册 Servlet

   ```xml
   <?xml version="1.0" encoding="UTF-8"?>
   <web-app xmlns="http://xmlns.jcp.org/xml/ns/javaee"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd"
            version="4.0">
   
       <servlet>
           <servlet-name>RegisterServlet</servlet-name>
           <servlet-class>org.example.controller.RegisterServlet</servlet-class>
       </servlet>
       <!--别名-->
       <servlet-mapping>
           <servlet-name>RegisterServlet</servlet-name>
           <url-pattern>/reg</url-pattern>
       </servlet-mapping>
   </web-app>
   ```

7. 运行结果分析

   当表单提交，跳转到 success.jsp 后，多刷新几次页面，查看后台输出，发现每刷新一次页面，就 new 出一个新的 Spring 容器。即，每提交一次请求，就会创建一个新的 Spring 容 器。对于一个应用来说，只需要一个 Spring 容器即可。所以，将 Spring 容器的创建语句放 在 Servlet 的 doGet()或 doPost()方法中是有问题的。

   此时，可以考虑，将 Spring 容器的创建放在 Servlet 进行初始化时进行，即执行 init() 方法时执行。并且，Servlet 还是单例多线程的，即一个业务只有一个 Servlet 实例，所有执行 该业务的用户执行的都是这一个 Servlet 实例。这样，Spring 容器就具有了唯一性了。

   但是，Servlet 是一个业务一个 Servlet 实例，即 LoginServlet 只有一个，但还会有 StudentServlet、TeacherServlet 等。每个业务都会有一个 Servlet，都会执行自己的 init()方法， 也就都会创建一个 Spring 容器了。这样一来，Spring 容器就又不唯一了。



##### 2 使用 Spring 的监听器 ContextLoaderListener

```
需求：
web项目中容器对象只需要创建一次，把容器对象放入到全局作用域ServletContext中。
怎么实现：
   使用监听器 当全局作用域对象被创建时 创建容器 存入ServletContext
	监听器作用：
	1）创建容器对象，执行 ApplicationContext ctx = new ClassPathXmlApplicationContext("applicationContext.xml");
	2）把容器对象放入到ServletContext， ServletContext.setAttribute(key,ctx)
	监听器可以自己创建，也可以使用框架中提供好的ContextLoaderListener

	 private WebApplicationContext context;
	 public interface WebApplicationContext extends ApplicationContext

	 ApplicationContext:javase项目中使用的容器对象
     WebApplicationContext：web项目中的使用的容器对象

    把创建的容器对象，放入到全局作用域
	 key： WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE
	       WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE
	 value：this.context

	 servletContext.setAttribute(WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE, this.context);
```

对于 Web 应用来说，ServletContext 对象是唯一的，一个 Web 应用，只有一个 ServletContext 对象，该对象是在 Web 应用装载时初始化的。若将 Spring 容器的创建时机， 放在 ServletContext 初始化时，就可以保证 Spring 容器的创建只会执行一次，也就保证了 Spring 容器在整个应用中的唯一性。

当 Spring 容器创建好后，在整个应用的生命周期过程中，Spring 容器应该是随时可以被访问的。即，Spring 容器应具有全局性。而放入 ServletContext 对象的属性，就具有应用的全局性。所以，将创建好的 Spring 容器，以属性的形式放入到 ServletContext 的空间中，就 保证了 Spring 容器的全局性。

上述的这些工作，已经被封装在了如下的 Spring 的 Jar 包的相关 API 中：spring-web-5.2.5.RELEASE

1. maven 依赖 pom.xml

   ```xml
   <dependency>
   	<groupId>org.springframework</groupId>
   	<artifactId>spring-web</artifactId>
   	<version>5.2.5.RELEASE</version>
   </dependency>
   ```

2. 注册监听器 ContextLoaderListener

   若要在 ServletContext 初始化时创建 Spring 容 器 ，就需要使用监听器接口 ServletContextListener 对 ServletContext 进行监听。在 web.xml 中注册该监听器。

   ```xml
   	<listener>
           <listener-class>org.springframework.web.context.ContextLoaderListener</listener-class>
       </listener>
   ```

   Spring 为该监听器接口定义了一个实现类 ContextLoaderListener，完成了两个很重要的 工作：创建容器对象，并将容器对象放入到了 ServletContext 的空间中。

   打开 ContextLoaderListener 的源码。看到一共四个方法，两个是构造方法，一个初始化方法，一个销毁方法。

   ![image-20220226184121788](https://cdn.jsdelivr.net/gh/xukang0509/picgo_bed/img/202203022113465.png)

   所以，在这四个方法中较重要的方法应该就是 contextInitialized()，context 初始化方法。

   跟踪 initWebApplicationContext()方法，可以看到，在其中创建了容器对象。

   ![image-20220226184301555](https://cdn.jsdelivr.net/gh/xukang0509/picgo_bed/img/202203022114506.png)

   并且，将创建好的容器对象放入到了 ServletContext 的空间中，key 为一个常量： WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE。

   ![image-20220226184340466](https://cdn.jsdelivr.net/gh/xukang0509/picgo_bed/img/202203022114250.png)

3. 指定 Spring 配置文件的位置 spring-param

   ContextLoaderListener 在对 Spring 容器进行创建时，需要加载 Spring 配置文件。其默认 的 Spring 配置文件位置与名称为：WEB-INF/applicationContext.xml。但，一般会将该配置文件放置于项目的 classpath 下，即 src 下，所以需要在 web.xml 中对 Spring 配置文件的位置及名称进行指定。

   ```xml
   	<context-param>
           <!-- contextConfigLocation:表示配置文件的路径  -->
           <param-name>contextConfigLocation</param-name>
           <!--自定义配置文件的路径-->
           <param-value>classpath:applicationcontext.xml</param-value>
       </context-param>
   ```

   从监听器 ContextLoaderListener 的父类 ContextLoader 的源码中可以看到其要读取的配置文件位置参数名称 contextConfigLocation。

   ![image-20220226184620651](https://cdn.jsdelivr.net/gh/xukang0509/picgo_bed/img/202203022114778.png)

4. 获取 Spring 容器对象

   - 直接从 ServletContext 中获取

     从对监听器 ContextLoaderListener 的源码分析可知，容器对象在 ServletContext 的中存 放的 key 为 WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE。所以，可 以直接通过 ServletContext 的 getAttribute()方法，按照指定的 key 将容器对象获取到。

     ```java
     	//获取ServletContext中的容器对象，创建好的容器对象，拿来就用
             String key = WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE;
             Object attr = getServletContext().getAttribute(key);
             if(attr != null){
                 ctx = (WebApplicationContext) attr;
             }
     ```

   - 通过 WebApplicationContextUtils 工具类获取

     工具类 WebApplicationContextUtils 有一个方法专门用于从 ServletContext 中获取 Spring 容器对象：getRequiredWebApplicationContext(ServletContext sc)

     ```java
     	//使用框架中的方法，获取容器对象
         ServletContext sc = getServletContext();
         WebApplicationContext ctx = WebApplicationContextUtils.getRequiredWebApplicationContext(sc);
     ```

     以上两种方式，无论使用哪种获取容器对象，刷新 success 页面后，可看到代码中使用的 Spring 容器均为同一个对象

# SpringMVC

### 一、SpringMVC概述

##### 1 SpringMVC 简介

SpringMVC 也叫 Spring web mvc。是 Spring 框架的一部分，是在 Spring3.0 后发布的。

```
SpringMVC：
	是基于spring的一个框架， 实际上就是spring的一个模块， 专门是做web开发的。
	理解是servlet的一个升级

	web开发底层是servlet，框架是在servlet基础上面加入一些功能，让你做web开发方便。

SpringMVC就是一个Spring。
Spring是容器，ioc能够管理对象，使用<bean>, @Component, @Repository, @Service, @Controller
SpringMVC能够创建对象，放入到容器中（SpringMVC容器），springmvc容器中放的是控制器对象，

我们要做的是 使用@Contorller创建控制器对象，把对象放入到springmvc容器中，把创建的对象作为控制器使用
这个控制器对象能接收用户的请求，显示处理结果，就当做是一个servlet使用。

使用@Controller注解创建的是一个普通类的对象，不是Servlet。springmvc赋予了控制器对象一些额外的功能。

web开发底层是servlet，springmvc中有一个对象是Servlet：DispatherServlet(中央调度器)
DispatherServlet: 负责接收用户的所有请求，用户把请求给了DispatherServlet，之后DispatherServlet把请求转发给
                  我们的Controller对象， 最后是Controller对象处理请求。

index.jsp-----DispatherServlet(Servlet)----转发，分配给---Controller对象（@Controller注解创建的对象）
main.jsp                                                   MainController
addUser.jsp                                                UserController
```



##### 2 SpringMVC 优点

1. 基于 MVC 架构

   基于 MVC 架构，功能分工明确；解耦合；

2. 容易理解，上手快，使用简单

   就可以开发一个注解的 SpringMVC 项目，SpringMVC 也是轻量级的，jar 很小。不依赖特定的接口和类。

3. 作为 Spring 框架一部分，能够使用 Spring 的 IOC 和 AOP 。方便整合Strtus，MyBatis，Hiberate，JPA 等其他框架。

4. SpringMVC 强化注解的使用，在控制器，Service，Dao 都可以使用注解。方便灵活。

   使用@Controller 创建处理器对象，@Service 创建业务对象，@Autowired 或者@Resource 在控制器类中注入 Service，Service 类中注入 Dao。

   

##### 3 第一个注解的 SpringMVC 程序

```
ch01-hello-springmvc: 第一个springmvc项目。
需求：用户在页面发起一个请求，请求交给springmvc的控制器对象，
     并显示请求的处理结果（在结果页面显示一个欢迎语句）。
实现步骤：
1. 新建web maven工程
2. 加入依赖
   spring-webmvc依赖，间接把spring的依赖都加入到项目
   jsp，servlet依赖
3.重点：在web.xml中注册springmvc框架的核心对象DispatcherServlet
     1)DispatcherServlet叫做中央调度器，是一个servlet，它的父类是继承HttpServlet
     2)DispatcherServlet也叫做前端控制器（front controller）
     3)DispatcherServlet负责接收用户提交的请求，调用其它的控制器对象，并把请求的处理结果显示给用户
4.创建一个发起请求的页面 index.jsp
5.创建控制器(处理器)类
  1）在类的上面加入@Controller注解，创建对象，并放入到springmvc容器中
  2）在类中的方法上面加入@RequestMapping注解。
6.创建一个作为结果的jsp，显示请求的处理结果。
7.创建springmvc的配置文件（spring的配置文件一样）
  1）声明组件扫描器，指定@Contorller注解所在的包名
  2）声明视图解析器。帮助处理视图的。
```

###### 3.1 新建 maven web 项目

![image-20220302214201016](https://cdn.jsdelivr.net/gh/xukang0509/picgo_bed/img/202203132338514.png)



###### 3.2 pom.xml

在创建好 web 项目后，加入 Servlet 依赖，SpringMVC 依赖

```xml
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://maven.apache.org/POM/4.0.0
                      http://maven.apache.org/xsd/maven-4.0.0.xsd">
  <modelVersion>4.0.0</modelVersion>

  <groupId>org.example</groupId>
  <artifactId>ch01-hello-springmvc</artifactId>
  <version>1.0-SNAPSHOT</version>
  <packaging>war</packaging>

  <properties>
    <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
    <maven.compiler.source>1.8</maven.compiler.source>
    <maven.compiler.target>1.8</maven.compiler.target>
  </properties>

  <dependencies>
    <!--servlet依赖-->
    <dependency>
      <groupId>javax.servlet</groupId>
      <artifactId>javax.servlet-api</artifactId>
      <version>3.1.0</version>
      <scope>provided</scope>
    </dependency>
    <!--springmvc依赖-->
    <dependency>
      <groupId>org.springframework</groupId>
      <artifactId>spring-webmvc</artifactId>
      <version>5.2.5.RELEASE</version>
    </dependency>
  </dependencies>

  <build>
    <plugins>
      <!-- 编码和编译和JDK版本 -->
      <plugin>
        <artifactId>maven-compiler-plugin</artifactId>
        <version>3.1</version>
        <configuration>
          <source>1.8</source>
          <target>1.8</target>
        </configuration>
      </plugin>
    </plugins>
  </build>
</project>
```



###### 3.3 注册中央调度器

```xml
<!--web.xml-->
<!--
    注册(声明)SpringMVC的核心对象 DispatcherServlet
    需要在tomcat服务器启动后，创建 DispatcherServlet 对象的实例。
    为什么要创建 DispatcherServlet 对象的实例呢？
    因为 DispatcherServlet 在他的创建过程中，会同时创建 springmvc 容器对象，
    读取 springmvc 的配置文件，把这个配置文件中的对象都创建好，当用户发起
    请求时就可以直接使用对象了。

    servlet的初始化会执行 init() 方法。 DispatcherServlet在 init() 中{
       //创建容器，读取配置文件
       WebApplicationContext ctx = new ClassPathXmlApplicationContext("springmvc.xml");
       //把容器对象放入到 ServletContext 中
       getServletContext().setAttribute(key, ctx);
    }

    启动tomcat报错，读取这个文件 /WEB-INF/springmvc-servlet.xml（/WEB-INF/springmvc-servlet.xml）
    springmvc创建容器对象时，读取的配置文件默认是/WEB-INF/<servlet-name>-servlet.xml .
    -->
<servlet>
    <servlet-name>springmvc</servlet-name>
    <!--全限定类名-->
    <servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>
    
    <!--自定义springmvc读取的配置文件的位置-->
    <init-param>
        <!--springmvc的配置文件的位置的属性-->
        <param-name>contextConfigLocation</param-name>
        <!--指定自定义文件的位置-->
        <param-value>classpath:springmvc.xml</param-value>
    </init-param>

    <!--在tomcat启动后，创建Servlet对象
        load-on-startup:表示tomcat启动后创建对象的顺序。它的值是大于等于0的整数，数值越小，
                        tomcat创建对象的时间越早。
    -->
    <load-on-startup>1</load-on-startup>
</servlet>

<servlet-mapping>
    <servlet-name>springmvc</servlet-name>
    <!--
        使用框架的时候，url-pattern可以使用两种值
        1. 使用扩展名方式，语法 *.xxxx，xxxx是自定义的扩展名。常用的方式 *.do, *.action, *.mvc等等
           不能使用 *.jsp
           http://localhost:8080/myweb/some.do
           http://localhost:8080/myweb/other.do
        2.使用斜杠 "/"
    -->
    <url-pattern>*.do</url-pattern>
</servlet-mapping>
```

1. 全限定类名

   该中央调度器为一个 Servlet，名称为 DispatcherServlet。中央调度器的全限定性类名在导入的 Jar 文件 spring-webmvc-5.2.5.RELEASE.jar 的第一个包 org.springframework.web.servlet 下可找到。

2. load-on-startup

   ```
   在<servlet/>中添加<load-on-startup/>的作用是，标记是否在Web服务器（这里是Tomcat）
   启动时会创建这个 Servlet 实例，即是否在 Web 服务器启动时调用执行该Servlet的init()方
   法，而不是在真正访问时才创建。
   它的值必须是一个整数。
   ➢ 当值大于等于 0 时，表示容器在启动时就加载并初始化这个 servlet，数值越小，该 Servlet
   的优先级就越高，其被创建的也就越早；
   ➢ 当值小于 0 或者没有指定时，则表示该 Servlet 在真正被使用时才会去创建。
   ➢ 当值相同时，容器会自己选择创建顺序。
   ```

3. url-pattern

   ```
   对于<url-pattern/>，可以写为 / ，建议写为*.do 的形式。
   ```

4. 配置文件位置与名称

   注册完毕后，可直接在服务器上发布运行。此时，访问浏览器页面，控制台均会抛出 FileNotFoundException 异常。即默认要从项目根下的 WEB-INF 目录下找名称为 【Servlet名称-servlet.xml】的配置文件。这里的“Servlet 名称”指的是注册中央调度器标签中指定的 Servlet 的 name 值。本例配置文件名为 springmvc-servlet.xml。

   ![image-20220302221800071](https://cdn.jsdelivr.net/gh/xukang0509/picgo_bed/img/202203132338143.png)

   而一般情况下，配置文件是放在类路径下，即 resources 目录下。所以，在注册中央调度器时，还需要为中央调度器设置查找 SpringMVC 配置文件路径，及文件名。

   ![image-20220302221913339](https://cdn.jsdelivr.net/gh/xukang0509/picgo_bed/img/202203132338451.png)

   打开 DispatcherServlet 的源码，其继承自 FrameworkServlet，而FrameworkServlet类中有一个属性 contextConfigLocation，用于设置 SpringMVC 配置文件的路径及文件名。该初始化参数的属性就来自于这里。

   ![image-20220302222232122](https://cdn.jsdelivr.net/gh/xukang0509/picgo_bed/img/202203132338493.png)

   ![image-20220302222236350](https://cdn.jsdelivr.net/gh/xukang0509/picgo_bed/img/202203132338458.png)



###### 3.4 创建 SpringMVC 配置文件

在工程的类路径即 src 目录下创建 SpringMVC 的配置文件 springmvc.xml。该文件名可以任意命名。

![image-20220302222659407](https://cdn.jsdelivr.net/gh/xukang0509/picgo_bed/img/202203132338447.png)



###### 3.5 创建处理(控制)器

在类上与方法上添加相应注解即可。 

@Controller：表示当前类为处理器 

@RequestMapping：表示当前方法为处理器方法。该方法要对 value 属性所指定的 URI 进行处理与响应。被注解的方法的方法名可以随意

若有多个请求路径均可匹配该处理器方法的执行，则@RequestMapping 的 value 属性中可以写上一个数组。

ModelAndView 类中的 addObject()方法用于向其 Model 中添加数据。Model 的底层为一个 HashMap。

Model 中的数据存储在 request 作用域中，SringMVC 默认采用请求转发的方式跳转到视图，本次请求结束，模型中的数据被销毁。

```java
package com.springmvc.controller;

import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.servlet.ModelAndView;
/*
 *  @Controller:创建处理器对象，对象放在springmvc容器中。
 *  位置：在类的上面
 *  和Spring中讲的@Service ,@Component
 *
 *  能处理请求的都是控制器（处理器）： MyController能处理请求，
 *                       叫做后端控制器（back controller）
 *  没有注解之前，需要实现各种不同的接口才能做控制器使用
 */
@Controller
public class MyController {
    /*
       处理用户提交的请求，springmvc中是使用方法来处理的。
       方法是自定义的， 可以有多种返回值， 多种参数，方法名称自定义
     */

    /*
     * 准备使用doSome方法处理some.do请求。
     * @RequestMapping: 请求映射，作用是把一个请求地址和一个方法绑定在一起。
     *                  一个请求指定一个方法处理。
     *       属性：1.value 是一个String，表示请求的uri地址的（some.do）。
     *              value的值必须是唯一的，不能重复。 在使用时，推荐地址以“/”为开头
     *       位置：1.在方法的上面，常用的。
     *            2.在类的上面
     *  说明：使用RequestMapping修饰的方法叫做处理器方法或者控制器方法。
     *  使用@RequestMapping修饰的方法可以处理请求的，类似Servlet中的doGet, doPost
     *
     *  返回值：ModelAndView 表示本次请求的处理结果
     *   Model: 数据，请求处理完成后，要显示给用户的数据
     *   View: 视图，比如jsp等等。
     */
    @RequestMapping(value = {"/some.do", "/first.do"})
    public ModelAndView doSome(){  // doGet()--service请求处理
        //处理some.do请求了。 相当于service调用处理完成了。
        ModelAndView mv  = new ModelAndView();
        //添加数据，框架在请求的最后把数据放入到request作用域。
        //request.setAttribute("msg","欢迎使用springmvc做web开发");
        mv.addObject("msg","欢迎使用springmvc做web开发");
        mv.addObject("fun","执行的是doSome方法");

        //指定视图, 指定视图的完整路径
        //框架对视图执行的forward操作， request.getRequestDispather("/show.jsp).forward(...)
        mv.setViewName("/show.jsp");// src/main/webapp/show.jsp
        //mv.setViewName("/WEB-INF/view/show.jsp");

        //返回mv
        return mv;
    }
}
```



###### 3.6 声明组件扫描器

在 springmvc.xml 中注册组件扫描器

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:context="http://www.springframework.org/schema/context"
       xsi:schemaLocation="http://www.springframework.org/schema/beans 
       http://www.springframework.org/schema/beans/spring-beans.xsd 
       http://www.springframework.org/schema/context 
       https://www.springframework.org/schema/context/spring-context.xsd">
    <!--声明组件扫描器-->
    <context:component-scan base-package="com.springmvc.controller" />
</beans>
```



###### 3.7 页面

index.jsp

```jsp
<%@ page contentType="text/html;charset=UTF-8" language="java" %>
<html>
<head>
    <title>Title</title>
</head>
<body>
    <P>第一个SpringMVC项目</P>
    <p><a href="some.do">发起some.do的请求</a></p>
</body>
</html>
```

show.jsp

```jsp
<%@ page contentType="text/html;charset=UTF-8" language="java" %>
<html>
<head>
    <title>Title</title>
</head>
<body>
  <h3>show.jsp 从request作用域获取数据</h3><br>
  <h4>msg数据:${msg}</h4><br>
  <h4>fun数据:${fun}</h4>
</body>
</html>
```

```
springmvc请求的处理流程
 1）发起some.do
 2）tomcat(web.xml--url-pattern知道 *.do的请求给DispatcherServlet)
 3）DispatcherServlet（根据springmvc.xml配置知道 some.do---doSome()）
 4）DispatcherServlet把some.do转发给MyController.doSome()方法
 5）框架执行 doSome() 把得到的ModelAndView进行处理，转发到show.jsp

上面的过程简化的方式
  some.do---DispatcherServlet---MyController
```

![image-20220303192620870](https://cdn.jsdelivr.net/gh/xukang0509/picgo_bed/img/202203132338589.png)

![image-20220303192625147](https://cdn.jsdelivr.net/gh/xukang0509/picgo_bed/img/202203132338741.png)

springMVC请求处理过程

![springmvc](https://cdn.jsdelivr.net/gh/xukang0509/picgo_bed/img/202203132338915.png)



###### 3.8 修改视图解析器的注册

SpringMVC 框架为了避免对于请求资源路径与扩展名上的冗余，在视图解析器 InternalResouceViewResolver 中引入了请求的前辍与后辍。而 ModelAndView 中只需给出要跳转页面的文件名即可，对于具体的文件路径与文件扩展名，视图解析器会自动完成拼接。

把 show.jsp 文件放到 /WEB-INF/jsp/路径中

```xml
	<!--springmvc.xml-->
	<!--注册视图解析器：帮助我们处理视图的路径和扩展名，生成视图对象-->
	<!--声明 springmvc框架中的视图解析器，帮助开发人员设置视图文件的路径-->
    <bean  class="org.springframework.web.servlet.view.InternalResourceViewResolver">
        <!--前缀：视图文件的路径-->
        <property name="prefix" value="/WEB-INF/jsp/" />
        <!--后缀：视图文件的扩展名-->
        <property name="suffix" value=".jsp" />
    </bean>
```



###### 3.9 修改处理器

使用逻辑视图名称，show 是逻辑视图名称。

```java
	@RequestMapping(value = "/some.do")
    public ModelAndView doSome(){
        ModelAndView mv  = new ModelAndView();
        
        mv.addObject("msg","欢迎使用springmvc做web开发");
        mv.addObject("fun","执行的是doSome方法");
        
        //当配置了视图解析器后，可以使用逻辑名称（文件名），指定视图
        //框架会使用视图解析器的前缀 + 逻辑名称 + 后缀 组成完成路径，这里就是字符连接操作
        // /WEB-INF/view/ + show + .jsp
        mv.setViewName("show");

        return mv;
    }
```



###### 3.10 使用 SpringMVC 框架 web 请求处理顺序

![image-20220303200208062](https://cdn.jsdelivr.net/gh/xukang0509/picgo_bed/img/202203132339703.png)



##### 4 SpringMVC 的 MVC 组件

![image-20220303200244538](https://cdn.jsdelivr.net/gh/xukang0509/picgo_bed/img/202203132339964.png)



##### 5 SpringMVC 执行流程

###### 5.1 流程图

![image-20220303201039414](https://cdn.jsdelivr.net/gh/xukang0509/picgo_bed/img/202203132339717.png)

###### 5.2 执行流程简单分析

1. 浏览器提交请求到中央调度器。 
2. 中央调度器直接将请求转给处理器映射器。 
3. 处理器映射器会根据请求，找到处理该请求的处理器，并将其封装为处理器执行链后返回给中央调度器。 
4. 中央调度器根据处理器执行链中的处理器，找到能够执行该处理器的处理器适配器。 
5. 处理器适配器调用执行处理器。 
6. 处理器将处理结果及要跳转的视图封装到一个对象 ModelAndView 中，并将其返回给处理器适配器。 
7. 处理器适配器直接将结果返回给中央调度器。 
8. 中央调度器调用视图解析器，将 ModelAndView 中的视图名称封装为视图对象。 
9. 视图解析器将封装了的视图对象返回给中央调度器。 
10. 中央调度器调用视图对象，让其自己进行渲染，即进行数据填充，形成响应对象。 
11. 中央调度器响应浏览器。



### 二、SpringMVC 注解式开发

##### 1 @RequestMapping 定义请求规则

###### 1.1 指定模块名称

通过@RequestMapping 注解可以定义处理器对于请求的映射规则。该注解可以注解在方法上，也可以注解在类上，但意义是不同的。value 属性值常以“/”开始。

@RequestMapping 的 value 属性用于定义所匹配请求的 URI。但对于注解在方法上与类上，其 value 属性所指定的 URI，意义是不同的。

一个@Controller 所注解的类中，可以定义多个处理器方法。当然，不同的处理器方法所匹配的 URI 是不同的。这些不同的 URI 被指定在注解于方法之上的@RequestMapping 的 value 属性中。但若这些请求具有相同的 URI 部分，则这些相同的 URI，可以被抽取到注解在类之上的@RequestMapping 的 value 属性中。此时的这个 URI 表示模块的名称。URI 的请求是相对于 Web 的根目录。

换个角度说，要访问处理器的指定方法，必须要在方法指定 URI 之前加上处理器类前定义的模块名称

```java
/**
 * @RequestMapping:
 *    value：所有请求地址的公共部分,叫做模块名称
 *    位置：放在类的上面
 */
@RequestMapping("/test")
@Controller
public class MyController {
    @RequestMapping(value = "/some.do")
    public ModelAndView doSome(){
        ModelAndView mv  = new ModelAndView();
        mv.addObject("msg","欢迎使用springmvc做web开发");
        mv.addObject("fun","执行的是doSome方法");
        mv.setViewName("show");
        return mv;
    }

    @RequestMapping(value = {"/other.do","/second.do"})
    public ModelAndView doOther(){
        ModelAndView mv  = new ModelAndView();
        mv.addObject("msg","====欢迎使用springmvc做web开发====");
        mv.addObject("fun","执行的是doOther方法");
        mv.setViewName("other");
        return mv;
    }
}
```



###### 1.2 对请求提交方式的定义

对于@RequestMapping，其有一个属性 method，用于对被注解方法所处理请求的提交方式进行限制，即只有满足该 method 属性指定的提交方式的请求，才会执行该被注解方法。

Method 属性的取值为 RequestMethod 枚举常量。常用的为 RequestMethod.GET 与 RequestMethod.POST，分别表示提交方式的匹配规则为 GET 与 POST 提交。

客户端浏览器常用的请求方式，及其提交方式有以下几种：

| 序号 | 请求方式        | 提交方式              |
| ---- | --------------- | --------------------- |
| 1    | 表单请求        | 默认GET，可以指定POST |
| 2    | AJAX请求        | 默认GET，可以指定POST |
| 3    | 地址栏请求      | GET请求               |
| 4    | 超链接请求      | GET请求               |
| 5    | src资源路径请求 | GET请求               |

也就是说，只要指定了处理器方法匹配的请求提交方式为 POST，则相当于指定了请求发送的方式：要么使用表单请求，要么使用 AJAX 请求。其它请求方式被禁用。

```java
修改处理器类 MyController
package com.springmvc.controller;

import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestMethod;
import org.springframework.web.servlet.ModelAndView;
/*
 * @RequestMapping:
 *    value：所有请求地址的公共部分,叫做模块名称
 *    位置： 放在类的上面
 */
@RequestMapping("/test")
@Controller
public class MyController {
    /*
     * @RequestMapping : 请求映射
     *         属性：method， 表示请求的方式。它的值RequestMethod类枚举值。
     *              get请求方式，RequestMethod.GET
     *              post请求方式，RequestMethod.POST
     *
     *  你不用get方式，错误是：
     *  HTTP Status 405 - Request method 'GET' not supported
     */
    //指定some.do使用get请求方式
    @RequestMapping(value = "/some.do", method = RequestMethod.GET)
    public ModelAndView doSome(){
        ModelAndView mv  = new ModelAndView();
        mv.addObject("msg","欢迎使用springmvc做web开发");
        mv.addObject("fun","执行的是doSome方法");
        mv.setViewName("show");
        return mv;
    }

    //指定other.do使用post请求方式
    @RequestMapping(value = "/other.do", method = RequestMethod.POST)
    public ModelAndView doOther(){
        ModelAndView mv  = new ModelAndView();
        mv.addObject("msg","====欢迎使用springmvc做web开发====");
        mv.addObject("fun","执行的是doOther方法");
        mv.setViewName("other");
        return mv;
    }

    //不指定请求方式，没有限制
    @RequestMapping(value = {"/first.do"})
    public ModelAndView doFirst(){
        ModelAndView mv  = new ModelAndView();
        mv.addObject("msg","====欢迎使用springmvc做web开发====");
        mv.addObject("fun","执行的是doFirst方法");
        mv.setViewName("other");
        return mv;
    }
}
```

```jsp
修改 index 页面
<%@ page contentType="text/html;charset=UTF-8" language="java" %>
<html>
<head>
    <title>Title</title>
</head>
<body>
    <P>第一个SpringMVC项目</P>
    <p><a href="test/some.do">发起some.do的get请求</a></p>
    <br>
    <form action="test/other.do" method="post">
        <input type="submit" value="post请求other.do">
    </form>
    <p><a href="test/first.do">发起first.do的默认(get)请求</a></p>
</body>
</html>
```



##### 2 处理器方法的参数

处理器方法可以包含以下四类参数，这些参数会在系统调用时由系统自动赋值，即程序员可在方法内直接使用。

- HttpServletRequest 
- HttpServletResponse 
- HttpSession 
- 请求中所携带的请求参数（逐个接收、对象接收）

![image-20220303205241346](https://cdn.jsdelivr.net/gh/xukang0509/picgo_bed/img/202203132339596.png)



###### 2.1 逐个参数接收

只要保证请求参数名与该请求处理方法的参数名相同即可。

Step1:修改 index 页面

```jsp
<%@ page contentType="text/html;charset=UTF-8" language="java" %>
<html>
<head>
    <title>Title</title>
</head>
<body>
    <P>提交参数给Controller</P>
    <form action="receiveProperty.do" method="post">
        姓名：<input type="text" name="name"><br>
        年龄：<input type="text" name="age"><br>
        <input type="submit" value="提交参数">
    </form>
</body>
</html>
```

Step2:修改处理器类 MyController

```java
@Controller
public class MyController {
    /*
     * 逐个接收请求的参数
     *   要求：处理器方法的形参名和请求中参数名必须一样
     *        同名的请求参数赋值给同名的形参
     *   框架接收请求参数
     *   1. 使用request对象接收请求参数
     *      String strName = request.getParameter("name");
     *      String strAge = request.getParameter("age");
     *   2. springmvc框架通过 DispatcherServlet 调用 MyController的doSome()方法
     *      调用方法时，按名称对应，把接收的参数赋值给形参
     *      doSome（strName，Integer.valueOf(strAge)）
     *      框架会提供类型转换的功能，能把String转为 int，long，float，double等类型。
     *
     *  400状态码是客户端错误，表示提交请求参数过程中，发生了问题。
     */
    @RequestMapping(value = "receiveProperty.do", method = RequestMethod.POST)
    public ModelAndView doSome(String name, Integer age){
        System.out.println("name:" + name + "\nage:" + age);
        ModelAndView mv = new ModelAndView();
        mv.addObject("myName", name);
        mv.addObject("myAge", age);
        mv.setViewName("show");
        return mv;
    }
}
```

Step3:添加 show 页面

在 /WEB-INF/jsp 下添加 show.jsp 页面。

```jsp
<%@ page contentType="text/html;charset=UTF-8" language="java" %>
<html>
<head>
    <title>Title</title>
</head>
<body>
  <h3>show.jsp 从request作用域获取数据</h3><br>
  <h4>myName数据:${myName}</h4><br>
  <h4>myAge数据:${myAge}</h4>
</body>
</html>
```



###### 2.2 请求参数中文乱码问题

```
注意：
 在提交请求参数时，get请求方式中文没有乱码。
 使用post方式提交请求，中文有乱码，需要使用过滤器处理乱码的问题。
 
过滤器可以自定义，也可使用框架中提供的过滤器 CharacterEncodingFilter
```

对于前面所接收的请求参数，若含有中文，则会出现中文乱码问题。Spring 对于请求参
数中的中文乱码问题，给出了专门的字符集过滤器：spring-web-5.2.5.RELEASE.jar 的
org.springframework.web.filter 包下的 CharacterEncodingFilter 类。

1. 解决方案

   在 web.xml 中注册字符集过滤器，即可解决 Spring 的请求参数的中文乱码问题。不过，
   最好将该过滤器注册在其它过滤器之前。因为过滤器的执行是按照其注册顺序进行的。

   直接在 web.xml 上直接进行设置字符集过滤器

   ```xml
   	<!--web.xml-->
   	<!--注册声明过滤器，解决Post请求乱码的问题-->
       <filter>
           <filter-name>characterEncodingFilter</filter-name>
           <filter-class>org.springframework.web.filter.CharacterEncodingFilter</filter-class>
           <!--设置项目中使用的字符编码-->
           <init-param>
               <param-name>encoding</param-name>
               <param-value>utf-8</param-value>
           </init-param>
           <!--强制请求对象(HttpServletRequest)使用encoding编码的值-->
           <init-param>
               <param-name>forceRequestEncoding</param-name>
               <param-value>true</param-value>
           </init-param>
           <!--强制应答对象(HttpServletResponse)使用encoding编码的值-->
           <init-param>
               <param-name>forceResponseEncoding</param-name>
               <param-value>true</param-value>
           </init-param>
       </filter>
   
       <filter-mapping>
           <filter-name>characterEncodingFilter</filter-name>
           <!-- /*:表示强制所有的请求先通过过滤器处理 -->
           <url-pattern>/*</url-pattern>
       </filter-mapping>
   ```

2. 源码分析

   字符集设置核心方法：

   ![image-20220305140159864](https://cdn.jsdelivr.net/gh/xukang0509/picgo_bed/img/202203132339111.png)



###### 2.3 校正请求参数名@RequestParam

所谓校正请求参数名，是指若请求 URL 所携带的参数名称与处理方法中指定的参数名
不相同时，则需在处理方法参数前，添加一个注解 @RequestParam(“请求参数名”)，指定请
求 URL 所携带参数的名称。该注解是对处理器方法参数进行修饰的。value 属性指定请求参
数的名称。

Step1：修改 index 页面

将表单中的参数名称修改的与原来不一样。

```jsp
	<p>请求参数名和处理器方法的形参名不一样</p>
    <form action="receiveparam.do" method="post">
        姓名：<input type="text" name="rname"> <br/>
        年龄：<input type="text" name="rage"> <br/>
        <input type="submit" value="提交参数">
    </form>
```

Step2：修改处理器类 MyController

```java
	/*
     * 请求中参数名和处理器方法的形参名不一样
     * @RequestParam: 逐个接收请求参数中，解决请求中参数名形参名不一样的问题
     *      属性： 1. value 请求中的参数名称
     *            2. required 是一个boolean，默认是true
     *                true：表示请求中必须包含此参数。
     *                false：可以没有此参数
     *      位置： 在处理器方法的形参定义的前面
     */
    @RequestMapping(value = "/receiveparam.do")
    public ModelAndView receiveParam(@RequestParam(value = "rname", required = false) String name,
                                     @RequestParam(value = "rage", required = false) Integer age) {
        System.out.println("doSome, name=" + name + "  age=" + age);
        //可以在方法中直接使用 name ， age
        //处理some.do请求了。 相当于service调用处理完成了。
        ModelAndView mv = new ModelAndView();
        mv.addObject("myName", name);
        mv.addObject("myAge", age);
        //show是视图文件的逻辑名称（文件名称）
        mv.setViewName("show");
        return mv;
    }
```



###### 2.4 对象参数接收

将处理器方法的参数定义为一个对象，只要保证请求参数名与这个对象的属性同名即可。

Step1：index 页面

```jsp
 	<p>使用Java对象接受请求参数</p>
    <form action="receiveObject.do" method="post">
        姓名：<input type="text" name="name"> <br/>
        年龄：<input type="text" name="age"> <br/>
        <input type="submit" value="提交参数">
    </form>
```

Step2：定义类 Student

```java
package com.springmvc.vo;

//保存请求参数值的一个普通类
public class Student {
    // 属性名和请求中参数名一样
    private String name;
    private Integer age;
	// get set toString
}
```

Step3：修改处理器类 MyController

```java
	/*
     * 处理器方法形参是java对象，这个对象的属性名和请求中参数名一样的
     * 框架会创建形参的java对象，给属性赋值。请求中的参数是name，框架会调用setName()
     */
    @RequestMapping(value = "/receiveObject.do")
    public ModelAndView receiveObject(Student myStudent) {
        System.out.println("myStduent=" + myStudent);
        ModelAndView mv = new ModelAndView();
        mv.addObject("myName", myStudent.getName());
        mv.addObject("myAge", myStudent.getAge());
        mv.addObject("myStudent", myStudent);
        mv.setViewName("show");
        return mv;
    }
```

Step4：修改 show 页面

```jsp
<body>
  <h3>show.jsp 从request作用域获取数据</h3>
  <h4>myName数据:${myName}</h4>
  <h4>myAge数据:${myAge}</h4>
  <h4>student数据:${myStudent}</h4>
</body>
```



##### 3 处理器方法的返回值

使用@Controller 注解的处理器的处理器方法，其返回值常用的有四种类型：

- ModelAndView (同时处理数据和视图)
- String
- 无返回值 void
- 返回自定义类型对象



###### 3.1 返回 ModelAndView

若处理器方法处理完后，需要跳转到其它资源，且又要在跳转的资源间传递数据，此时
处理器方法返回 ModelAndView 比较好。当然，若要返回 ModelAndView，则处理器方法中
需要定义 ModelAndView 对象。

在使用时，若该处理器方法只是进行跳转而不传递数据，或只是传递数据而并不向任何
资源跳转（如对页面的 Ajax 异步响应），此时若返回 ModelAndView，则将总是有一部分多
余：要么 Model 多余，要么 View 多余。即此时返回 ModelAndView 将不合适。



###### 3.2 返回 String

处理器方法返回的字符串可以指定逻辑视图名，通过视图解析器解析可以将其转换为物
理视图地址

**返回内部资源逻辑视图名**

若要跳转的资源为内部资源，则视图解析器可以使用 InternalResourceViewResolver 内部
资源视图解析器。此时处理器方法返回的字符串就是要跳转页面的文件名去掉文件扩展名后
的部分。这个字符串与视图解析器中的 prefix、suffix 相结合，即可形成要访问的 URI。

![image-20220305163657330](https://cdn.jsdelivr.net/gh/xukang0509/picgo_bed/img/202203132341628.png)

index 页面

```jsp
<body>
    <P>处理器方法返回String表示视图名称</P>
    <form action="returnString-view.do" method="post">
        姓名：<input type="text" name="name"><br>
        年龄：<input type="text" name="age"><br>
        <input type="submit" value="提交参数">
    </form>
    <br/>
</body>
```

处理器类 MyController

```java
@Controller
public class MyController {
    /*
    * 处理器方法返回String---表示逻辑视图名称，需要配置视图解析器
    * */
    @RequestMapping(value = "/returnString-view.do", method = RequestMethod.POST)
    public String doReturnView(HttpServletRequest request, String name, Integer age) {
        System.out.println("doReturnView name:" + name + "\nage:" + age);
        //可以自己手工添加数据到request作用域
        request.setAttribute("myName",name);
        request.setAttribute("myAge",age);
        // 逻辑视图名称，项目中配置了视图解析器
        // 框架对视图执行 forward 转发操作
        // /WEB-INF/jsp/show.jsp
        return "show";
    }
}
```

show 页面

```jsp
<body>
  <h3>show.jsp 从request作用域获取数据</h3>
  <h4>myName数据:${myName}</h4>
  <h4>myAge数据:${myAge}</h4>
</body>
```

当然，也可以直接**返回资源的物理视图名**。不过，此时就不需要再在视图解析器中再配
置前辍与后辍了。

```java
	//处理器方法返回String，表示完整视图路径，此时不能配置视图解析器
    @RequestMapping(value = "/returnString-view2.do")
    public String doReturnView2(HttpServletRequest request,String name, Integer age){
        System.out.println("===doReturnView2====, name="+name+"   age="+age);
        //可以自己手工添加数据到request作用域
        request.setAttribute("myname",name);
        request.setAttribute("myage",age);
        // 完整视图路径，项目中不能配置视图解析器
        // 框架对视图执行forward转发操作
        return "/WEB-INF/view/show.jsp";
    }
```



###### 3.3 返回 void

对于处理器方法返回 void 的应用场景，AJAX 响应

若处理器对请求处理后，无需跳转到其它任何资源，此时可以让处理器方法返回 void。

Step1：maven 加入 jackson 依赖

由于本项目中服务端向浏览器传回的是 JSON 数据，需要使用一个工具类将字符串包装
为 JSON 格式，所以需要导入 JSON 的依赖。

```xml
	<!--pom.xml-->
	<!--Jackson依赖-->
    <dependency>
      <groupId>com.fasterxml.jackson.core</groupId>
      <artifactId>jackson-core</artifactId>
      <version>2.9.0</version>
    </dependency>
    <dependency>
      <groupId>com.fasterxml.jackson.core</groupId>
      <artifactId>jackson-databind</artifactId>
      <version>2.9.0</version>
    </dependency>
```

Step2：引入 jQuery 库

由于本项目要使用 jQuery 的 ajax()方法提交 AJAX 请求，所以项目中需要引入 jQuery 的
库。在 webapp下新建一个 Folder（文件夹），命名为 js，并将 jquery-3.6.0.js 文件放入其
中。

![image-20220306142227841](https://cdn.jsdelivr.net/gh/xukang0509/picgo_bed/img/202203132339092.png)

Step3：定义 index 页面

index 页面由两部分内容构成：一个是<button/>，用于提交 AJAX 请求；一个是<script/>，
用于处理 AJAX 请求。

```jsp
<%@ page contentType="text/html;charset=UTF-8" language="java" %>
<html>
<head>
    <title>Title</title>
    <script type="text/javascript" src="js/jquery-3.6.0.js"></script>
    <script type="text/javascript">
        $(function (){
            $("#btn").click(function (){
                $.ajax({
                    url:"returnvoid-ajax.do",
                    data:{
                        name:"zhangsan",
                        age:20
                    },
                    type:"post",
                    dataType:"json",
                    success:function (resp){
                        //resp从服务器端返回的是json格式的字符串 {"name":"zhangsan","age":20}
                        //jquery会把字符串转为json对象， 赋值给resp形参。
                        alert(resp.name + "    "+resp.age);
                    }
                })
            })
        })
    </script>
</head>
    
<body>
    <button id="btn">发起ajax请求</button>
</body>
</html>
```

Step4: 定义对象 Student

```java
public class Student{
	//属性名和请求参数名一样
	private String name;
	private Integer age;
	// set get
}
```

Step5：修改处理器类 MyController

处理器对于 AJAX 请求中所提交的参数，可以使用逐个接收的方式，也可以以对象的方
式整体接收。只要保证 AJAX 请求参数与接收的对象类型属性同名。

以逐个方式接收参数：

```java
package com.springmvc.controller;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.springmvc.vo.Student;
import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestMethod;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.servlet.ModelAndView;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import javax.servlet.http.HttpSession;
import java.io.IOException;
import java.io.PrintWriter;

@Controller
public class MyController {
    // 处理器方法返回void，响应ajax请求
    // 手工实现ajax，json数据：代码有重复的 1.java对象转为json；2.通过HttpServletResponse输出json数据
    @RequestMapping(value = "/returnvoid-ajax.do", method = RequestMethod.POST)
    public void doReturnVoid(HttpServletResponse response, String name, Integer age) throws IOException {
        System.out.println("doReturnVoidAjax name:" + name + "\nage:" + age);
        // 处理ajax，使用json做数据的格式
        // service调用完成了，使用Student表示处理结果
        Student student = new Student();
        student.setName(name);
        student.setAge(age);
        //把结果的对象转为json格式的数据
        String json = "";
        if(student != null){
            ObjectMapper om = new ObjectMapper();
            json = om.writeValueAsString(student);
            System.out.println(student + " ==> " + json);
        }
        // 输出数据，响应ajax的请求
        response.setContentType("application/json;charset=utf-8");
        PrintWriter writer = response.getWriter();
        writer.println(json);
        writer.flush();
        writer.close();
    }
}
```



###### 3.4 返回对象Object

处理器方法也可以返回 Object 对象。这个 Object 可以是 Integer，String，自定义对象，
Map，List 等。但返回的对象不是作为逻辑视图出现的，而是作为直接在页面显示的数据出
现的。

返回对象，需要使用@ResponseBody 注解，将转换后的 JSON 数据放入到响应体中。

1. 环境搭建

    maven pom.xml

   由于返回 Object 数据，一般都是将数据转化为了 JSON 对象后传递给浏览器页面的。而
   这个由 Object 转换为 JSON，是由 Jackson 工具完成的。所以需要导入 Jackson 的相关 Jar 包。

   ```xml
   	<!--Jackson依赖-->
       <dependency>
         <groupId>com.fasterxml.jackson.core</groupId>
         <artifactId>jackson-core</artifactId>
         <version>2.9.0</version>
       </dependency>
       <dependency>
         <groupId>com.fasterxml.jackson.core</groupId>
         <artifactId>jackson-databind</artifactId>
         <version>2.9.0</version>
       </dependency>
   ```

   

   声明注解驱动

   将 Object 数据转化为 JSON 数据，需要由**消息转换器 HttpMessageConverter** 完成。而转
   换器的开启，需要由<mvc:annotation-driven/ >来完成。

   SpringMVC 使用消息转换器实现请求数据和对象，处理器方法返回对象和响应输出之间
   的自动转换

   当 Spring 容器进行初始化过程中，在 <mvc:annotation-driven/ > 处创建注解驱动时，默认
   创建了七个 HttpMessageConverter 对象。也就是说，我们注册 <mvc:annotation-driven/ > ，就
   是为了让容器为我们创建 HttpMessageConverter 对象。

   ![image-20220306145918905](https://cdn.jsdelivr.net/gh/xukang0509/picgo_bed/img/202203132339288.png)

   HttpMessageConverter 接口 : HttpMessageConverter<T>是 Spring3.0 新添加的一个接口，
   负责将请求信息转换为一个对象（类型为 T），将对象（类型为 T）输出为响应信息

   

   HttpMessageConverter<T>接口定义的方法：

   - boolean canRead(Class<?> clazz, MediaType mediaType)：指定转换器可以读取的对象类型，即
     转换器是否可将请求信息转换为 clazz 类型的对象，同时指定支持 MIME 类型
     ( text/html, applaiction/json 等)
   - boolean canWrite(Class<?> clazz, MediaType mediaType)：指定转换器是否可将 clazz 类型的对
     象写到响应流中，响应流支持的媒体类型在 MediaType 中定义。
   - LIst<MediaType> getSupportMediaTypes()：该转换器支持的媒体类
     型。
   - T read(Class<? extends T> clazz,HttpInputMessage inputMessage)：将请求信息流转换为 T 类型
     的对象。
   - void write(T t, MediaType contnetType, HttpOutputMessgae outputMessage):将 T 类型的对象写
     到响应流中，同时指定相应的媒体类型为 contentType

   

   | *HttpMessageConverter 接口实现类*       | *作用*                                                       |
   | --------------------------------------- | ------------------------------------------------------------ |
   | ByteArrayHttpMessageConverter           | 负责读取二进制格式的数据和写出二进制格<br/>式的数据          |
   | **StringHttpMessageConverter**          | **负责读取字符串格式的数据和写出字符串格<br/>式的数据**      |
   | ResourceHttpMessageConverter            | 负责读取资源文件和写出资源文件数据                           |
   | SourceHttpMessageConverter              | 能够读 / 写 来 自 HTTP 的 请 求 与 响 应 的<br/>javax.xml.transform.Source ,支持 DOMSource, <br/>SAXSource, 和 StreamSource 的 XML 格式 |
   | AllEncompassingFormHttpMessageConverter | 负责处理表单(form)数据                                       |
   | Jaxb2RootElementHttpMessageConverter    | 使用 JAXB 负责读取和写入 xml 标签格式的数<br/>据             |
   | **MappingJackson2HttpMessageConverter** | **负责读取和写入 json 格式的数据。利用<br/>Jackson 的 ObjectMapper 读写 json 数据，操作<br/>Object 类型数据，可读取 application/json，响<br/>应媒体类型为 application/json** |

   

   2. 返回自定义类型对象

      返回自定义类型对象时，不能以对象的形式直接返回给客户端浏览器，而是将对象转换
      为 JSON 格式的数据发送给浏览器的。

      由于转换器底层使用了Jackson转换方式将对象转换为JSON数据，所以需要导入Jackson
      的相关 Jar 包或者依赖。

      Step1：定义数据类

      ```java
      public class Student{
      	//属性名和请求参数名一样
      	private String name;
      	private Integer age;
      	// set get toString()
      }
      ```

      Step2：springmvc.xml 中注册mvc的注解驱动

      ```xml
      <beans xmlns="http://www.springframework.org/schema/beans"
             xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
             xmlns:context="http://www.springframework.org/schema/context"
             xmlns:mvc="http://www.springframework.org/schema/mvc"
             xsi:schemaLocation="http://www.springframework.org/schema/beans
             http://www.springframework.org/schema/beans/spring-beans.xsd
             http://www.springframework.org/schema/context
             https://www.springframework.org/schema/context/spring-context.xsd
             http://www.springframework.org/schema/mvc
             https://www.springframework.org/schema/mvc/spring-mvc.xsd">	
      	<!--注册mvc的注解驱动-->
          <mvc:annotation-driven />
      ```

      Step3：修改处理器 MyController

      ```java
      @Controller
      public class MyController {
          /*
          * 处理器方法返回一个Student，通过框架转为json，响应ajax请求
          * @ResponseBody:
          *   作用：把处理器方法返回对象转为json后，通过HttpServletResponse输出给浏览器
          *   位置：方法的定义上面。和其他注解没有顺序的关系
          * 返回对象框架的处理流程
          * 1.框架会把返回Student类型，调用框架的中ArrayList<HttpMessageConverter>中每个类的canWrite()方法
          *   检查那个HttpMessageConverter接口的实现类能处理Student类型的数据--MappingJackson2HttpMessageConverter
          * 2.框架会调用实现类的write()，MappingJackson2HttpMessageConverter的write()方法
          *   把李四同学的student对象转为json，调用Jackson的ObjectMapper实现转为json
          *   contentType:application/json;charset=utf-8
          * 3.框架会调用 @ResponseBody 把2的结果数据输出到浏览器，ajax请求处理完成
          * */
          @RequestMapping(value = "/retuenStudentJson.do")
          @ResponseBody
          public Student doStudentJsonObject(){
              // 调用Service，获取请求结果数据，Student对象表示结果数据
              Student student = new Student();
              student.setName("李四同学");
              student.setAge(20);
              return student;// 会被框架转为json
          }
      }
      ```

      Step4：修改 index 页面

      ```jsp
      <%@ page contentType="text/html;charset=UTF-8" language="java" %>
      <html>
      <head>
          <title>Title</title>
          <script type="text/javascript" src="js/jquery-3.6.0.js"></script>
          <script type="text/javascript">
              $(function (){
                  $("#btn").click(function (){
                      $.ajax({
                          url:"retuenStudentJson.do",
                          type:"post",
                          dataType:"json",
                          success:function (resp){
                              // {"name":"李四同学","age":20}
                              alert(resp.name + "    "+resp.age);
                          }
                      })
                  })
              })
          </script>
      </head>
      <body>
          <button id="btn">发起ajax请求</button>
      </body>
      </html>
      ```

      

   3. 返回 List 集合

      Step1：处理器 MyController

      ```java
      @Controller
      public class MyController {
          /*
           * 处理器方法返回List<Student>
           * 返回对象框架的处理流程：
           *  1.框架会把返回List<Student>类型，调用框架的中ArrayList<HttpMessageConverter>中每个类的canWrite()方法
           *    检查那个HttpMessageConverter接口的实现类能处理Student类型的数据--MappingJackson2HttpMessageConverter
           *  2.框架会调用实现类的write（）， MappingJackson2HttpMessageConverter的write()方法
           *    把李四同学的student对象转为json， 调用Jackson的ObjectMapper实现转为json array
           *    contentType: application/json;charset=utf-8
           *  3.框架会调用@ResponseBody把2的结果数据输出到浏览器， ajax请求处理完成
           */
          @RequestMapping(value = "/retuenStudentJsonList.do")
          @ResponseBody
          public List<Student> doStudentJsonObjectArray(){
              List<Student> list = new ArrayList<>();
              // 调用Service，获取请求结果数据，Student对象表示结果数据
              Student student = new Student();
              student.setName("李四同学");
              student.setAge(20);
              list.add(student);
      
              student = new Student();
              student.setName("张三");
              student.setAge(28);
              list.add(student);
              return list;// 会被框架转为json数组
          }
      }
      ```

      Step2：index 页面

      ```jsp
      <%@ page contentType="text/html;charset=UTF-8" language="java" %>
      <html>
      <head>
          <title>Title</title>
          <script type="text/javascript" src="js/jquery-3.6.0.js"></script>
          <script type="text/javascript">
              $(function (){
                  $("#btn").click(function (){
                      $.ajax({
                          url:"retuenStudentJsonList.do",
                          type:"post",
                          dataType:"json",
                          success:function (resp){
                              // resp = "[{"name":"李四同学","age":20},{"name":"张三","age":28}]";
                              $.each(resp,function(i,n){
                                  alert(n.name + "   " + n.age)
                              })
                          }
                      })
                  })
              })
          </script>
      </head>
      <body>
          <button id="btn">发起ajax请求</button>
      </body>
      </html>
      ```

      

   4. 返回字符串对象

      若要返回非中文字符串，将前面返回数值型数据的返回值直接修改为字符串即可。但若
      返回的字符串中带有中文字符，则接收方页面将会出现乱码。此时需要使用 
      @RequestMapping 的 produces 属性指定字符集。

      produces，产品，结果，即该属性用于设置输出结果类型。

      Step1：处理器 MyController

      ```java
      @Controller
      public class MyController {
          /*
          * 处理器方法返回String，String表示数据，不是视图
          * 区分返回值String是数据，还是视图，看有没有@ResponseBody注解
          * 如果有@ResponseBody注解，返回String就是数据，反之就是视图
          *
          * 默认使用“text/plain;charset=ISO-8859-1”作为contentType,导致中文有乱码，
          * 解决方案：给RequestMapping增加一个属性 produces, 使用这个属性指定新的contentType.
          * 返回对象框架的处理流程：
          *  1.框架会把返回String类型，调用框架的中ArrayList<HttpMessageConverter>中每个类的canWrite()方法
          *    检查那个HttpMessageConverter接口的实现类能处理String类型的数据--StringHttpMessageConverter
          *  2.框架会调用实现类的write()，StringHttpMessageConverter的write()方法
          *    把字符按照指定的编码处理 text/plain;charset=ISO-8859-1
          *  3.框架会调用@ResponseBody把2的结果数据输出到浏览器， ajax请求处理完成
          * */
          @RequestMapping(value = "/returnStringData.do", produces = "text/plain;charset=utf-8")
          @ResponseBody
          public String doStringData(){
              return "Hello SpringMVC 返回String对象，表示数据";
          }
      }
      ```

      Step2：index 页面

      ```jsp
      <%@ page contentType="text/html;charset=UTF-8" language="java" %>
      <html>
      <head>
          <title>Title</title>
          <script type="text/javascript" src="js/jquery-3.6.0.js"></script>
          <script type="text/javascript">
              $(function (){
                  $("#btn").click(function (){
                      $.ajax({
                          url:"returnStringData.do",
                          type:"post",
                          dataType:"text",
                          success:function (resp){
                              alert("返回的是文本数据：" + resp);
                          }
                      })
                  })
              })
          </script>
      </head>
      <body>
          <button id="btn">发起ajax请求</button>
      </body>
      </html>
      ```

###### 3.5 小结

```
ch04-return: 处理器方法的返回值表示请求的处理结果
1.ModelAndView: 有数据和视图，对视图执行forward。
2.String:表示视图，可以逻辑名称，也可以是完整视图路径
3.void: 不能表示数据，也不能表示视图。
  在处理ajax的时候，可以使用void返回值。 通过HttpServletResponse输出数据。响应ajax请求。
  ajax请求服务器端返回的就是数据，和视图无关。
4.Object：例如String，Integer，Map，List，Student等等都是对象，
  对象有属性，属性就是数据。所以返回Object表示数据，和视图无关。
  可以使用对象表示的数据，响应ajax请求。

  现在做ajax，主要使用json的数据格式。实现步骤：
   1.加入处理json的工具库的依赖，springmvc默认使用的jackson。
   2.在sprigmvc配置文件之间加入 <mvc:annotation-driven> 注解驱动。
      json = om.writeValueAsString(student);
   3.在处理器方法的上面加入@ResponseBody注解
      response.setContentType("application/json;charset=utf-8");
      PrintWriter pw  = response.getWriter();
      pw.println(json);

  springmvc处理器方法返回Object，可以转为json输出到浏览器，响应ajax的内部原理
  1.<mvc:annotation-driven> 注解驱动。
     注解驱动实现的功能是 完成java对象到json，xml，text，二进制等数据格式的转换。
     <mvc:annotation-driven>在加入到springmvc配置文件后，会自动创建HttpMessageConverter接口
     的7个实现类对象， 包括 MappingJackson2HttpMessageConverter （使用jackson工具库中的ObjectMapper实现java对象转为json字符串）

     HttpMessageConverter接口：消息转换器。
     功能：定义了java转为json，xml等数据格式的方法。 这个接口有很多的实现类。
           这些实现类完成 java对象到json，java对象到xml，java对象到二进制数据的转换

     下面的两个方法是控制器类把结果输出给浏览器时使用的：
     boolean canWrite(Class<?> var1, @Nullable MediaType var2);
     void write(T var1, @Nullable MediaType var2, HttpOutputMessage var3)

     例如处理器方法
     @RequestMapping(value = "/returnString.do")
     public Student doReturnView2(HttpServletRequest request, String name, Integer age){
             Student student = new Student();
             student.setName("lisi");
             student.setAge(20);
             return student;
     }

     1）canWrite作用检查处理器方法的返回值，能不能转为var2表示的数据格式。
       检查student(lisi，20)能不能转为var2表示的数据格式。如果检查能转为json，canWrite返回true
       MediaType：表示数格式的，例如json，xml等等

     2）write：把处理器方法的返回值对象，调用jackson中的ObjectMapper转为json字符串。
       json  = om.writeValueAsString(student);

  2.@ResponseBody注解
     放在处理器方法的上面，通过HttpServletResponse输出数据，响应ajax请求的。
           PrintWriter pw  = response.getWriter();
           pw.println(json);
           pw.flush();
           pw.close();

=====================================================================================
没有加入注解驱动标签<mvc:annotation-driven /> 时的状态
org.springframework.http.converter.ByteArrayHttpMessageConverter
org.springframework.http.converter.StringHttpMessageConverter
org.springframework.http.converter.xml.SourceHttpMessageConverter
org.springframework.http.converter.support.AllEncompassingFormHttpMessageConverter

加入注解驱动标签时<mvc:annotation-driven />的状态
org.springframework.http.converter.ByteArrayHttpMessageConverter
org.springframework.http.converter.StringHttpMessageConverter
org.springframework.http.converter.ResourceHttpMessageConverter
org.springframework.http.converter.ResourceRegionHttpMessageConverter
org.springframework.http.converter.xml.SourceHttpMessageConverter
org.springframework.http.converter.support.AllEncompassingFormHttpMessageConverter
org.springframework.http.converter.xml.Jaxb2RootElementHttpMessageConverter
org.springframework.http.converter.json.MappingJackson2HttpMessageConverter
```



##### 4 解读<url-pattern/  >

###### 4.1 配置详解

1. ***.do**

   在没有特殊要求的情况下，SpringMVC 的中央调度器 DispatcherServlet 的 <url-pattern/ >
   常使用后辍匹配方式，如写为*.do 或者 *.action，*.mvc 等。

2. **/**

   可以写为/，因为 DispatcherServlet 会将向静态资源的获取请求，例如 .css、.js、.jpg、.png
   等资源的获取请求，当作是一个普通的 Controller 请求。中央调度器会调用处理器映射器为
   其查找相应的处理器。当然也是找不到的，所以在这种情况下，所有的静态资源获取请求也
   均会报 404 错误。



在 index.jsp 页面中存在一个访问图片的链接。

该项目用于演示将<url-pattern/ >写为 *.do
可以访问到该图片

而写为/，则无法访问(导致静态资源访问失败404，动态资源可以正常访问)。

```xml
发起的请求是由哪些服务器程序处理的。
http://localhost:8080/ch05_url_pattern/index.jsp ：tomcat（jsp会转为servlet）
http://localhost:8080/ch05_url_pattern/js/jquery-3.4.1.js ： tomcat
http://localhost:8080/ch05_url_pattern/images/p1.jpg ： tomcat
http://localhost:8080/ch05_url_pattern/html/test.html： tomcat
http://localhost:8080/ch05_url_pattern/some.do ：  DispatcherServlet（springmvc框架处理的）

tomcat本身能处理静态资源的访问，像html，图片，js文件都是静态资源
tomcat的web.xml文件有一个servlet 名称是 default ， 在服务器启动时创建的。
 	<servlet>
        <servlet-name>default</servlet-name>
        <servlet-class>org.apache.catalina.servlets.DefaultServlet</servlet-class>
        <init-param>
            <param-name>debug</param-name>
            <param-value>0</param-value>
        </init-param>
        <init-param>
            <param-name>listings</param-name>
            <param-value>false</param-value>
        </init-param>
        <load-on-startup>1</load-on-startup>
    </servlet>
	<servlet-mapping>
        <servlet-name>default</servlet-name>
        <url-pattern>/</url-pattern>  <!--表示静态资源和未映射的请求都这个default处理-->
    </servlet-mapping>

default这个servlet作用： 
1.处理静态资源
2.处理未映射到其它servlet的请求。
```



###### 4.2 静态资源访问

<url-pattern/ >的值并不是说写为/后，静态资源就无法访问了。经过一些配置后，该问
题也是可以解决的。

1. 使用<mvc:default-servlet-handler/ >

   声明了 <mvc:default-servlet-handler / > 后，springmvc 框架会在容器中创建
   DefaultServletHttpRequestHandler 处理器对象。它会像一个检查员，对进入 DispatcherServlet
   的 URL 进行筛查，如果发现是静态资源的请求，就将该请求转由 Web 应用服务器默认的
   Servlet 处理。一般的服务器都有默认的 Servlet。

   在 Tomcat 中，有一个专门用于处理静态资源访问的 Servlet 名叫 DefaultServlet。其
   <servlet-name/ >为 default。可以处理各种静态资源访问请求。该 Servlet 注册在 Tomcat 服务
   器的 web.xml 中。在 Tomcat 安装目录/conf/web.xml。

   ![image-20220306165340345](https://cdn.jsdelivr.net/gh/xukang0509/picgo_bed/img/202203132339469.png)

   

   只需要在 springmvc.xml 中添加<mvc:default-servlet-handler/ >标签即可。

   ![image-20220306165704702](https://cdn.jsdelivr.net/gh/xukang0509/picgo_bed/img/202203132340943.png)

   <mvc:default-servlet-handler/ >表示使用 DefaultServletHttpRequestHandler 处理器对象。
   而该处理器调用了 Tomcat 的 DefaultServlet 来处理静态资源的访问请求。

   当然了，要想使用<mvc: …/>标签，需要引入 mvc 约束

   ![image-20220306165818200](https://cdn.jsdelivr.net/gh/xukang0509/picgo_bed/img/202203132340092.png)

   该约束可从 Spring 帮助文档中搜索关键字 spring-mvc.xsd 即可获取：

   docs/spring-framework-reference/htmlsingle/index.html

   

   解决动态资源和静态资源冲突的问题，在 springmvc 配置文件中声明注解驱动

   ![image-20220306170334023](https://cdn.jsdelivr.net/gh/xukang0509/picgo_bed/img/202203132340502.png)

   

2. 使用<mvc:resources/ >

   在 Spring3.0 版本后，Spring 定义了专门用于处理静态资源访问请求的处理器
   ResourceHttpRequestHandler。并且添加了<mvc:resources/ >标签，专门用于解决静态资源无
   法访问的问题。需要在 springmvc 配置文件中添加如下形式的配置：

   ![image-20220306172631758](https://cdn.jsdelivr.net/gh/xukang0509/picgo_bed/img/202203132340565.png)

   

   解决动态资源和静态资源冲突的问题，在 springmvc 配置文件中声明注解驱动

   ![image-20220306172715088](https://cdn.jsdelivr.net/gh/xukang0509/picgo_bed/img/202203132340875.png)

    ![image-20220306172937951](https://cdn.jsdelivr.net/gh/xukang0509/picgo_bed/img/202203132340946.png)

    

##### 5 绝对地址和相对地址

```
在jsp，html中使用的地址，都是在前端页面中的地址，都是相对地址
地址分类：
 1.绝对地址，带有协议名称的是绝对地址，http://www.baidu.com, ftp://202.122.23.1
 2.相对地址，没有协议开头的，例如 user/some.do, /user/some.do
            相对地址不能独立使用，必须有一个参考地址。通过参考地址+相对地址本身才能指定资源。
 3.参考地址
    1） 在你的页面中的，访问地址不加 "/"
	   访问的是：http://localhost:8080/ch06_path/index.jsp
	   路径：http://localhost:8080/ch06_path/
	   资源：index.jsp
    在index.jsp发起 user/some.do 请求，访问地址变为 http://localhost:8080/ch06_path/user/some.do
	当你的地址没有斜杠开头,例如 user/some.do，
	当你点击链接时，访问地址 = 当前页面的地址 + 链接的地址。
	http://localhost:8080/ch06_path/ + user/some.do
    
    -------------------------------------------------------------
	index.jsp 访问 user/some.do，返回后现在的地址：http://localhost:8080/ch06_path/user/some.do
	http://localhost:8080/ch06_path/user/some.do
	路径：http://localhost:8080/ch06_path/user/
	资源：some.do

	在index.jsp 再点击 user/some.do，就变为 http://localhost:8080/ch06_path/user/user/some.do

	解决方案：
	1.加入${pageContext.request.contextPath}
	2.加入一个base标签，是html语言中的标签。 表示当前页面中访问地址的基地址。
	  你的页面中所有没有“/”开头的地址，都是以base标签中的地址为参考地址
	  使用base中的地址 + user/some.do 组成访问地址

   2）在你的页面中的，访问地址加 "/"
      访问的是：http://localhost:8080/ch06_path/index.jsp
	  路径：http://localhost:8080/ch06_path/
	  资源：index.jsp

	  点击 /user/some.do, 访问地址变为 http://localhost:8080/user/some.do
	  参考地址是 你的服务器地址， 也就是 http://localhost:8080

	  如果你的资源不能访问： 加入${pageContext.request.contextPath}
		<a href="${pageContext.request.contextPath}/user/some.do">发起user/some.do的get请求</a>

index.jsp--addStudent.jsp---student/addStudent.do( service的方法，调用dao的方法)--result.jsp
```

![image-20220306175324876](https://cdn.jsdelivr.net/gh/xukang0509/picgo_bed/img/202203132340773.png)



### 三、SSM 整合开发

SSM 编程，即 SpringMVC + Spring + MyBatis 整合，是当前最为流行的 JavaEE 开发技术架
构。其实 SSM 整合的实质，仅仅就是将 MyBatis 整合入 Spring。因为 SpringMVC原本就是 Spring
的一部分，不用专门整合。

SSM 整合的实现方式可分为两种：基于 XML 配置方式，基于注解方式。

SSM整合注解开发

```
SSM整合开发。
SSM：SpringMVC + Spring + MyBatis.

SpringMVC:视图层，界面层，负责接收请求，显示处理结果的。
Spring：业务层，管理service，dao，工具类对象的。
MyBatis：持久层，访问数据库的

用户发起请求-->SpringMVC接收-->Spring中的Service对象-->MyBatis处理数据

SSM整合也叫做SSI (IBatis也就是mybatis的前身)，整合中有容器。
1.第一个容器SpringMVC容器，管理Controller控制器对象的。
2.第二个容器Spring容器，管理Service、Dao、工具类对象的
我们要做的把使用的对象交给合适的容器创建，管理。把Controller还有web开发的相关对象
交给springmvc容器，这些web用的对象写在springmvc配置文件中
service，dao对象定义在spring的配置文件中，让spring管理这些对象。

springmvc容器和spring容器是有关系的，关系已经确定好了
springmvc容器是spring容器的子容器，类似java中的继承。子可以访问父的内容；
在子容器中的Controller可以访问父容器中的Service对象，就可以实现controller使用service对象

实现步骤：
0.使用springdb的mysql库，表使用student（id auto_increment, name, age）
1.新建maven web项目
2.加入依赖
  springmvc，spring，mybatis三个框架的依赖，jackson依赖，mysql驱动，druid连接池
  jsp，servlet依赖
3.写web.xml
    1)注册DispatcherServlet ,目的：
            1.创建springmvc容器对象，才能创建Controller类对象。
            2.创建的是Servlet，才能接受用户的请求。
    2）注册spring的监听器：ContextLoaderListener，目的：创建spring的容器对象，才能创建service，dao等对象。
    3）注册字符集过滤器，解决post请求乱码的问题。
4.创建包，controller，service，dao，实体类(domain)包名创建好
5.写springmvc，spring，mybatis的配置文件
    1）springmvc配置文件
    2）spring配置文件
    3）mybatis主配置文件
    4）数据库的属性配置文件
6.写代码，dao接口和mapper文件，service和实现类，controller，实体类
7.写jsp页面
```

##### 1 建表Student

student 表

![image-20220308190135375](https://cdn.jsdelivr.net/gh/xukang0509/picgo_bed/img/202203132340121.png)



##### 2 新建 web 工程

骨架：maven-archetype-webapp

工程名称：ssm



##### 3 maven 依赖

pom.xml

```xml
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
  <modelVersion>4.0.0</modelVersion>

  <groupId>com.ssm</groupId>
  <artifactId>ch07-SSM</artifactId>
  <version>1.0-SNAPSHOT</version>
  <packaging>war</packaging>

  <properties>
    <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
    <maven.compiler.source>1.8</maven.compiler.source>
    <maven.compiler.target>1.8</maven.compiler.target>
  </properties>

  <dependencies>
    <dependency>
      <groupId>junit</groupId>
      <artifactId>junit</artifactId>
      <version>4.11</version>
      <scope>test</scope>
    </dependency>
    <!--servlet依赖-->
    <dependency>
      <groupId>javax.servlet</groupId>
      <artifactId>javax.servlet-api</artifactId>
      <version>3.1.0</version>
      <scope>provided</scope>
    </dependency>
    <!-- jsp依赖 -->
    <dependency>
      <groupId>javax.servlet.jsp</groupId>
      <artifactId>jsp-api</artifactId>
      <version>2.2.1-b03</version>
      <scope>provided</scope>
    </dependency>
    <!--springmvc-->
    <dependency>
      <groupId>org.springframework</groupId>
      <artifactId>spring-webmvc</artifactId>
      <version>5.2.5.RELEASE</version>
    </dependency>
    <!--事务的-->  
    <dependency>
      <groupId>org.springframework</groupId>
      <artifactId>spring-tx</artifactId>
      <version>5.2.5.RELEASE</version>
    </dependency>
    <dependency>
      <groupId>org.springframework</groupId>
      <artifactId>spring-jdbc</artifactId>
      <version>5.2.5.RELEASE</version>
    </dependency>
    <!--jackson-->
    <dependency>
      <groupId>com.fasterxml.jackson.core</groupId>
      <artifactId>jackson-core</artifactId>
      <version>2.9.0</version>
    </dependency>
    <dependency>
      <groupId>com.fasterxml.jackson.core</groupId>
      <artifactId>jackson-databind</artifactId>
      <version>2.9.0</version>
    </dependency>
     <!--mybatis 和 spring 整合的-->
    <dependency>
      <groupId>org.mybatis</groupId>
      <artifactId>mybatis-spring</artifactId>
      <version>1.3.1</version>
    </dependency>
    <!--mybatis-->  
    <dependency>
      <groupId>org.mybatis</groupId>
      <artifactId>mybatis</artifactId>
      <version>3.5.1</version>
    </dependency>
    <!--mysql 驱动-->  
    <dependency>
      <groupId>mysql</groupId>
      <artifactId>mysql-connector-java</artifactId>
      <version>5.1.9</version>
    </dependency>
    <!--druid-->  
    <dependency>
      <groupId>com.alibaba</groupId>
      <artifactId>druid</artifactId>
      <version>1.1.12</version>
    </dependency>
  </dependencies>

  <build>
    <resources>
      <resource>
        <directory>src/main/java</directory><!--所在的目录-->
        <includes><!--包括目录下的.properties,.xml 文件都会扫描到-->
          <include>**/*.properties</include>
          <include>**/*.xml</include>
        </includes>
        <filtering>false</filtering>
      </resource>
    </resources>
    <plugins>
      <plugin>
        <artifactId>maven-compiler-plugin</artifactId>
        <version>3.1</version>
        <configuration>
          <source>1.8</source>
          <target>1.8</target>
        </configuration>
      </plugin>
    </plugins>
  </build>
</project>
```



##### 4 定义包，组织程序的结构

![image-20220310192026690](https://cdn.jsdelivr.net/gh/xukang0509/picgo_bed/img/202203132340889.png)



##### 5 编写配置文件

jdbc 属性配置文件 jdbc.properties

```properties
jdbc.url=jdbc:mysql://localhost:3306/bjpowernode
jdbc.username=root
jdbc.password=111
```

Spring 配置文件 applicationContext.xml

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:context="http://www.springframework.org/schema/context"
       xsi:schemaLocation="http://www.springframework.org/schema/beans
       http://www.springframework.org/schema/beans/spring-beans.xsd
       http://www.springframework.org/schema/context
       https://www.springframework.org/schema/context/spring-context.xsd">
    <!--Spring的配置文件，声明Service、dao和其他工具类相关的对象-->

    <!--声明数据源，连接数据库-->
    <context:property-placeholder location="classpath:conf/jdbc.properties" />
    <bean id="dataSource" class="com.alibaba.druid.pool.DruidDataSource"
          init-method="init" destroy-method="close">
        <property name="url" value="${jdbc.url}" />
        <property name="username" value="${jdbc.username}" />
        <property name="password" value="${jdbc.password}" />
        <property name="maxActive" value="20" />
    </bean>

    <!--SqlSessionFactoryBean 创建 SqlSessionFactory -->
    <bean id="sqlSessionFactory" class="org.mybatis.spring.SqlSessionFactoryBean" >
        <property name="dataSource" ref="dataSource" />
        <property name="configLocation" value="classpath:conf/mybatis.xml" />
    </bean>

    <!--声明myBatis的扫描器，创建dao对象-->
    <bean class="org.mybatis.spring.mapper.MapperScannerConfigurer" >
        <property name="sqlSessionFactoryBeanName" value="sqlSessionFactory" />
        <property name="basePackage" value="com.ssm.dao" />
    </bean>

    <!--声明service的注解 @Service 所在的包名位置-->
    <context:component-scan base-package="com.ssm.service" />

    <!--事务配置：注解的配置，aspectj的配置-->
</beans>
```

Springmvc 配置文件：dispatcherServlet.xml

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:context="http://www.springframework.org/schema/context"
       xmlns:mvc="http://www.springframework.org/schema/mvc"
       xsi:schemaLocation="http://www.springframework.org/schema/beans
       http://www.springframework.org/schema/beans/spring-beans.xsd
       http://www.springframework.org/schema/context
       https://www.springframework.org/schema/context/spring-context.xsd
       http://www.springframework.org/schema/mvc
       https://www.springframework.org/schema/mvc/spring-mvc.xsd">

    <!--SpringMVC的配置文件，声明controller和其他web相关的对象-->
    <!--Controller层 组件扫描器-->
    <context:component-scan base-package="com.ssm.controller" />

    <!--视图解析器-->
    <bean class="org.springframework.web.servlet.view.InternalResourceViewResolver" >
        <property name="prefix" value="/WEB-INF/jsp/" />
        <property name="suffix" value=".jsp" />
    </bean>

    <!--注解驱动-->
    <!-- 1.响应ajax请求，返回json -->
    <!-- 2.解决静态资源访问问题 -->
    <mvc:annotation-driven />
</beans>
```

mybatis.xml

```xml
<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE configuration
        PUBLIC "-//mybatis.org//DTD Config 3.0//EN"
        "http://mybatis.org/dtd/mybatis-3-config.dtd">
<configuration>
    <settings>
        <!--设置mybatis输出日志-->
        <setting name="logImpl" value="STDOUT_LOGGING" />
    </settings>

    <!--设置别名-->
    <typeAliases>
        <!--name：实体类所在的包名-->
        <package name="com.ssm.domain"/>
    </typeAliases>

    <mappers>
        <!-- name：是包名，这个包中的所有 mapper.xml 一次都能加载 -->
        <!--
            使用package的要求：
                1.mapper文件名称和dao接口名必须完全一样，包括大小写
                2.mapper文件和dao接口必须在同一目录
        -->
        <package name="com.ssm.dao"/>
    </mappers>
</configuration>
```



##### 6 定义 web.xml

1. 注册 ContextLoaderListener
2. 注册 DisatcherServlet
3. 注册字符集过滤器
4. 同时创建 Spring 的配置文件和 SpringMVC 的配置文件

```xml
<?xml version="1.0" encoding="UTF-8"?>
<web-app xmlns="http://xmlns.jcp.org/xml/ns/javaee"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/javaee
         http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd"
         version="4.0">

    <!--中央调度器-->
    <servlet>
        <servlet-name>springmvc</servlet-name>
        <servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>
        <init-param>
            <param-name>contextConfigLocation</param-name>
            <param-value>classpath:conf/dispatcherServlet.xml</param-value>
        </init-param>
        <load-on-startup>1</load-on-startup>
    </servlet>
    <servlet-mapping>
        <servlet-name>springmvc</servlet-name>
        <url-pattern>*.do</url-pattern>
    </servlet-mapping>
    
    <!--注册spring的监听器-->
    <context-param>
        <param-name>contextConfigLocation</param-name>
        <param-value>classpath:conf/applicationContext.xml</param-value>
    </context-param>
    <listener>
        <listener-class>org.springframework.web.context.ContextLoaderListener</listener-class>
    </listener>

    <!--注册字符集过滤器-->
    <filter>
        <filter-name>characterEncodingFilter</filter-name>
        <filter-class>org.springframework.web.filter.CharacterEncodingFilter</filter-class>
        <init-param>
            <param-name>encoding</param-name>
            <param-value>utf-8</param-value>
        </init-param>
        <init-param>
            <param-name>forceRequestEncoding</param-name>
            <param-value>true</param-value>
        </init-param>
        <init-param>
            <param-name>forceResponseEncoding</param-name>
            <param-value>true</param-value>
        </init-param>
    </filter>
    <filter-mapping>
        <filter-name>characterEncodingFilter</filter-name>
        <url-pattern>/*</url-pattern>
    </filter-mapping>
</web-app>
```



##### 7 实体类Student

```java
package com.ssm.domain;
public class Student {
    private Integer id;
    private String name;
    private Integer age;

    public Integer getId() { return id; }
    public void setId(Integer id) { this.id = id; }
    public String getName() { return name; }
    public void setName(String name) { this.name = name; }
    public Integer getAge() { return age; }
    public void setAge(Integer age) { this.age = age; }
    @Override
    public String toString() {
        return "Student{" + "id=" + id + ", name='" + name + '\'' + ", age=" + age + '}';
    }
}
```



##### 8 Dao 接口和 sql 映射文件

```java
package com.ssm.dao;
import com.ssm.domain.Student;
import java.util.List;
public interface StudentDao {
    int insertStudent(Student student);
    List<Student> selectStudents();
}
```

StudentDao.xml

```xml
<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE mapper
        PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
        "http://mybatis.org/dtd/mybatis-3-mapper.dtd">
<mapper namespace="com.ssm.dao.StudentDao">
    <select id="selectStudents" resultType="com.ssm.domain.Student">
        select id, name, age from student order by id asc
    </select>

    <insert id="insertStudent">
        insert into student(name,age) values(#{name},#{age})
    </insert>
</mapper>
```



##### 9 Service 接口和实现类

```java
package com.ssm.service;
import com.ssm.domain.Student;
import java.util.List;
public interface StudentService {
    int addStudent(Student student);
    List<Student> findStudents();
}
```

```java
package com.ssm.service.impl;
import com.ssm.dao.StudentDao;
import com.ssm.domain.Student;
import com.ssm.service.StudentService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import java.util.List;
@Service
public class StudentServiceImpl implements StudentService {
    //引用类型自动注入@Autowired, @Resource
    @Autowired
    private StudentDao studentDao;

    @Override
    public int addStudent(Student student) {
        int nums = studentDao.insertStudent(student);
        return nums;
    }

    @Override
    public List<Student> findStudents() {
        return studentDao.selectStudents();
    }
}
```



##### 10 处理器类

```java
package com.ssm.controller;

@Controller
@RequestMapping("/student")
public class StudentController {
    @Resource
    private StudentService service;

    //注册学生
    @RequestMapping("/addStudent.do")
    public ModelAndView addStudent(Student student){
        ModelAndView mv = new ModelAndView();
        String tips = "注册失败";
        //调用service处理student
        int nums = service.addStudent(student);
        if(nums > 0){
            tips = "学生【" + student.getName() + "】注册成功！";
        }
        //添加数据
        mv.addObject("tips", tips);
        //指定结果页面
        mv.setViewName("result");
        return mv;
    }

    //处理查询，响应ajax
    @RequestMapping("/queryStudent.do")
    @ResponseBody
    public List<Student> queryStudents(){
        //参数检查，简单的处理数据
        List<Student> students = service.findStudents();
        return students;
    }
}
```



##### 11 定义视图-首页文件--- index.jsp

```jsp
<%@ page contentType="text/html;charset=UTF-8" language="java" %>
<%
  String basePath = request.getScheme() + "://" +
          request.getServerName() + ":" + request.getServerPort() +
          request.getContextPath() + "/";
%>
<html>
<head>
    <title>功能入口</title>
    <base href="<%=basePath%>" />
</head>
<body>
  <div align="center" >
    <p>SSM整合的例子</p>
    <img src="images/ssm.jpg">
    <table>
      <tr>
        <td><a href="addStduent.jsp">注册学生</a></td>
      </tr>
      <tr>
        <td><a href="listStudent.jsp">浏览学生</a></td>
      </tr>
    </table>
  </div>

</body>
</html>
```

![image-20220310193953091](https://cdn.jsdelivr.net/gh/xukang0509/picgo_bed/img/202203132340481.png)



##### 12 注册学生页面 --- addStudent.jsp

```jsp
<%@ page contentType="text/html;charset=UTF-8" language="java" %>
<%
    String basePath = request.getScheme() + "://" +
            request.getServerName() + ":" + request.getServerPort() +
            request.getContextPath() + "/";
%>
<html>
<head>
    <title>注册学生</title>
    <base href="<%=basePath%>" />
</head>
<body>
<div align="center">
    <form action="student/addStudent.do" method="post">
        <table>
            <tr>
                <td>姓名：</td>
                <td><input type="text" name="name"></td>
            </tr>
            <tr>
                <td>年龄：</td>
                <td><input type="text" name="age"></td>
            </tr>
            <tr>
                <td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td>
                <td><input type="submit" value="注册"></td>
            </tr>
        </table>
    </form>
</div>
</body>
</html>
```

![image-20220310194015907](https://cdn.jsdelivr.net/gh/xukang0509/picgo_bed/img/202203132340864.png)



##### 13 浏览学生页面 --- listStudent.jsp

```jsp
<%@ page contentType="text/html;charset=UTF-8" language="java" %>
<%
    String basePath = request.getScheme() + "://" +
            request.getServerName() + ":" + request.getServerPort() +
            request.getContextPath() + "/";
%>
<html>
<head>
    <title>查询学生ajax</title>
    <base href="<%=basePath%>" />
    <script type="text/javascript" src="js/jquery-3.6.0.js"></script>
    <script type="text/javascript">
        $(function (){
            // 在当前页面dom对象加载后，执行loadStudentData()
            loadStudentData();
            $("#btnLoader").click(function (){
                loadStudentData();
            })
        })

        function loadStudentData(){
            $.ajax({
                url:"student/queryStudent.do",
                type:"get",
                dataType:"json",
                success:function (data){
                    // 清除旧的数据
                    $("#info").html("");
                    //增加新的数据
                    $.each(data, function (i, n){
                        $("#info").append("<tr>")
                            .append("<td>"+ n.id + "</td>")
                            .append("<td>"+ n.name + "</td>")
                            .append("<td>"+ n.age + "</td>")
                            .append("</tr>")
                    })
                }
            })
        }
    </script>
</head>
<body>
    <div align="center">
        <table border="1px">
            <thead>
            <tr>
                <td>学号</td>
                <td>姓名</td>
                <td>年龄</td>
            </tr>
            </thead>
            <tbody id="info">

            </tbody>
        </table>
        <input type="button" id="btnLoader" value="查询数据">
    </div>
</body>
</html>
```



##### 14 结果页面--- result.jsp

```jsp
<%@ page contentType="text/html;charset=UTF-8" language="java" %>
<html>
<head>
    <title>Title</title>
</head>
<body>
result.jsp 结果页面，注册结果：${tips}
</body>
</html>
```

![image-20220310194104655](https://cdn.jsdelivr.net/gh/xukang0509/picgo_bed/img/202203132340498.png)



### 四、SpringMVC 核心技术

##### 1 请求重定向和转发

​		当处理器对请求处理完毕后，向其它资源进行跳转时，有两种跳转方式：请求转发与重
定向。而根据所要跳转的资源类型，又可分为两类：跳转到页面与跳转到其它处理器。

​		注意，对于请求转发的页面，可以是WEB-INF中页面；而重定向的页面，是不能为 WEB-INF中页面的。因为重定向相当于用户再次发出一次请求，而用户是不能直接访问 WEB-INF 中资
源的。

![image-20220312200218987](https://cdn.jsdelivr.net/gh/xukang0509/picgo_bed/img/202203132340413.png)

​		

​		SpringMVC 框架把原来 Servlet 中的请求转发和重定向操作进行了封装。

​		现在可以使用简
单的方式实现转发和重定向。

​		forward: 表示转发，实现 request.getRequestDispatcher("xx.jsp").forward()

​		redirect: 表示重定向，实现 response.sendRedirect("xxx.jsp")



###### 1.1 请求转发

​		处理器方法返回 ModelAndView 时，需在 setViewName() 指定的视图前添加 forward:，且
此时的视图不再与视图解析器一同工作，这样可以在配置了解析器时指定不同位置的视图。
视图页面必须写出相对于项目根的路径。forward 操作不需要视图解析器。

​		处理器方法返回 String，在视图路径前面加入 forward: 视图完整路径。

```java
package com.springmvc.controller;

import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestMethod;
import org.springframework.web.servlet.ModelAndView;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import javax.servlet.http.HttpSession;

/*
 * 处理器方法返回ModelAndView，实现转发forward
 * 语法：setViewName("forward:视图文件完整路径")
 * 特点：不和视图解析器一同使用，就当项目中没有视图解析器
 */
@Controller
public class MyController {
    @RequestMapping(value = "/doForward.do", method = RequestMethod.POST)
    public ModelAndView doSome(){
        ModelAndView mv  = new ModelAndView();
        mv.addObject("msg","欢迎使用springmvc做web开发");
        mv.addObject("fun","执行的是doSome方法");
        // 显示转发
        //mv.setViewName("forward:/WEB-INF/jsp/show.jsp");
        mv.setViewName("forward:/other.jsp");// 解除视图解析器的限制
        return mv;
    }
}
```



###### 1.2 请求重定向

在处理器方法返回的视图字符串的前面添加 redirect:，则可实现重定向跳转。

```jsp
index.jsp
	<P>当出来方法返回ModelAndView实现redirect</P>
    <form action="doRedirect.do" method="post" >
        姓名：<input type="text" name="name"><br>
        年龄：<input type="text" name="age" ><br>
        <input type="submit" value="提交请求">
    </form>
```

```java
MyController.java
	/*
     * 处理器方法返回ModelAndView，实现重定向redirect
     * 语法：setViewName("redirect:视图文件完整路径")
     * redirect特点：不和视图解析器一同使用，就当项目中没有视图解析器
     *
     * 框架对重定向的操作：
     * 1.框架会把Model中的简单类型的数据，转为string使用，作为hello.jsp的get请求参数使用。
     *   目的是在 doRedirect.do 和 hello.jsp 两次请求之间传递数据
     * 2.在目标hello.jsp页面可以使用参数集合对象 ${param}获取请求参数值
     *    ${param.myname}
     * 3.重定向不能访问/WEB-INF资源
     */
    @RequestMapping(value = "/doRedirect.do", method = RequestMethod.POST)
    public ModelAndView doOther(String name, Integer age){
        ModelAndView mv  = new ModelAndView();
        mv.addObject("myName",name);
        mv.addObject("myAge",age);
        // 重定向
        mv.setViewName("redirect:/hello.jsp");
        // http://localhost:8080/ch08_forward/hello.jsp?myName=岳云&myAge=22
        //重定向不能访问/WEB-INF资源
        //mv.setViewName("redirect:/WEB-INF/view/show.jsp");
        return mv;
    }
```

```jsp
hello.jsp
<%@ page contentType="text/html;charset=UTF-8" language="java" %>
<html>
<head>
    <title>Title</title>
</head>
<body>
  <h4>myName数据:${param.myName}</h4>
  <h4>myAge数据:${param.myAge}</h4>
  <h4>取参数数据:<%=request.getParameter("myName")%></h4>
</body>
</html>
```

![image-20220312205020762](https://cdn.jsdelivr.net/gh/xukang0509/picgo_bed/img/202203132341664.png)

![image-20220312205043268](https://cdn.jsdelivr.net/gh/xukang0509/picgo_bed/img/202203132341463.png)



##### 2 异常处理

​		SpringMVC 框架处理异常的常用方式：使用@ExceptionHandler 注解处理异常。



@ExceptionHandler 注解

​		使用注解@ExceptionHandler 可以将一个方法指定为异常处理方法。该注解只有一个可选属性 value，为一个   Class<?>数组，用于指定该注解的方法所要处理的异常类，即所要匹
配的异常。

​		而被注解的方法，其返回值可以是 ModelAndView、String，或 void，方法名随意，方法
参数可以是 Exception 及其子类对象、HttpServletRequest、HttpServletResponse 等。系统会
自动为这些方法参数赋值。

​		对于异常处理注解的用法，也可以直接将异常处理方法注解于 Controller 之中。



```
异常处理：
springmvc 框架采用的是统一，全局的异常处理。
把controller中的所有异常处理都集中到一个地方。
采用的是aop的思想。把业务逻辑和异常处理代码分开。解耦合。

使用两个注解
1.@ExceptionHandler
2.@ControllerAdvice

异常处理步骤：
1.新建maven web项目
2.加入依赖
3.新建一个自定义异常类 MyUserException , 再定义它的子类NameException, AgeException
4.在controller抛出NameException , AgeException
5.创建一个普通类，作用全局异常处理类
    1) 在类的上面加入@ControllerAdvice
    2) 在类中定义方法，方法的上面加入@ExceptionHandler
6.创建处理异常的视图页面
7.创建springmvc的配置文件
    1）组件扫描器，扫描 @Controller 注解
    2）组件扫描器，扫描 @ControllerAdvice 所在的包名
    3）声明注解驱动
```

###### 2.1 自定义异常类

定义三个异常类：NameException、AgeException、MyUserException。其中 MyUserException
是另外两个异常的父类。

```java
package com.springmvc.exception;
public class MyUserException extends Exception {
    public MyUserException() {}
    public MyUserException(String message) { super(message); }
}
```

```java
package com.springmvc.exception;

//当用户的姓名有异常，抛出NameException
public class NameException extends MyUserException{
    public NameException() { super(); }
    public NameException(String message) { super(message); }
}
```

```java
package com.springmvc.exception;

//当用户的年龄有异常，抛出AgeException
public class AgeException extends MyUserException{
    public AgeException() { super(); }
    public AgeException(String message) { super(message); }
}
```



###### 2.2 修改 Controller 类抛出异常

```java
package com.springmvc.controller;

import com.springmvc.exception.AgeException;
import com.springmvc.exception.MyUserException;
import com.springmvc.exception.NameException;
import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestMethod;
import org.springframework.web.servlet.ModelAndView;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import javax.servlet.http.HttpSession;

@Controller
public class MyController {
    @RequestMapping(value = "/some.do", method = RequestMethod.POST)
    public ModelAndView doSome(String name, Integer age) throws MyUserException {
        ModelAndView mv  = new ModelAndView();
        // 根据请求参数抛出异常
        if(!"zs".equals(name)){
            throw new NameException("姓名不是zs！");
        }
        if(age == null || age > 80){
            throw new AgeException("年龄过大！");
        }
        mv.addObject("myName", name);
        mv.addObject("myAge", age);
        mv.setViewName("show");
        return mv;
    }
}
```



###### 2.3 定义异常响应页面

定义三个异常响应页面。

nameError.jsp

```jsp
<%@ page contentType="text/html;charset=UTF-8" language="java" %>
<html>
<head>
    <title>Title</title>
</head>
<body>
  nameError.jsp<br>
  提示信息：${msg}<br>
  系统异常信息：${exception.message}
</body>
</html>
```

ageError.jsp

```jsp
<%@ page contentType="text/html;charset=UTF-8" language="java" %>
<html>
<head>
    <title>Title</title>
</head>
<body>
  ageError.jsp<br>
  提示信息：${msg}<br>
  系统异常信息：${exception.message}
</body>
</html>
```

defaultError.jsp

```jsp
<%@ page contentType="text/html;charset=UTF-8" language="java" %>
<html>
<head>
    <title>Title</title>
</head>
<body>
  defaultError.jsp<br>
  提示信息：${msg}<br>
  系统异常信息：${exception.message}
</body>
</html>
```



###### 2.4 定义全局异常处理类

```java
package com.springmvc.handler;

import com.springmvc.exception.AgeException;
import com.springmvc.exception.NameException;
import org.springframework.web.bind.annotation.ControllerAdvice;
import org.springframework.web.bind.annotation.ExceptionHandler;
import org.springframework.web.servlet.ModelAndView;
/*
 * @ControllerAdvice : 控制器增强（也就是说给控制器类增加功能----异常处理功能）
 *   位置：在类的上面
 *   特点：必须让框架知道这个注解所在的包名，需要在springmvc配置文件声明组件扫描器。
 *   指定 @Controller 所在的包名
 */
@ControllerAdvice
public class GlobalExceptionHandler {
    /*
     * 定义方法，处理发生的异常
     * 处理异常的方法和控制器方法的定义一样，可以有多个参数；
     * 可以有ModelAndView、String、void、对象类型的返回值
     *
     * 形参：Exception，表示Controller中抛出的异常对象
     * 通过形参可以获取发生的异常信息
     *
     * @ExceptionHandler(对应异常类的class):表示异常的类型，当发生此类异常时，
     * 由当前方法处理。
     */
    @ExceptionHandler(value = NameException.class)
    public ModelAndView doNameException(Exception exception){
        /*
         * 处理NameException异常
         * 异常发生处理逻辑：
         * 1.需要把异常记录下来，记录到数据库，日志文件。
         *   记录日志发生的时间，哪个方法发生的，异常错误内容
         * 2.发送通知，把异常的信息通过邮件，短信，微信发送给相关人员
         * 3.给用户友好的提示
         */
        ModelAndView mv = new ModelAndView();
        mv.addObject("msg", "姓名必须是zs，其他用户不能访问！");
        mv.addObject("exception", exception);
        mv.setViewName("nameError");
        return mv;
    }

    @ExceptionHandler(value = AgeException.class)
    public ModelAndView doAgeException(Exception exception){
        ModelAndView mv = new ModelAndView();
        mv.addObject("msg", "您的年龄不能大于80！");
        mv.addObject("exception", exception);
        mv.setViewName("ageError");
        return mv;
    }

    // 处理其他异常，NameException、AgeException以外，不知类型的异常
    @ExceptionHandler
    public ModelAndView doOtherException(Exception exception){
        ModelAndView mv = new ModelAndView();
        mv.addObject("msg", "其他异常");
        mv.addObject("exception", exception);
        mv.setViewName("defaultError");
        return mv;
    }
}
```



###### 2.5 定义 SpringMVC 配置文件

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:context="http://www.springframework.org/schema/context"
       xmlns:mvc="http://www.springframework.org/schema/mvc"
       xsi:schemaLocation="http://www.springframework.org/schema/beans
       http://www.springframework.org/schema/beans/spring-beans.xsd
       http://www.springframework.org/schema/context
       https://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/mvc https://www.springframework.org/schema/mvc/spring-mvc.xsd">

    <!--声明 springmvc框架中的视图解析器，帮助开发人员设置视图文件的路径-->
    <bean  class="org.springframework.web.servlet.view.InternalResourceViewResolver">
        <!--前缀：视图文件的路径-->
        <property name="prefix" value="/WEB-INF/jsp/" />
        <!--后缀：视图文件的扩展名-->
        <property name="suffix" value=".jsp" />
    </bean>


    <context:component-scan base-package="com.springmvc.controller" />

    <!--处理异常的两步-->
    <!--声明组件扫描器-->
    <context:component-scan base-package="com.springmvc.handler" />
    <!--声明注解驱动-->
    <mvc:annotation-driven />
</beans>
```



##### 3 拦截器

SpringMVC 中的 Interceptor 拦截器是非常重要和相当有用的，它的主要作用是拦截指定的用户请求，并进行相应的预处理与后处理。其拦截的时间点在 “处理器映射器根据用户提
交的请求映射出了所要执行的处理器类，并且也找到了要执行该处理器类的处理器适配器，
在处理器适配器执行处理器之前” 。当然，在处理器映射器映射出所要执行的处理器类时，
已经将拦截器与处理器组合为了一个处理器执行链，并返回给了中央调度器。

```
拦截器：
1）拦截器是springmvc中的一种，需要实现HandlerInterceptor接口。
2）拦截器和过滤器类似，功能方向侧重点不同。 过滤器是用来过滤器请求参数，设置编码字符集等工作。
    拦截器是拦截用户的请求，做请求做判断处理的。
3）拦截器是全局的，可以对多个Controller做拦截。 
   一个项目中可以有0个或多个拦截器， 他们在一起拦截用户的请求。
	拦截器常用在：用户登录处理，权限检查， 记录日志。

拦截器的使用步骤：
 1.定义类实现HandlerInterceptor接口
 2.在springmvc配置文件中，声明拦截器， 让框架知道拦截器的存在。

拦截器的执行时间：
  1）在请求处理之前， 也就是controller类中的方法执行之前先被拦截。
  2）在控制器方法执行之后也会执行拦截器。
  3）在请求处理完成后也会执行拦截器。

拦截器：看做是多个Controller中公用的功能，集中到拦截器统一处理。使用的aop的思想
```



###### 3.1 一个拦截器的执行

```
步骤：
1.新建maven web项目
2.加入依赖
3.创建Controller类
4.创建一个普通类，作为拦截器使用
    1）实现HandlerInterceptor接口
    2）实现接口中的三个方法
5.创建show.jsp
6.创建springmvc的配置文件
    1)组件扫描器 ，扫描@Controller注解
    2)声明拦截器，并指定拦截的请求uri地址
```

```java
package com.springmvc.handler;

import org.springframework.web.servlet.HandlerInterceptor;
import org.springframework.web.servlet.ModelAndView;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.util.Date;

// 拦截器类：拦截用户的请求
public class MyInterceptor implements HandlerInterceptor {
    private long bigTime = 0l;

    /**
     * preHandle:叫做预处理方法
     *   重要：是整个项目的入口，门户。
     *        当preHandle返回true，请求可以被处理
     *        当preHandle返回false，请求到此被截止
     * @param handler 被拦截的控制器对象MyController
     * @return boolean值
     *              true:请求通过了拦截器的验证，可以执行处理器方法
     *                拦截器MyInterceptor的preHandle()方法
     *                MyController中的doSome方法
     *                拦截器MyInterceptor的postHandle()方法
     *                拦截器MyInterceptor的afterCompletion()方法
     *              false:请求没有通过拦截器的验证，请求到达拦截器就截止了，请求没有被处理
     *                拦截器MyInterceptor的preHandle()方法
     * @throws Exception
     * 特点：1.方法在控制器方法(MyController的doSome方法)之前执行的。
     *        用户的请求首先到达此方法
     *      2.在这个方法中可以获取请求的信息，验证请求是否符合要求；
     *        可以验证用户是否登录，验证用户是否有权限访问某个链接地址；
     *        如果验证失败，可以截断请求，请求不能被处理。
     *        如果验证成功，可以放行请求，此时控制器方法才能执行。
     */
    @Override
    public boolean preHandle(HttpServletRequest request, HttpServletResponse response,
                             Object handler) throws Exception {
        bigTime = System.currentTimeMillis();
        System.out.println("拦截器MyInterceptor的preHandle()方法");
        // 计算的业务逻辑，根据计算结果，返回true或者false
        // 给浏览器一个返回结果
        //request.getRequestDispatcher("/tips.jsp").forward(request, response);
        //return fasle;
        return true;
    }

    /**
     * postHandle:后处理方法
     * @param handler 被拦截的处理器对象MyController
     * @param modelAndView mv:处理器方法的返回值
     * 特点：
     *    1.在处理器方法之后执行的（MyController.doSome()）
     *    2.能够获取到处理器方法的返回值ModelAndView，可以修改ModelAndView中的数据和
     *      视图，可以影响到最后的执行结果。
     *    3.主要是对原来的执行结果做二次修正
     */
    @Override
    public void postHandle(HttpServletRequest request, HttpServletResponse response,
                           Object handler, ModelAndView modelAndView) throws Exception {
        HandlerInterceptor.super.postHandle(request, response, handler, modelAndView);
        System.out.println("拦截器MyInterceptor的postHandle()方法");
        // 对原来doSome的执行结果，需要调整
        if(modelAndView != null){
            modelAndView.addObject("myDate", new Date());//修改数据
            modelAndView.setViewName("other");//修改视图
        }
    }

    /**
     * afterCompletion:最后执行的方法
     * @param handler 被拦截的处理器对象
     * @param ex 程序中发生的异常
     * 特点：
     *    1.在请求处理完成后执行的；框架中规定是当你的视图处理完成后，对视图执行了forward，就认为请求处理完成
     *    2.一般做资源回收工作的，程序请求过程中创建了一些对象，在这里可以删除，把占用的内存回收。
     */
    @Override
    public void afterCompletion(HttpServletRequest request, HttpServletResponse response,
                                Object handler, Exception ex) throws Exception {
        System.out.println("拦截器MyInterceptor的afterCompletion()方法");
        long endTime = System.currentTimeMillis();
        System.out.println("计算从preHandle到请求处理完成的时间：" + (endTime - bigTime));
    }
}
```



自定义拦截器，需要实现 HandlerInterceptor 接口。而该接口中含有三个方法：

- preHandle(request, response, Object handler)：该方法在处理器方法执行之前执行。其返回值为 boolean，若为 true，则紧接着会执行处理器方
  法，且会将 afterCompletion()方法放入到一个专门的方法栈中等待执行。
- postHandle(request, response, Object handler, modelAndView)：该方法在处理器方法执行之后执行。处理器方法若最终未被执行，则该方法不会执行。
  由于该方法是在处理器方法执行完后执行，且该方法参数中包含 ModelAndView，所以该方法可以修
  改处理器方法的处理结果数据，且可以修改跳转方向。
- afterCompletion(request, response, Object handler, Exception ex)：当 preHandle() 方法返回 true 时，会将该方法放到专门的方法栈中，等到对请求进行响应的所有
  工作完成之后才执行该方法。即该方法是在中央调度器渲染（数据填充）了响应页面之后执行的，此
  时对 ModelAndView 再操作也对响应无济于事。



**afterCompletion 最后执行的方法，清除资源，例如在 Controller 方法中加入数据**

![image-20220313195423029](https://cdn.jsdelivr.net/gh/xukang0509/picgo_bed/img/202203132341449.png)



拦截器中方法与处理器方法的执行顺序如下图：

![image-20220313195454006](https://cdn.jsdelivr.net/gh/xukang0509/picgo_bed/img/202203132341659.png)



1. 注册拦截器

   在springmvc.xml中注册拦截器

   ```xml
   <?xml version="1.0" encoding="UTF-8"?>
   <beans xmlns="http://www.springframework.org/schema/beans"
          xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
          xmlns:context="http://www.springframework.org/schema/context"
          xmlns:mvc="http://www.springframework.org/schema/mvc"
          xsi:schemaLocation="http://www.springframework.org/schema/beans
          http://www.springframework.org/schema/beans/spring-beans.xsd
          http://www.springframework.org/schema/context
          https://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/mvc https://www.springframework.org/schema/mvc/spring-mvc.xsd">
       <!--声明组件扫描器-->
       <context:component-scan base-package="com.springmvc.controller" />
   
       <!--声明 springmvc框架中的视图解析器，帮助开发人员设置视图文件的路径-->
       <bean  class="org.springframework.web.servlet.view.InternalResourceViewResolver">
           <!--前缀：视图文件的路径-->
           <property name="prefix" value="/WEB-INF/jsp/" />
           <!--后缀：视图文件的扩展名-->
           <property name="suffix" value=".jsp" />
       </bean>
   
       <!--声明拦截器：拦截器可以有0个或多个-->
       <mvc:interceptors>
           <!--声明第一个拦截器-->
           <mvc:interceptor>
               <!--
                   指定拦截的请求uri地址
                   path：就是uri地址，可以使用通配符 **
                       **：表示任意的字符，文件或者多级目录和目录中的文件
                   http://localhost:8080/myweb/user/listUser.do
               -->
               <mvc:mapping path="/user/**" />
               <!--声明拦截器对象-->
               <bean class="com.springmvc.handler.MyInterceptor" />
           </mvc:interceptor>
       </mvc:interceptors>
   </beans>
   ```

2. 修改 index 页面

   ```jsp
   <%@ page contentType="text/html;charset=UTF-8" language="java" %>
   <html>
   <head>
       <title>Title</title>
       <%
           String basePath = request.getScheme() + "://" +
                   request.getServerName() + ":" + request.getServerPort() +
                   request.getContextPath() + "/";
       %>
       <base href="<%=basePath%>" />
   </head>
   <body>
       <P>一个拦截器</P>
       <form action="some.do" method="post" >
           姓名：<input type="text" name="name"><br>
           年龄：<input type="text" name="age" ><br>
           <input type="submit" value="提交请求">
       </form>
       <br>
   </body>
   </html>
   ```

3. 修改处理器

   ```java
   package com.springmvc.controller;
   
   import org.springframework.stereotype.Controller;
   import org.springframework.web.bind.annotation.RequestMapping;
   import org.springframework.web.bind.annotation.RequestMethod;
   import org.springframework.web.servlet.ModelAndView;
   
   @Controller
   public class MyController {
       @RequestMapping(value = "/some.do", method = RequestMethod.POST)
       public ModelAndView doSome(String name, Integer age) {
           System.out.println("MyController中的doSome方法");
           ModelAndView mv  = new ModelAndView();
           mv.addObject("myName", name);
           mv.addObject("myAge", age);
           mv.setViewName("show");
           return mv;
       }
   }
   ```

4. 修改结果页面

   show.jsp

   ```jsp
   <%@ page contentType="text/html;charset=UTF-8" language="java" %>
   <html>
   <head>
       <title>Title</title>
   </head>
   <body>
     <h4>myName数据:${myName}</h4>
     <h4>myAge数据:${myAge}</h4>
   </body>
   </html>
   ```

   other.jsp

   ```jsp
   <%@ page contentType="text/html;charset=UTF-8" language="java" %>
   <html>
   <head>
       <title>Title</title>
   </head>
   <body>
     <h4>myName数据:${myName}</h4>
     <h4>myAge数据:${myAge}</h4>
     <h4>拦截器中增加的数据:${myDate}</h4>
   </body>
   </html>
   ```

   tips.jsp

   ```jsp
   <%@ page contentType="text/html;charset=UTF-8" language="java" %>
   <html>
   <head>
       <title>Title</title>
   </head>
   <body>
     tips.jsp  请求被拦截，不能执行
   </body>
   </html>
   ```



###### 3.2 多个拦截器的执行

1. 建立两个自定义拦截器

   ```java
   package com.bjpowernode.handler;
   
   import org.springframework.web.servlet.HandlerInterceptor;
   import org.springframework.web.servlet.ModelAndView;
   
   import javax.servlet.http.HttpServletRequest;
   import javax.servlet.http.HttpServletResponse;
   import java.util.Date;
   
   //拦截器类：拦截用户的请求。
   public class MyInterceptor implements HandlerInterceptor {
       @Override
       public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {
           System.out.println("111111-拦截器的MyInterceptor的preHandle()");
           return true;
       }
   
       @Override
       public void postHandle(HttpServletRequest request,
                              HttpServletResponse response,
                              Object handler, ModelAndView mv) throws Exception {
           System.out.println("111111-拦截器的MyInterceptor的postHandle()");
       }
   
       @Override
       public void afterCompletion(HttpServletRequest request, HttpServletResponse response,
                                   Object handler, Exception ex) throws Exception {
           System.out.println("111111-拦截器的MyInterceptor的afterCompletion()");
       }
   }
   
   ```

   ```java
   package com.bjpowernode.handler;
   
   import org.springframework.web.servlet.HandlerInterceptor;
   import org.springframework.web.servlet.ModelAndView;
   
   import javax.servlet.http.HttpServletRequest;
   import javax.servlet.http.HttpServletResponse;
   
   //拦截器类：拦截用户的请求。
   public class MyInterceptor2 implements HandlerInterceptor {
       @Override
       public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {
           System.out.println("22222-拦截器的MyInterceptor的preHandle()");
           return true;
       }
   
       @Override
       public void postHandle(HttpServletRequest request,
                              HttpServletResponse response,
                              Object handler, ModelAndView mv) throws Exception {
           System.out.println("22222-拦截器的MyInterceptor的postHandle()");
       }
   
   
       @Override
       public void afterCompletion(HttpServletRequest request, HttpServletResponse response,
                                   Object handler, Exception ex) throws Exception {
           System.out.println("22222-拦截器的MyInterceptor的afterCompletion()");
       }
   }
   ```

2. 多个拦截器的注册与执行

   ```xml
   <?xml version="1.0" encoding="UTF-8"?>
   <beans xmlns="http://www.springframework.org/schema/beans"
          xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
          xmlns:context="http://www.springframework.org/schema/context"
          xmlns:mvc="http://www.springframework.org/schema/mvc"
          xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/mvc https://www.springframework.org/schema/mvc/spring-mvc.xsd">
   
       <!--声明组件扫描器-->
       <context:component-scan base-package="com.bjpowernode.controller" />
   
       <!--视图解析器-->
       <bean  class="org.springframework.web.servlet.view.InternalResourceViewResolver">
           <property name="prefix" value="/WEB-INF/view/" />
           <property name="suffix" value=".jsp" />
       </bean>
   
       <!--在框架中保存多个拦截器是ArrayList，按照声明的先后顺序放入到ArrayList-->
       <mvc:interceptors>
           <!--声明第一个拦截器-->
           <mvc:interceptor>
               <mvc:mapping path="/**"/>
               <bean class="com.bjpowernode.handler.MyInterceptor" />
           </mvc:interceptor>
   
           <!--声明第二个拦截器-->
           <mvc:interceptor>
               <mvc:mapping path="/**"/>
               <bean class="com.bjpowernode.handler.MyInterceptor2" />
           </mvc:interceptor>
       </mvc:interceptors>
   </beans>
   ```

3. 控制台执行结果

   当有多个拦截器时，形成拦截器链。拦截器链的执行顺序，与其注册顺序一致。需要再
   次强调一点的是，当某一个拦截器的 preHandle()方法返回 true 并被执行到时，会向一个专
   门的方法栈中放入该拦截器的 afterCompletion()方法。

   多个拦截器中方法与处理器方法的执行顺序如下图：

   ![image-20220313202745230](https://cdn.jsdelivr.net/gh/xukang0509/picgo_bed/img/202203132341342.png)

   从图中可以看出，只要有一个 preHandle()方法返回 false，则上部的执行链将被断开，
   其后续的处理器方法与 postHandle()方法将无法执行。但，无论执行链执行情况怎样，只要
   方法栈中有方法，即执行链中只要有 preHandle()方法返回 true，就会执行方法栈中的
   afterCompletion()方法。最终都会给出响应。

   ```
   多个拦截器：
   第一个拦截器preHandle=true , 第二个拦截器preHandle=true 
   
   111111-拦截器的MyInterceptor的preHandle()
   22222-拦截器的MyInterceptor的preHandle()
   =====执行MyController中的doSome方法=====
   22222-拦截器的MyInterceptor的postHandle()
   111111-拦截器的MyInterceptor的postHandle()
   22222-拦截器的MyInterceptor的afterCompletion()
   111111-拦截器的MyInterceptor的afterCompletion()
   
   ---------------------------------------------------
   第一个拦截器preHandle=true , 第二个拦截器preHandle=false
   
   111111-拦截器的MyInterceptor的preHandle()
   22222-拦截器的MyInterceptor的preHandle()
   111111-拦截器的MyInterceptor的afterCompletion()
   
   ----------------------------------------------------------
   第一个拦截器preHandle=false , 第二个拦截器preHandle=true|false
   
   111111-拦截器的MyInterceptor的preHandle()
   ```



###### 3.3 拦截器与过滤器的区别

1. 过滤器是servlet的对象，拦截器是框架中的对象。

2. 过滤器实现Filter接口的对象，拦截器是实现HandlerInterctor

3. 过滤器是用来设置request、response的参数、属性的，侧重是对数据过滤；

   拦截器是用来验证请求的，能截断请求。

4. 过滤器是在拦截器之前执行的。

5. 过滤器是Tomcat服务器创建的对象；

   拦截器是SpringMVC容器中创建的对象。

6. 过滤器只有一个执行时间点；

   拦截器有三个执行时间点。

7. 过滤器可以处理jsp、js、html等等；

   拦截器是侧重拦截对Controller的请求；如果你的请求不能被DispatcherServlet接收，这个请求不会执行拦截器内容。

8. 拦截器拦截普通类方法执行，过滤器过滤servlet请求响应。



###### 3.4 权限拦截器举例

```
使用拦截器检查登录的用户是不是能访问系统
实现步骤：
1.新建maven
2.修改web.xml注册中央调度器
3.新建index.jsp发起请求
4.创建MyController处理请求
5.创建结果show.jsp
6.创建一个login.jsp，模拟登录（把用户的信息放入到session）；
  创建一个jsp，logout.jsp，模拟退出系统（从session中删除数据）
7.创建拦截器，从session中获取用户的登录数据，验证能否访问系统
8.创建一个验证的jsp，如果验证视图，给出提示
9.创建springmvc配置文件
  声明组件扫描器
  声明拦截器
```

只有经过登录的用户方可访问处理器，否则，将返回“无权访问”提示。

本例的登录，由一个 JSP 页面完成。即在该页面里将用户信息放入 session 中。也就是
说，只要访问过该页面，就说明登录了。没访问过，则为未登录用户。

1. index.jsp 页面

   ```jsp
   <%@ page contentType="text/html;charset=UTF-8" language="java" %>
   <%
       String basePath = request.getScheme() + "://" +
               request.getServerName() + ":" + request.getServerPort() +
               request.getContextPath() + "/";
   %>
   <html>
   <head>
       <title>Title</title>
       <base href="<%=basePath%>" />
   </head>
   <body>
       <p>一个拦截器</p>
       <form action="some.do" method="post">
           姓名：<input type="text" name="name"> <br/>
           年龄：<input type="text" name="age"> <br/>
           <input type="submit" value="提交请求">
       </form>
   </body>
   </html>
   
   ```

2. Controller 类

   ```java
   package com.bjpowernode.controller;
   
   import org.springframework.stereotype.Controller;
   import org.springframework.web.bind.annotation.RequestMapping;
   import org.springframework.web.servlet.ModelAndView;
   
   @Controller
   public class MyController {
       @RequestMapping(value = "/some.do")
       public ModelAndView doSome(String name,Integer age) {
           System.out.println("=====执行MyController中的doSome方法=====");
           //处理some.do请求了。 相当于service调用处理完成了。
           ModelAndView mv  = new ModelAndView();
           mv.addObject("myname",name);
           mv.addObject("myage",age);
           mv.setViewName("show");
           return mv;
       }
   }
   ```

3. 定义权限拦截器

   当 preHandle()方法返回 false 时，需要使用 request 或 response 对请求进行响应。

   ```java
   package com.bjpowernode.handler;
   
   import org.springframework.web.servlet.HandlerInterceptor;
   import org.springframework.web.servlet.ModelAndView;
   
   import javax.servlet.http.HttpServletRequest;
   import javax.servlet.http.HttpServletResponse;
   import java.util.Date;
   
   //拦截器类：拦截用户的请求。
   public class MyInterceptor implements HandlerInterceptor {
       //验证登录的用户信息， 正确return true，其它return false
       @Override
       public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {
           System.out.println("111111-拦截器的MyInterceptor的preHandle()");
           String loginName = "";
           //从session中获取name的值
           Object attr  = request.getSession().getAttribute("name");
           if( attr != null){
               loginName = (String)attr;
           }
   
           //判断登录的账户，是否符合要求
           if( !"zs".equals(loginName)){
               //不能访问系统
               //给用户提示
               request.getRequestDispatcher("/tips.jsp").forward(request,response);
               return false;
           }
   
           //zs登录
           return true;
       }
   }
   ```

4. 注册权限拦截器

   在springmvc.xml中注册权限拦截器

   ```xml
   <?xml version="1.0" encoding="UTF-8"?>
   <beans xmlns="http://www.springframework.org/schema/beans"
          xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
          xmlns:context="http://www.springframework.org/schema/context"
          xmlns:mvc="http://www.springframework.org/schema/mvc"
          xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/mvc https://www.springframework.org/schema/mvc/spring-mvc.xsd">
       <!--声明组件扫描器-->
       <context:component-scan base-package="com.bjpowernode.controller" />
   
       <!--声明 springmvc框架中的视图解析器， 帮助开发人员设置视图文件的路径-->
       <bean  class="org.springframework.web.servlet.view.InternalResourceViewResolver">
           <!--前缀：视图文件的路径-->
           <property name="prefix" value="/WEB-INF/view/" />
           <!--后缀：视图文件的扩展名-->
           <property name="suffix" value=".jsp" />
       </bean>
   
       <!--声明拦截器： 拦截器可以有0或多个
           在框架中保存多个拦截器是ArrayList，
           按照声明的先后顺序放入到ArrayList
       -->
       <mvc:interceptors>
           <!--声明第一个拦截器-->
           <mvc:interceptor>
               <mvc:mapping path="/**"/>
               <!--声明拦截器对象-->
               <bean class="com.bjpowernode.handler.MyInterceptor" />
           </mvc:interceptor>
       </mvc:interceptors>
   </beans>
   ```

5. 定义页面

   login.jsp

   ```jsp
   <%@ page contentType="text/html;charset=UTF-8" language="java" %>
   <html>
   <head>
       <title>Title</title>
   </head>
   <body>
       模拟登录,zs登录系统
       <%
           session.setAttribute("name","zs");
       %>
   </body>
   </html>
   ```

   logout.jsp

   ```jsp
   <%@ page contentType="text/html;charset=UTF-8" language="java" %>
   <html>
   <head>
       <title>Title</title>
   </head>
   <body>
      退出系统，从session中删除数据
     <%
         session.removeAttribute("name");
     %>
   </body>
   </html>
   ```

   tips.jsp 请求被截止后

   ```jsp
   <%@ page contentType="text/html;charset=UTF-8" language="java" %>
   <html>
   <head>
       <title>Title</title>
   </head>
   <body>
     tips.jsp  非zs不能访问系统
   </body>
   </html>
   ```

   show.jsp 请求没被截止

   ```jsp
   <%@ page contentType="text/html;charset=UTF-8" language="java" %>
   <html>
   <head>
       <title>Title</title>
   </head>
   <body>
       <h3>/WEB-INF/view/show.jsp从request作用域获取数据</h3><br/>
       <h3>myname数据：${myname}</h3><br/>
       <h3>myage数据：${myage}</h3>
   </body>
   </html>
   ```

   
